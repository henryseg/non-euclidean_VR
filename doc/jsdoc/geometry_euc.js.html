<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: geometry/euc.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: geometry/euc.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Euclidean geometry
 *
 * @description
 * Extension of the abstract geometry modeule for the euclidean space.
 */

import {
  Matrix4,
  Vector4,
} from "../lib/three.module.js"

import {
  Isometry as AbstractIsometry,
  Point as AsbstractPoint,
  Vector as AbstractVector,
  Position as AbstractPosition,
} from "./abstract.js"


/**
 * @const {string}
 * @default computer name for the geometry
 */
const key='euc';
/**
 * @const {string}
 * @default Full name of the geometry
 */
const name='Euclidean space';


/**
 * @class
 * @classdesc
 * Euclidean isometries.
 * Represented as a 4x4 matrix.
 */
class Isometry extends AbstractIsometry {

  /**
   * Constructor.
   * Return the identity.
   * @property {Matrix4} matrix - The matrix represneting the isometry.
   */
  constructor() {
    super();
    this.matrix = new Matrix4();
  }

  /**
   * Set the current isometry with the given data.
   * @param {array} data - the first entry of data
   * should be the matrix representing the isometry
   * @return {Isometry}
   */
  set(data) {
    this.matrix = data[0].clone();
    return this;
  }

  /**
   * Reduce the eventual numerical errors of the current isometry
   * (typically Gram-Schmidt).
   * @return {Isometry}
   */
  reduceError() {
    return this;
  }

  /**
   * Multiply the current isometry by isom on the left, i.e. replace `this` by `this * isom`.
   * @param {Isometry} isom
   * @return {Isometry}
   */
  multiply(isom) {
    this.matrix.multiply(isom.matrix);
    return this;
  }

  /**
   * Multiply the current isometry by isom on the right, i.e. replace `this` by `isom * this`.
   * @param {Isometry} isom
   * @return {Isometry}
   */
  premultiply(isom) {
    this.matrix.premultiply(isom.matrix);
    return this;
  }

  /**
   * Set the current isometry to the inverse of `isom`.
   * @param {Isometry} isom
   * @return {Isometry}
   */
  getInverse(isom) {
    this.matrix.getInverse(isom.matrix);
    return this;
  }

  /**
   * Return a preferred isometry sending the origin to the given point
   * (typically in Nil, Sol, SL2, etc).
   * @param {Point} point
   * @return {Isometry}
   */
  makeTranslation(point) {
    [x,y,z,] = point.coords;
    this.matrix.set(
      1, 0, 0, x,
      0, 1, 0, y,
      0, 1, 0, z,
      0, 1, 0, 1,
    )
    return this;
  }

  /**
   * Return a preferred isometry sending the given point to the origin
   * (typically in Nil, Sol, SL2, etc).
   * @param {Point} point
   * @return {Isometry}
   */
  makeInvTranslation(point) {
    [x,y,z,] = point.coords;
    this.matrix.set(
      1, 0, 0, -x,
      0, 1, 0, -y,
      0, 1, 0, -z,
      0, 1, 0, 1,
    )
    return this;
  }


  /**
   * Check if the current isometry and `isom` are the same.
   * @param isom
   * @return {boolean}
   */
  equals(isom) {
    return this.matrix.equals(this.isom);
  }

  /**
   * Return a new copy of the current isometry.
   * @return {Isometry}
   */
  clone() {
    let res = new Isometry();
    res.set([this.matrix.clone()]);
    return res;
  }

  /**
   * Set the current isometry with the given isometry
   * @param {Isometry} isom
   * @return {Isometry}
   */
  copy(isom) {
    this.matrix.copy(isom.matrix);
    return this;
  }

  /**
   * Encode the isometry in a way that can be easily passed to the shader.
   * @todo Decide what type is used to pass a position to the shader
   */
  serialize() {
    return [this.matrix, 0];
  }
}

/**
 * @class
 *
 * @classdesc
 * Point in the geometry.
 */
class Point extends AsbstractPoint{

    /**
     * Constructor.
     * Return the origin of the space.
     * @property {Vector4} coords - the coordinates of the point
     */
    constructor() {
      super();
      this.coords = new Vector4(0,0,0,1);
    }

    /**
     * Update the current point with the given data.
     * @param {array} data - the first entry of data
     * are the coordinates of the point as a `Vector4`
     * @return {Point}
     */
    set(data) {
      this.coords = data[0].clone();
      return this;
    }

    /**
     * Translate the current point by the given isometry.
     * @param {Isometry} isom
     * @return {Point}
     */
    applyIsometry(isom) {
      this.coords.applyMatrix4(isom.matrix)
      return this;
    }


    /**
     * Check if the current point and `point ` are the same.
     * @param {Point} point
     * @return {boolean}
     */
    equals(point) {
      return this.coords.equals(point.coords)
    }

    /**
     * Return a new copy of the current point.
     * @return {Point}
     */
    clone() {
      let res = new Point()
      res.set([this.coords.clone()]);
      return res;
    }

    /**
     * set the current point with the given point
     * @param {Point} point
     * @return {Point}
     */
    copy(point) {
      this.coords.copy(point.coords);
      return this;
    }

    /**
     * Encode the point in a way that can be easily passed to the shader.
     * @todo Decide what type is used to pass a position to the shader
     */
    serialize() {
      return this.coords;
    }
}

/**
 * @class
 * @extends Vector3
 *
 * @classdesc
 * Tangent vector at the origin written in the reference frame.
 * Are available form three.js:
 * - all the linear algebra
 * - the length of a vector
 */
class Vector extends AbstractVector {

}


/**
 * @class
 *
 * @classdesc
 * Location and facing (of the observer, an object, etc).
 */
class Position extends AbstractPosition{

    /**
     * Return the type used for isometries.
     */
    get isometryType(){
      return Isometry;
    }

    /**
     * Return the type used for points.
     */
    get unserializePointType(){
      return Point;
    }

    /**
     * Return the type used for vectors.
     */
    get vectorType(){
      return Vector;
    }
}

export{
  key,
  name,
  Isometry,
  Point,
  Vector,
  Position
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Abstract.html">Abstract</a></li><li><a href="module-Euclidean%2520geometry.html">Euclidean geometry</a></li><li><a href="module-events.html">events</a></li><li><a href="module-Thurston.html">Thurston</a></li><li><a href="module-User%2520Interface.html">User Interface</a></li></ul><h3>Classes</h3><ul><li><a href="Controls.html">Controls</a></li><li><a href="module-Abstract-Isometry.html">Isometry</a></li><li><a href="module-Abstract-Point.html">Point</a></li><li><a href="module-Abstract-Position.html">Position</a></li><li><a href="module-Abstract-Vector.html">Vector</a></li><li><a href="module-Euclidean%2520geometry-Isometry.html">Isometry</a></li><li><a href="module-Euclidean%2520geometry-Point.html">Point</a></li><li><a href="module-Euclidean%2520geometry-Position.html">Position</a></li><li><a href="module-Euclidean%2520geometry-Vector.html">Vector</a></li><li><a href="module-Thurston-SceneItem.html">SceneItem</a></li><li><a href="module-Thurston-SceneMaterial.html">SceneMaterial</a></li><li><a href="module-Thurston-Thurston.html">Thurston</a></li></ul><h3>Global</h3><ul><li><a href="global.html#keyboard">keyboard</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sat Nov 14 2020 20:10:51 GMT+0100 (heure normale dâ€™Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
