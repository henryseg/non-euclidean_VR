<?xml version="1.0" encoding="UTF-8"?>
<library>
    <background>
        /**
        * Distance between two points
        */
        float dist(Point p1, Point p2){
        return acos(dot(p1.coords, p2.coords));
        }

        /**
        * Intensity of the light after travelling a length `len` in the direction `dir`
        * @param[in] dir unit vector at the light position
        * @param[in] len distance from the light
        * @return intensity of the light
        */
        float lightIntensity(float len){
        return 1./(len);
        }

        Vector direction(Point p, Point q) {
        float c = dot(p.coords, q.coords);
        vec4 dir = q.coords - c * p.coords;
        return geomNormalize(Vector(p,dir));
        }
    </background>
    <items>
        <solid class="ball">
            <shader type="declare">
                Solid {{name}};
            </shader>
            <shader type="setup">
                {{name}} = {{toGLSL}};
            </shader>
            <shader type="sdf">
                Point loc = {{name}}.obj.loc;
                {{#global}}
                loc = applyIsometry(v.invCellBoost, loc);
                {{/global}}
                return dist(v.local.pos, loc) - {{radius}};
            </shader>
            <shader type="gradient">
                Point loc = {{name}}.obj.loc;
                {{#global}}
                loc = applyIsometry(v.invCellBoost, loc);
                {{/global}}

                Vector local = direction(v.local.pos, loc);
                local = negate(local);
                return RelVector(local, v.cellBoost, v.invCellBoost);
            </shader>
        </solid>

        <solid class="ballComplement">
            <shader type="declare">
                Solid {{name}};
            </shader>
            <shader type="setup">
                {{name}} = {{toGLSL}};
            </shader>
            <shader type="sdf">
                Point loc = {{name}}.obj.loc;
                {{#global}}
                loc = applyIsometry(v.invCellBoost, loc);
                {{/global}}
                return {{radius}} - dist(v.local.pos, loc);
            </shader>
            <shader type="gradient">
                Point loc = {{name}}.obj.loc;
                {{#global}}
                loc = applyIsometry(v.invCellBoost, loc);
                {{/global}}

                Vector local = direction(v.local.pos, loc);
                return RelVector(local, v.cellBoost, v.invCellBoost);
            </shader>
        </solid>

        <light class="pointLight">
            <shader type="declare">
                Light {{name}};
            </shader>
            <shader type="setup">
                {{name}} = {{toGLSL}};
            </shader>
            <shader type="direction">
                Point loc = {{name}}.obj.loc;
                Point pos = v.local.pos;
                {{#global}}
                loc = applyIsometry(v.invCellBoost, loc);
                {{/global}}
                float dist = dist(pos,loc);
                intensities[0] = lightIntensity(dist);
                Vector local = direction(pos, loc);
                dirs[0] = RelVector(local, v.cellBoost, v.invCellBoost);
                return 1;
            </shader>
        </light>
    </items>
</library>