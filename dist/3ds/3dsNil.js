import*as e from"three";var t={9397:(e,t)=>{!function(e){var t=/\S/,n=/\"/g,r=/\n/g,a=/\r/g,o=/\\/g,s=/\u2028/,i=/\u2029/;function l(e){"}"===e.n.substr(e.n.length-1)&&(e.n=e.n.substring(0,e.n.length-1))}function c(e){return e.trim?e.trim():e.replace(/^\s*|\s*$/g,"")}function h(e,t,n){if(t.charAt(n)!=e.charAt(0))return!1;for(var r=1,a=e.length;r<a;r++)if(t.charAt(n+r)!=e.charAt(r))return!1;return!0}e.tags={"#":1,"^":2,"<":3,$:4,"/":5,"!":6,">":7,"=":8,_v:9,"{":10,"&":11,_t:12},e.scan=function(n,r){var a=n.length,o=0,s=null,i=null,d="",u=[],p=!1,m=0,b=0,v="{{",f="}}";function g(){d.length>0&&(u.push({tag:"_t",text:new String(d)}),d="")}function x(n,r){if(g(),n&&function(){for(var n=!0,r=b;r<u.length;r++)if(!(n=e.tags[u[r].tag]<e.tags._v||"_t"==u[r].tag&&null===u[r].text.match(t)))return!1;return n}())for(var a,o=b;o<u.length;o++)u[o].text&&((a=u[o+1])&&">"==a.tag&&(a.indent=u[o].text.toString()),u.splice(o,1));else r||u.push({tag:"\n"});p=!1,b=u.length}function y(e,t){var n="="+f,r=e.indexOf(n,t),a=c(e.substring(e.indexOf("=",t)+1,r)).split(" ");return v=a[0],f=a[a.length-1],r+n.length-1}for(r&&(r=r.split(" "),v=r[0],f=r[1]),m=0;m<a;m++)0==o?h(v,n,m)?(--m,g(),o=1):"\n"==n.charAt(m)?x(p):d+=n.charAt(m):1==o?(m+=v.length-1,"="==(s=(i=e.tags[n.charAt(m+1)])?n.charAt(m+1):"_v")?(m=y(n,m),o=0):(i&&m++,o=2),p=m):h(f,n,m)?(u.push({tag:s,n:c(d),otag:v,ctag:f,i:"/"==s?p-v.length:m+f.length}),d="",m+=f.length-1,o=0,"{"==s&&("}}"==f?m++:l(u[u.length-1]))):d+=n.charAt(m);return x(p,!0),u};var d={_t:!0,"\n":!0,$:!0,"/":!0};function u(t,n,r,a){var o,s=[],i=null,l=null;for(o=r[r.length-1];t.length>0;){if(l=t.shift(),o&&"<"==o.tag&&!(l.tag in d))throw new Error("Illegal content in < super tag.");if(e.tags[l.tag]<=e.tags.$||p(l,a))r.push(l),l.nodes=u(t,l.tag,r,a);else{if("/"==l.tag){if(0===r.length)throw new Error("Closing tag without opener: /"+l.n);if(i=r.pop(),l.n!=i.n&&!m(l.n,i.n,a))throw new Error("Nesting error: "+i.n+" vs. "+l.n);return i.end=l.i,s}"\n"==l.tag&&(l.last=0==t.length||"\n"==t[0].tag)}s.push(l)}if(r.length>0)throw new Error("missing closing tag: "+r.pop().n);return s}function p(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n].o==e.n)return e.tag="#",!0}function m(e,t,n){for(var r=0,a=n.length;r<a;r++)if(n[r].c==e&&n[r].o==t)return!0}function b(e){var t=[];for(var n in e.partials)t.push('"'+f(n)+'":{name:"'+f(e.partials[n].name)+'", '+b(e.partials[n])+"}");return"partials: {"+t.join(",")+"}, subs: "+function(e){var t=[];for(var n in e)t.push('"'+f(n)+'": function(c,p,t,i) {'+e[n]+"}");return"{ "+t.join(",")+" }"}(e.subs)}e.stringify=function(t,n,r){return"{code: function (c,p,i) { "+e.wrapMain(t.code)+" },"+b(t)+"}"};var v=0;function f(e){return e.replace(o,"\\\\").replace(n,'\\"').replace(r,"\\n").replace(a,"\\r").replace(s,"\\u2028").replace(i,"\\u2029")}function g(e){return~e.indexOf(".")?"d":"f"}function x(e,t){var n="<"+(t.prefix||"")+e.n+v++;return t.partials[n]={name:e.n,partials:{}},t.code+='t.b(t.rp("'+f(n)+'",c,p,"'+(e.indent||"")+'"));',n}function y(e,t){t.code+="t.b(t.t(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'}function V(e){return"t.b("+e+");"}e.generate=function(t,n,r){v=0;var a={code:"",subs:{},partials:{}};return e.walk(t,a),r.asString?this.stringify(a,n,r):this.makeTemplate(a,n,r)},e.wrapMain=function(e){return'var t=this;t.b(i=i||"");'+e+"return t.fl();"},e.template=e.Template,e.makeTemplate=function(e,t,n){var r=this.makePartials(e);return r.code=new Function("c","p","i",this.wrapMain(e.code)),new this.template(r,t,this,n)},e.makePartials=function(e){var t,n={subs:{},partials:e.partials,name:e.name};for(t in n.partials)n.partials[t]=this.makePartials(n.partials[t]);for(t in e.subs)n.subs[t]=new Function("c","p","t","i",e.subs[t]);return n},e.codegen={"#":function(t,n){n.code+="if(t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,0,'+t.i+","+t.end+',"'+t.otag+" "+t.ctag+'")){t.rs(c,p,function(c,p,t){',e.walk(t.nodes,n),n.code+="});c.pop();}"},"^":function(t,n){n.code+="if(!t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,1,0,0,"")){',e.walk(t.nodes,n),n.code+="};"},">":x,"<":function(t,n){var r={partials:{},code:"",subs:{},inPartial:!0};e.walk(t.nodes,r);var a=n.partials[x(t,n)];a.subs=r.subs,a.partials=r.partials},$:function(t,n){var r={subs:{},code:"",partials:n.partials,prefix:t.n};e.walk(t.nodes,r),n.subs[t.n]=r.code,n.inPartial||(n.code+='t.sub("'+f(t.n)+'",c,p,i);')},"\n":function(e,t){t.code+=V('"\\n"'+(e.last?"":" + i"))},_v:function(e,t){t.code+="t.b(t.v(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'},_t:function(e,t){t.code+=V('"'+f(e.text)+'"')},"{":y,"&":y},e.walk=function(t,n){for(var r,a=0,o=t.length;a<o;a++)(r=e.codegen[t[a].tag])&&r(t[a],n);return n},e.parse=function(e,t,n){return u(e,0,[],(n=n||{}).sectionTags||[])},e.cache={},e.cacheKey=function(e,t){return[e,!!t.asString,!!t.disableLambda,t.delimiters,!!t.modelGet].join("||")},e.compile=function(t,n){n=n||{};var r=e.cacheKey(t,n),a=this.cache[r];if(a){var o=a.partials;for(var s in o)delete o[s].instance;return a}return a=this.generate(this.parse(this.scan(t,n.delimiters),t,n),t,n),this.cache[r]=a}}(t)},5485:(e,t,n)=>{var r=n(9397);r.Template=n(2882).Template,r.template=r.Template,e.exports=r},2882:(e,t)=>{!function(e){function t(e,t,n){var r;return t&&"object"==typeof t&&(void 0!==t[e]?r=t[e]:n&&t.get&&"function"==typeof t.get&&(r=t.get(e))),r}e.Template=function(e,t,n,r){e=e||{},this.r=e.code||this.r,this.c=n,this.options=r||{},this.text=t||"",this.partials=e.partials||{},this.subs=e.subs||{},this.buf=""},e.Template.prototype={r:function(e,t,n){return""},v:function(e){return e=l(e),i.test(e)?e.replace(n,"&amp;").replace(r,"&lt;").replace(a,"&gt;").replace(o,"&#39;").replace(s,"&quot;"):e},t:l,render:function(e,t,n){return this.ri([e],t||{},n)},ri:function(e,t,n){return this.r(e,t,n)},ep:function(e,t){var n=this.partials[e],r=t[n.name];if(n.instance&&n.base==r)return n.instance;if("string"==typeof r){if(!this.c)throw new Error("No compiler available.");r=this.c.compile(r,this.options)}if(!r)return null;if(this.partials[e].base=r,n.subs){for(key in t.stackText||(t.stackText={}),n.subs)t.stackText[key]||(t.stackText[key]=void 0!==this.activeSub&&t.stackText[this.activeSub]?t.stackText[this.activeSub]:this.text);r=function(e,t,n,r,a,o){function s(){}function i(){}var l;s.prototype=e,i.prototype=e.subs;var c=new s;for(l in c.subs=new i,c.subsText={},c.buf="",r=r||{},c.stackSubs=r,c.subsText=o,t)r[l]||(r[l]=t[l]);for(l in r)c.subs[l]=r[l];for(l in a=a||{},c.stackPartials=a,n)a[l]||(a[l]=n[l]);for(l in a)c.partials[l]=a[l];return c}(r,n.subs,n.partials,this.stackSubs,this.stackPartials,t.stackText)}return this.partials[e].instance=r,r},rp:function(e,t,n,r){var a=this.ep(e,n);return a?a.ri(t,n,r):""},rs:function(e,t,n){var r=e[e.length-1];if(c(r))for(var a=0;a<r.length;a++)e.push(r[a]),n(e,t,this),e.pop();else n(e,t,this)},s:function(e,t,n,r,a,o,s){var i;return(!c(e)||0!==e.length)&&("function"==typeof e&&(e=this.ms(e,t,n,r,a,o,s)),i=!!e,!r&&i&&t&&t.push("object"==typeof e?e:t[t.length-1]),i)},d:function(e,n,r,a){var o,s=e.split("."),i=this.f(s[0],n,r,a),l=this.options.modelGet,h=null;if("."===e&&c(n[n.length-2]))i=n[n.length-1];else for(var d=1;d<s.length;d++)void 0!==(o=t(s[d],i,l))?(h=i,i=o):i="";return!(a&&!i)&&(a||"function"!=typeof i||(n.push(h),i=this.mv(i,n,r),n.pop()),i)},f:function(e,n,r,a){for(var o=!1,s=!1,i=this.options.modelGet,l=n.length-1;l>=0;l--)if(void 0!==(o=t(e,n[l],i))){s=!0;break}return s?(a||"function"!=typeof o||(o=this.mv(o,n,r)),o):!a&&""},ls:function(e,t,n,r,a){var o=this.options.delimiters;return this.options.delimiters=a,this.b(this.ct(l(e.call(t,r)),t,n)),this.options.delimiters=o,!1},ct:function(e,t,n){if(this.options.disableLambda)throw new Error("Lambda features disabled.");return this.c.compile(e,this.options).render(t,n)},b:function(e){this.buf+=e},fl:function(){var e=this.buf;return this.buf="",e},ms:function(e,t,n,r,a,o,s){var i,l=t[t.length-1],c=e.call(l);return"function"==typeof c?!!r||(i=this.activeSub&&this.subsText&&this.subsText[this.activeSub]?this.subsText[this.activeSub]:this.text,this.ls(c,l,n,i.substring(a,o),s)):c},mv:function(e,t,n){var r=t[t.length-1],a=e.call(r);return"function"==typeof a?this.ct(l(a.call(r)),r,n):a},sub:function(e,t,n,r){var a=this.subs[e];a&&(this.activeSub=e,a(t,n,this,r),this.activeSub=!1)}};var n=/&/g,r=/</g,a=/>/g,o=/\'/g,s=/\"/g,i=/[&<>\"\']/;function l(e){return String(null==e?"":e)}var c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}}(t)},9606:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n, r);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, rayType);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n, r);\n}\n\nvec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    return render({{name}}, v, rayType);\n}",r);return e.render.apply(e,arguments)}},9909:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);"),r.b("\n"+n),r.b("    //return vec4(debugColor,1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);\n    //return vec4(debugColor,1);\n}",r);return e.render.apply(e,arguments)}},8906:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},1998:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,220,289,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,481,540,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},699:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,405,478,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,580,881,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,764,845,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1119,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1289,1570,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1464,1535,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},4261:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,210,275,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,463,518,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},8474:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},5506:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,171,240,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,432,491,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},7397:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,356,429,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,531,832,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,715,796,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1070,1133,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1240,1521,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1415,1486,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},3045:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,161,226,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,414,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},6077:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    return normalMaterialRender(v, normal);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    return normalMaterialRender(v, normal);\n}",r);return e.render.apply(e,arguments)}},1202:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n,r);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n,r);\n}",r);return e.render.apply(e,arguments)}},2330:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v).rgb;\n}",r);return e.render.apply(e,arguments)}},9040:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, normal).rgb;\n}",r);return e.render.apply(e,arguments)}},588:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;   "),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;   \n    }\n    return {{material.name}}_render(v, normal, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},1365:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("      return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n      return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},8149:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,204,519,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongMaterial material = {{name}};\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},3838:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,261,587,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},472:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,269,595,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},7660:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,282,608,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},8204:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,275,601,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},5377:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.b("        color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    color0 = {{mat0.name}}_render(v);\n\n    if(v.vector.cellBoost == material.cellBoost){\n        color1 = {{mat1.name}}_render(v);\n    } else{\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},9441:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,156,212,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,405,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else {"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionLocalWrapMaterial material = {{name}};\n    vec4 color0, color1;\n    {{#mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v, normal);\n        {{/mat1.usesNormal}}\n        {{^mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v);\n        {{/mat1.usesNormal}}\n    } else {\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},9245:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,296,355,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,429,658,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,567,634,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,834,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,1017,1274,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1171,1246,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            {{^mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal);\n            {{/mat1.usesUVMap}}\n            {{#mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal, uv);\n            {{/mat1.usesUVMap}}\n        {{/mat1.usesNormal}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},6766:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,147,198,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,386,445,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},8402:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    TransitionWrapMaterial material = {{name}};\n\n    vec4 color0 = {{mat0.name}}_render(v);\n    vec4 color1 = {{mat1.name}}_render(v);\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},6158:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,127,188,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,332,393,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    {{#mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v, normal);\n    {{/mat1.usesNormal}}\n    {{^mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v);\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},4146:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,271,335,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,409,648,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,552,624,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,829,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,967,1206,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1110,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n    \n    {{#mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},2332:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,117,173,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,312,368,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    {{#mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v, uv);\n    {{/mat1.usesUVMap}}\n    {{^mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v);\n    {{/mat1.usesUVMap}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},6142:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return negate("),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v));"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the complement of a shape\n */\nRelVector {{name}}_gradient(RelVector v){\n    return negate({{shape.name}}_gradient(v));\n}",r);return e.render.apply(e,arguments)}},7939:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    return - "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the complement of a shape\n */\nfloat {{name}}_sdf(RelVector v){\n    return - {{shape.name}}_sdf(v);\n}",r);return e.render.apply(e,arguments)}},7260:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},6861:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMaxPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMaxPoly(dist1, dist2, grad1, grad2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},3335:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the intersection of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6428:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMaxPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMaxPoly(dist1, dist2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},2076:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return max(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the intersection of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return max(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},2905:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},8655:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMinPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMinPoly(dist1, dist2, grad1, grad2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},7762:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},3238:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMinPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMinPoly(dist1, dist2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},3908:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return min(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return min(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},7500:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6242:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for a wrapping\n */\nRelVector {{name}}_gradient(RelVector v){\n    return {{shape.name}}_gradient(v);\n}",r);return e.render.apply(e,arguments)}},3105:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float wrap = "),r.b(r.v(r.d("wrap.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(wrap > camera.threshold){"),r.b("\n"+n),r.b("        return wrap;"),r.b("\n"+n),r.b("    } else {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for a wrapping\n */\nfloat {{name}}_sdf(RelVector v){\n    float wrap = {{wrap.name}}_sdf(v);\n    if(wrap > camera.threshold){\n        return wrap;\n    } else {\n        return {{shape.name}}_sdf(v);\n    }\n}",r);return e.render.apply(e,arguments)}},9338:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},7577:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("bool "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(RelVector v, int i, out RelVector dir, out float intensity) {"),r.b("\n"+n),r.b("    return directions("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, i, dir, intensity);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"bool {{name}}_directions(RelVector v, int i, out RelVector dir, out float intensity) {\n    return directions({{name}}, v, i, dir, intensity);\n}",r);return e.render.apply(e,arguments)}},8778:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return render({{name}}, v);\n}\n",r);return e.render.apply(e,arguments)}},1215:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, uv);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    return render({{name}}, v, uv);\n}\n",r);return e.render.apply(e,arguments)}},2044:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1403,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1386,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representation of v can be updated"),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2169,2585,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2232,2533,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3143,3524,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3165,3506,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representation of v can be updated\n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},7781:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec4 color;"),r.b("\n"+n),r.b("    vec4 reflectivity;"),r.b("\n"+n),r.b("    float opacity;"),r.b("\n"+n),r.b("    float t;"),r.b("\n"),r.b("\n"+n),r.b("    switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,315,5918,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,0,373,2190,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,589,724,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,822,1314,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,1071,1278,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("            if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                opacity = 1.;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else {"),r.b("\n"+n),r.b("                opacity = color.a;"),r.b("\n"+n),r.b("            }"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,1525,1604,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                //color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("            if(opacity == 1.) {"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else{"),r.b("\n"+n),r.b("                v.data.stop = false;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;"),r.b("\n"+n),r.b("            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;"),r.b("\n"+n),r.b("            "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack = false;"),r.b("\n"+n),r.b("            v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("            v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("            //v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,1,0,0,"")||(r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,0,2294,4409,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("                if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                    reflectivity = vec4(0);"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else {"),r.b("\n"+n),r.b("                    reflectivity = vec4("),r.b(r.v(r.d("material.name",e,t,0))),r.b(".reflectivity,1);"),r.b("\n"+n),r.b("                }"),r.b("\n"),r.b("\n"+n),r.b("                normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                // in general the gradient is not necessarily a unit vector"),r.b("\n"+n),r.b("                normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,2944,3091,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,3197,3593,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,3398,3553,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,3649,3734,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                if(length(reflectivity) == 0.) {"),r.b("\n"+n),r.b("                    v.data.stop = true;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else{"),r.b("\n"+n),r.b("                    v.data.stop = false;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;"),r.b("\n"+n),r.b("                v.vector = geomReflect(v.vector,normal);"),r.b("\n"+n),r.b("                v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("                v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("                v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,4710,4857,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,4963,5495,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,5232,5455,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,5551,5636,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n)),r.b("\n"+n)),r.b("        break;"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec4 color = "),r.b(r.v(r.d("scene.background.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));\n}\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    vec2 uv;\n    vec4 color;\n    vec4 reflectivity;\n    float opacity;\n    float t;\n\n    switch(objId){\n    {{#scene.solids}}\n\n        case {{id}}:\n        {{#material.isTransparent}}\n\n            {{^material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color =  {{material.name}}_render(v);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            {{#material.usesNormal}}\n                {{^material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    color = {{material.name}}_render(v, normal);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, normal, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            if(v.data.iBounce == maxBounces){\n                opacity = 1.;\n            }\n            else {\n                opacity = color.a;\n            }\n\n            {{#scene.fog}}\n                //color = applyFog(color, v.data.lastBounceDist);\n            {{/scene.fog}}\n\n            if(opacity == 1.) {\n                v.data.stop = true;\n            }\n            else{\n                v.data.stop = false;\n            }\n            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;\n            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;\n            {{name}}_isRenderedHack = false;\n            v.data.lastBounceDist = 0.;\n            v.data.iBounce = v.data.iBounce + 1;\n            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n            //v = flow(v, t);\n\n        {{/material.isTransparent}}\n\n        {{^material.isTransparent}}\n\n            {{#material.isReflecting}}\n\n                if(v.data.iBounce == maxBounces){\n                    reflectivity = vec4(0);\n                }\n                else {\n                    reflectivity = vec4({{material.name}}.reflectivity,1);\n                }\n\n                normal = {{shape.name}}_gradient(v.vector);\n                // in general the gradient is not necessarily a unit vector\n                normal = geomNormalize(normal);\n\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                if(length(reflectivity) == 0.) {\n                    v.data.stop = true;\n                }\n                else{\n                    v.data.stop = false;\n                }\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;\n                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;\n                v.vector = geomReflect(v.vector,normal);\n                v.data.lastBounceDist = 0.;\n                v.data.iBounce = v.data.iBounce + 1;\n                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n                v = flow(v, t);\n\n            {{/material.isReflecting}}\n\n            {{^material.isReflecting}}\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n                v.data.leftToComputeColor = vec4(0);\n                v.data.stop = true;\n            {{/material.isReflecting}}\n\n        {{/material.isTransparent}}\n        break;\n\n    {{/scene.solids}}\n    }\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec4 color = {{scene.background.name}}_render(v);\n        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},4122:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * We assume that we are inside a solid"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("void nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    ior = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.ior; // index of the "air"'),r.b("\n"+n),r.b("    absorb = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.absorb; // absorb of the "air"'),r.b("\n"+n),r.b("    emission=vec3(0,0,0);//no emission from 'air'"),r.b("\n"+n),r.b("    opticalDepth="),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.opticalDepth; // opticalDepth of the "air"'),r.b("\n"+n),r.b("    isInside = false;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    RelVector v = flow(normal, 2. * camera.threshold);"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,579,1010,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("            dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("            if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                ior = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("                absorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("                emission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("                opticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("                isInside = true;"),r.b("\n"+n),r.b("                return;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("}"),r.fl()},partials:{},subs:{}},'/**\n * We assume that we are inside a solid\n */\nvoid nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){\n    float dist;\n    ior = {{scene.ptBackground.name}}.ior; // index of the "air"\n    absorb = {{scene.ptBackground.name}}.absorb; // absorb of the "air"\n    emission=vec3(0,0,0);//no emission from \'air\'\n    opticalDepth={{scene.ptBackground.name}}.opticalDepth; // opticalDepth of the "air"\n    isInside = false;\n    \n    RelVector v = flow(normal, 2. * camera.threshold);\n    {{#scene.solids}}\n        if({{name}}.isRendered){\n            dist = {{shape.name}}_sdf(v);\n            if(dist < camera.threshold) {\n                ior = {{ptMaterial.name}}.ior;\n                absorb = {{ptMaterial.name}}.absorb;\n                emission = {{ptMaterial.name}}.volumeEmission;\n                opticalDepth = {{ptMaterial.name}}.opticalDepth;\n                isInside = true;\n                return;\n            }\n        }\n    {{/scene.solids}}\n}',r);return e.render.apply(e,arguments)}},6172:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1381,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1364,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representatiion of v can be updated "),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2149,2565,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2212,2513,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3123,3482,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3145,3464,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representatiion of v can be updated \n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},6272:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".absorb, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".volumeEmission, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".opticalDepth, false);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void roulette(inout ExtVector v){"),r.b("\n"+n),r.b("    // as the light left gets smaller, the ray is more likely to get terminated early."),r.b("\n"+n),r.b("    // survivors have their value boosted to make up for fewer samples being in the average."),r.b("\n"+n),r.b("    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));"),r.b("\n"+n),r.b("    if (randomFloat() > p){"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    // add the energy we 'lose' by randomly terminating paths"),r.b("\n"+n),r.b("    v.data.light = v.data.light / p;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    RayType rayType;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec3 color;"),r.b("\n"+n),r.b("    vec3 reflectivity;"),r.b("\n"+n),r.b("    float hackCoeff = 1.;"),r.b("\n"+n),r.b("    float r; /** ratio of IOR */"),r.b("\n"+n),r.b("    float nextIOR; /** IOR of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextAbsorb; /** absorb of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextEmission;/** volumetric emission of the neighbor solid */"),r.b("\n"+n),r.b("    float nextOpticalDepth;/** optical depth of the neighbor solid */"),r.b("\n"+n),r.b("    bool nextIsInside = true;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector diffuseDir;"),r.b("\n"+n),r.b("    RelVector reflectDir;"),r.b("\n"+n),r.b("    RelVector refractDir;"),r.b("\n"),r.b("\n"+n),r.b("    // get a uniformly distributed vector on the sphere"),r.b("\n"+n),r.b("    RelVector random = randomVector(v.vector);"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("    //get volumetric coloring:"),r.b("\n"+n),r.b("    //portion of light is absorbed."),r.b("\n"+n),r.b("    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    //light is emitted along the journey (linear or expoenential pickup)"),r.b("\n"+n),r.b("    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;"),r.b("\n"+n),r.b("    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);"),r.b("\n"),r.b("\n"+n),r.b("    //use these quantities to update pixel and light:"),r.b("\n"+n),r.b("    v.data.light = v.data.light * volAbsorb;"),r.b("\n"+n),r.b("    v.data.pixel = v.data.pixel + v.data.light*volEmit;"),r.b("\n"+n),r.b("    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output"),r.b("\n"+n),r.b("    "),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,2036,5260,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("    "),r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.b("            normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("            normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.b("            "),r.b("\n"+n),r.b("            // get info and reset normal based on which side we are on."),r.b("\n"+n),r.b('            // starting assumption: in the "air"'),r.b("\n"+n),r.b("            r = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".ior / "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("            nextAbsorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("            nextEmission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("            nextOpticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(v.data.isInside){"),r.b("\n"+n),r.b("                //things to change if we are inside a material instead:"),r.b("\n"+n),r.b("                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);"),r.b("\n"+n),r.b("                r = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior / nextIOR;"),r.b("\n"+n),r.b("                normal = negate(normal);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            rayType = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_setRayType(v, normal,r);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color =  "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, rayType);"),r.b("\n"+n)),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,0,3160,3302,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                color = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, uv, rayType);"),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("        // hack to make sure that lights are not too bright"),r.b("\n"+n),r.b("            if(v.data.iBounce == 0){"),r.b("\n"+n),r.b("                hackCoeff = 0.2;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            //apply surface effects"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".emission;"),r.b("\n"+n),r.b("            if(!rayType.refract){"),r.b("\n"+n),r.b("                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);"),r.b("\n"+n),r.b("             }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            // update the ray direction"),r.b("\n"+n),r.b("            // diffuse uses a normal oriented cosine weighted hemisphere sample."),r.b("\n"+n),r.b("            diffuseDir = geomNormalize(add(normal, random));"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.diffuse){"),r.b("\n"+n),r.b("                v.vector = diffuseDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.reflect){"),r.b("\n"+n),r.b("                // perfectly smooth specular uses the reflection ray."),r.b("\n"+n),r.b("                reflectDir = geomReflect(v.vector, normal);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                v.vector = reflectDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.refract){"),r.b("\n"+n),r.b("                    refractDir = geomRefract(v.vector,normal, r);"),r.b("\n"+n),r.b("                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                    v.data.isInside = nextIsInside;"),r.b("\n"+n),r.b("                    v.data.currentAbsorb = nextAbsorb;"),r.b("\n"+n),r.b("                    v.data.currentEmission = nextEmission;"),r.b("\n"+n),r.b("                    v.data.currentOpticalDepth = nextOpticalDepth;"),r.b("\n"+n),r.b("                    v.vector = refractDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("    v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("    // be carefull, v is not normal to the surface"),r.b("\n"+n),r.b("    // if the time we flow is too small, we are still below the camera threshold"),r.b("\n"+n),r.b("    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("    v = flow(v, t);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor.rgb;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec3 bgColor = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".diffuse;"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.light * bgColor;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        roulette(v);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), {{scene.ptBackground.name}}.absorb, {{scene.ptBackground.name}}.volumeEmission, {{scene.ptBackground.name}}.opticalDepth, false);\n}\n\n\n\nvoid roulette(inout ExtVector v){\n    // as the light left gets smaller, the ray is more likely to get terminated early.\n    // survivors have their value boosted to make up for fewer samples being in the average.\n    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));\n    if (randomFloat() > p){\n        v.data.stop = true;\n    }\n    // add the energy we 'lose' by randomly terminating paths\n    v.data.light = v.data.light / p;\n}\n\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    RayType rayType;\n    vec2 uv;\n    vec3 color;\n    vec3 reflectivity;\n    float hackCoeff = 1.;\n    float r; /** ratio of IOR */\n    float nextIOR; /** IOR of the neighbor solid */\n    vec3 nextAbsorb; /** absorb of the neighbor solid */\n    vec3 nextEmission;/** volumetric emission of the neighbor solid */\n    float nextOpticalDepth;/** optical depth of the neighbor solid */\n    bool nextIsInside = true;\n\n    RelVector diffuseDir;\n    RelVector reflectDir;\n    RelVector refractDir;\n\n    // get a uniformly distributed vector on the sphere\n    RelVector random = randomVector(v.vector);\n\n\n\n\n\n    //get volumetric coloring:\n    //portion of light is absorbed.\n    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);\n    \n    //light is emitted along the journey (linear or expoenential pickup)\n    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;\n    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);\n\n    //use these quantities to update pixel and light:\n    v.data.light = v.data.light * volAbsorb;\n    v.data.pixel = v.data.pixel + v.data.light*volEmit;\n    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output\n    \n\n\n\n\n\n\nswitch(objId){\n    {{#scene.solids}}\n    \n        case {{id}}:\n            normal = {{shape.name}}_gradient(v.vector);\n            normal = geomNormalize(normal);\n\n            \n            // get info and reset normal based on which side we are on.\n            // starting assumption: in the \"air\"\n            r = {{scene.ptBackground.name}}.ior / {{ptMaterial.name}}.ior;\n            nextAbsorb = {{ptMaterial.name}}.absorb;\n            nextEmission = {{ptMaterial.name}}.volumeEmission;\n            nextOpticalDepth = {{ptMaterial.name}}.opticalDepth;\n        \n            if(v.data.isInside){\n                //things to change if we are inside a material instead:\n                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);\n                r = {{ptMaterial.name}}.ior / nextIOR;\n                normal = negate(normal);\n            }\n        \n            rayType = {{ptMaterial.name}}_setRayType(v, normal,r);\n        \n            {{^ptMaterial.usesUVMap}}\n                color =  {{ptMaterial.name}}_render(v, normal, rayType);\n            {{/ptMaterial.usesUVMap}}\n            {{#ptMaterial.usesUVMap}}\n                uv = {{shape.name}}_uvMap(v.vector);\n                color = {{ptMaterial.name}}_render(v, normal, uv, rayType);\n            {{/ptMaterial.usesUVMap}}\n        \n        \n        // hack to make sure that lights are not too bright\n            if(v.data.iBounce == 0){\n                hackCoeff = 0.2;\n            }\n        \n            //apply surface effects\n            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * {{ptMaterial.name}}.emission;\n            if(!rayType.refract){\n                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);\n             }\n        \n            // update the ray direction\n            // diffuse uses a normal oriented cosine weighted hemisphere sample.\n            diffuseDir = geomNormalize(add(normal, random));\n        \n            if(rayType.diffuse){\n                v.vector = diffuseDir;\n            }\n        \n            if(rayType.reflect){\n                // perfectly smooth specular uses the reflection ray.\n                reflectDir = geomReflect(v.vector, normal);\n        \n                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                v.vector = reflectDir;\n            }\n        \n            if(rayType.refract){\n                    refractDir = geomRefract(v.vector,normal, r);\n                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                    v.data.isInside = nextIsInside;\n                    v.data.currentAbsorb = nextAbsorb;\n                    v.data.currentEmission = nextEmission;\n                    v.data.currentOpticalDepth = nextOpticalDepth;\n                    v.vector = refractDir;\n            }\n            break;\n    \n    {{/scene.solids}}\n    }\n\n    v.data.lastBounceDist = 0.;\n    v.data.iBounce = v.data.iBounce + 1;\n    // be carefull, v is not normal to the surface\n    // if the time we flow is too small, we are still below the camera threshold\n    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n    v = flow(v, t);\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor.rgb;\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec3 bgColor = {{scene.ptBackground.name}}.diffuse;\n        v.data.pixel = v.data.pixel + v.data.light * bgColor;\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        roulette(v);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},5030:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return gradient("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    return gradient({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},8266:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float newEp = 0.001;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));"),r.b("\n"+n),r.b("    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));"),r.b("\n"),r.b("\n"+n),r.b("    float vgx = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPX) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMX);"),r.b("\n"+n),r.b("    float vgy = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPY) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMY);"),r.b("\n"+n),r.b("    float vgz = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPZ) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMZ);"),r.b("\n"+n),r.b("    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));"),r.b("\n"),r.b("\n"+n),r.b("    n = geomNormalize(n);"),r.b("\n"+n),r.b("    return n;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    float newEp = 0.001;\n\n    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));\n    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));\n    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));\n    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));\n    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));\n    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));\n\n    float vgx = {{name}}_sdf(shiftPX) - {{name}}_sdf(shiftMX);\n    float vgy = {{name}}_sdf(shiftPY) - {{name}}_sdf(shiftMY);\n    float vgz = {{name}}_sdf(shiftPZ) - {{name}}_sdf(shiftMZ);\n    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));\n\n    n = geomNormalize(n);\n    return n;\n}",r);return e.render.apply(e,arguments)}},3707:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v) {"),r.b("\n"+n),r.b("    return sdf("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"float {{name}}_sdf(RelVector v) {\n    return sdf({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},4355:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return uvMap("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return uvMap({{name}}, v);\n}",r);return e.render.apply(e,arguments)}},3148:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Default creeping function (binary search)"),r.b("\n"+n),r.b(" * @param start starting point of the creeping"),r.b("\n"+n),r.b(" * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)"),r.b("\n"+n),r.b(" * @param offset how long we flow after passing the boundary"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(ExtVector v, ExtVector outside,  float offset){"),r.b("\n"+n),r.b("    ExtVector try = outside;"),r.b("\n"+n),r.b("    float sIn = 0.;"),r.b("\n"+n),r.b("    float sOut = try.data.lastFlowDist;"),r.b("\n"+n),r.b("    float s;"),r.b("\n"+n),r.b("    for(int i=0; i < 100; i++){"),r.b("\n"+n),r.b("        if(sOut - sIn < offset){"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("        s = 0.5 * sIn + 0.5 * sOut;"),r.b("\n"+n),r.b("        try = flow(v,s);"),r.b("\n"+n),r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("            sOut = s;"),r.b("\n"+n),r.b("            outside = try;"),r.b("\n"+n),r.b("        } else {"),r.b("\n"+n),r.b("            sIn = s;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return sOut;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Default creeping function (binary search)\n * @param start starting point of the creeping\n * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)\n * @param offset how long we flow after passing the boundary\n */\nfloat {{glslCreepName}}(ExtVector v, ExtVector outside,  float offset){\n    ExtVector try = outside;\n    float sIn = 0.;\n    float sOut = try.data.lastFlowDist;\n    float s;\n    for(int i=0; i < 100; i++){\n        if(sOut - sIn < offset){\n            break;\n        }\n        s = 0.5 * sIn + 0.5 * sOut;\n        try = flow(v,s);\n        if({{glslTestName}}(try.vector.local.pos)){\n            sOut = s;\n            outside = try;\n        } else {\n            sIn = s;\n        }\n    }\n    return sOut;\n}",r);return e.render.apply(e,arguments)}},5103:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* Teleportation."),r.b("\n"+n),r.b("* Check if the local vector is still in the fundamental domain define by the teleportation tests."),r.b("\n"+n),r.b("* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true"),r.b("\n"+n),r.b("* Otherwise, do nothing and set teleported to false"),r.b("\n"+n),r.b("* @param[in] v the relative vector to teleport."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("ExtVector teleport(ExtVector v){"),r.b("\n"+n),r.b("    v.data.isTeleported = false;"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,424,621,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(v.vector.local.pos)){"),r.b("\n"+n),r.b("            v.vector = rewrite(v.vector, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("            v.data.isTeleported = true;"),r.b("\n"+n),r.b("            return v;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    return v;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Does one of the two following transformation:"),r.b("\n"+n),r.b("* flow the vector by the given time, if the vector escape the fundamental domain,"),r.b("\n"+n),r.b("* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain"),r.b("\n"+n),r.b("* (and even a bit further)"),r.b("\n"+n),r.b("*"),r.b("\n"+n),r.b("* @param[inout] v the relative vector to flow / teleport / creep."),r.b("\n"+n),r.b("* @param[in] t the (maximal) time to flow"),r.b("\n"+n),r.b("* @param[in] offset the amount we march passed the boundary"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float creepingDist(ExtVector v, float t, float offset){"),r.b("\n"+n),r.b("    float res = t;"),r.b("\n"+n),r.b("    ExtVector try = flow(v, t);"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,1233,1638,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.f("usesCreepingCustom",e,t,1),e,t,0,1266,1407,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.f("usesCreepingBinary",e,t,1),e,t,0,1463,1609,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, try, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n)})),e.pop()),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"/**\n* Teleportation.\n* Check if the local vector is still in the fundamental domain define by the teleportation tests.\n* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true\n* Otherwise, do nothing and set teleported to false\n* @param[in] v the relative vector to teleport.\n*/\nExtVector teleport(ExtVector v){\n    v.data.isTeleported = false;\n    {{#teleportations}}\n        if({{glslTestName}}(v.vector.local.pos)){\n            v.vector = rewrite(v.vector, {{elt.name}}, {{inv.name}});\n            v.data.isTeleported = true;\n            return v;\n        }\n    {{/teleportations}}\n    return v;\n}\n\n\n/**\n* Does one of the two following transformation:\n* flow the vector by the given time, if the vector escape the fundamental domain,\n* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain\n* (and even a bit further)\n*\n* @param[inout] v the relative vector to flow / teleport / creep.\n* @param[in] t the (maximal) time to flow\n* @param[in] offset the amount we march passed the boundary\n*/\nfloat creepingDist(ExtVector v, float t, float offset){\n    float res = t;\n    ExtVector try = flow(v, t);\n    {{#teleportations}}\n\n        {{#usesCreepingCustom}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, offset));\n            }\n        {{/usesCreepingCustom}}\n\n        {{#usesCreepingBinary}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, try, offset));\n            }\n        {{/usesCreepingBinary}}\n\n    {{/teleportations}}\n    return res;\n}\n\n\n",r);return e.render.apply(e,arguments)}},9188:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                               \n                                                                                                                        \n\nstruct GroupElement {\n    bool fake;                                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(true);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(true);\n}\n\n                                              \n                                \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return IDENTITY;\n}"},5363:e=>{e.exports="   \n                                                                \n   \nfloat fresnelReflectAmount(RelVector incident, RelVector normal, float r, float reflecAt0, float relfectAt90) {\n                           \n    float r0 = (r - 1.) / (r + 1.);\n    r0 = r0 * r0;\n    float cosX = -geomDot(normal, incident);\n    if (r > 1.)\n    {\n        float sinT2 = r * r * (1. - cosX * cosX);\n                                    \n        if (sinT2 > 1.){\n            return relfectAt90;\n        }\n        cosX = sqrt(1. - sinT2);\n    }\n    float x = 1.- cosX;\n    float ret = clamp(r0 + (1. - r0) * x * x * x * x * x, 0., 1.);\n\n                                                        \n                               \n    return reflecAt0 + (relfectAt90 - reflecAt0) * ret;\n}"},2093:e=>{e.exports="   \n                                  \n   \nfloat smoothMaxPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return max(a, b) + 0.25 * k * h * h;\n}\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMaxPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n    return add(multiplyScalar(1. - 0.5 * h, gradMax), multiplyScalar(0.5 * h, gradMin));\n}\n"},5442:e=>{e.exports="float smoothMinPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return min(a, b) - 0.25 * k * h * h;\n}\n\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMinPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n\n    return add(multiplyScalar(1. - 0.5 * h, gradMin), multiplyScalar(0.5 * h, gradMax));\n}\n"},2143:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct BasicPTMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(BasicPTMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n                                                         \n                                  \n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\nvec3 render(BasicPTMaterial material, ExtVector v, RayType rayType) {\n    if (rayType.reflect){\n        return material.specular;\n    }\n                               \n                                              \n                                         \n       \n    return material.diffuse;\n}\n\n"},2197:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct CheckerboardMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\nvec4 render(CheckerboardMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    if (x1 < 1. && x2 < 1.){\n        return vec4(material.color1, 1);\n    } else if (x1 >= 1. && x2 >= 1.) {\n        return vec4(material.color1, 1);\n    } else {\n        return vec4(material.color2, 1);\n    }\n}\n\n"},7793:e=>{e.exports="\n                                                                                                                        \n                       \n                                                                                                                        \n"},4743:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct EquidistantHypStripsMaterial {\n    float distance;\n    float width;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(EquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float distP = atanh(uv.x);\n    float k = round(distP / material.distance);\n    vec2 q = horizontalTranslate(uv, -k * material.distance);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1917:e=>{e.exports="                                                                                                                        \n                                                  \n                                                                                                                        \n\nstruct EquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n\nvec4 render(EquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n    float theta = uv.x;\n    float phi = uv.y;\n    theta = theta - round(theta / material.distance) * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n                                                                                            \n    if (cosDistSq > material.cosHalfWidthSq) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},3801:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct GraphPaperMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\n\nfloat gridLines(vec2 uv, float size){\n    float brightness = 1./(2.*sqrt(size));\n    float gridPattern = abs(sin(3.14*size*uv.x)*sin(1.*3.14*size*uv.y));\n                                   \n    gridPattern = 1.-clamp(pow(gridPattern,0.05),0.,1.);\n    return gridPattern*brightness;\n}\n\nfloat grid(vec2 uv){\n    float grid1 = gridLines(uv,1.);\n    float grid2 = gridLines(uv,5.);\n    float grid3 = gridLines(uv,10.);\n    float grid4 = gridLines(uv,50.);\n    float gridTotal = grid1+grid2+grid3+grid4;\n    gridTotal *=5.;\n   return gridTotal;\n}\n\nvec4 render(GraphPaperMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    float gridPattern = grid(vec2(x1,x2));\n\n    vec3 col1 = material.color1*(1.-gridPattern);\n    vec3 col2 = material.color2*gridPattern;\n    return vec4(col1+col2,1.);\n\n}\n\n"},2278:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightLocalWrapMaterial {\n    GroupElement cellBoost;\n    bool isHighlightOn;\n};\n"},3048:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightWrapMaterial {\n    bool isHighlightOn;\n};\n"},7685:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct HypStripsMaterial {\n    float totalWidth;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n};\n\nvec4 render(HypStripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float aux = clamp(uv.x, -1., 1.);\n    float dist = atanh(aux);\n    float x = mod(dist / material.totalWidth, 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}"},4566:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantHypStripsMaterial {\n    float distance;\n    float halfWidth;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(ImprovedEquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float t = atanh(uv.x) - material.distance;\n    vec2 m = horizontalTranslate(uv, -t);\n    float distM = abs(distToYAxis(m));\n    float n = floor(log(distM / material.distance) / log(2.));\n\n    float distP = atanh(uv.x);\n    float period = pow(2., -n) * material.distance;\n    float k = round(distP / period);\n    vec2 q = horizontalTranslate(uv, -k * period);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1650:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    float fadingAmplitude;\n    vec3 stripColor;\n    vec3 bgColor;\n    mat4 rotation;\n};\n\nvec4 render(ImprovedEquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n                         \n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n\n\n                                                                                              \n    float ln2 = 0.6931471;                               \n\n    float theta = rotatedUV.x;\n    float phi = rotatedUV.y;\n    float k = round(theta / material.distance);\n    theta = theta - k * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n\n                                                                                            \n    if (cosDistSq < material.cosHalfWidthSq) {\n                                                               \n        return vec4(material.bgColor, 1);\n    }\n    if (k == 0.) {\n        return vec4(material.stripColor, 1);\n    }\n\n                                                                        \n                                                                             \n    int kInt = int(k);\n    int nInt = kInt & (~kInt + 1);\n    float n = float(nInt);\n                                \n                                                                                        \n    float theta0 = material.distance;\n    float theta1 = n * theta0;\n\n                                                    \n                                   \n                                                  \n           \n\n    float c = 0.66;\n    float sinPh1 = sin(c * theta0) / sin(theta1);\n    float phi1 = asin(clamp(sinPh1, 0., 1.));\n\n    float coeff = ((0.5 * PI - phi1) - abs(0.5 * PI - phi)) / material.fadingAmplitude + 0.5;\n    coeff = clamp(coeff, 0., 1.);\n    vec3 base = coeff * material.stripColor + (1. - coeff) * material.bgColor;\n    return vec4(base, 1);\n\n                         \n                                                                                       \n                                                                           \n                                       \n                                                        \n      \n                                                        \n}"},3496:e=>{e.exports="                                                                                                                        \n                  \n                                            \n                                                     \n                                                                                                                        \n\nvec4 normalMaterialRender(ExtVector v, RelVector normal) {\n    Vector[3] f;\n    Point pos = applyGroupElement(v.vector.cellBoost, v.vector.local.pos);\n    frame(pos, f);\n\n    f[0] = applyGroupElement(v.vector.invCellBoost, f[0]);\n    f[1] = applyGroupElement(v.vector.invCellBoost, f[1]);\n    f[2] = applyGroupElement(v.vector.invCellBoost, f[2]);\n    \n                  \n                            \n    float r =  geomDot(normal.local, f[0]);\n    float g =  geomDot(normal.local, f[1]);\n    float b =  geomDot(normal.local, f[2]);\n    return abs(vec4(r, g, b, 1));\n}"},7198:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct PathTracerWrapMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(PathTracerWrapMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\n"},6045:e=>{e.exports="                                                                                                                        \n                 \n                                                                                                                        \n\nstruct PhongMaterial {\n    vec3 color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, PhongMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * material.color;\n    vec3 ambient = ambientCoeff * ambientLight * material.color;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},5836:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct PhongWrapMaterial {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, vec3 baseColor, PhongWrapMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * baseColor;\n    vec3 ambient = ambientCoeff * ambientLight * baseColor;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},1220:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct RotatedSphericalTextureMaterial {\n    sampler2D sampler;\n    mat4 rotation;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(RotatedSphericalTextureMaterial material, ExtVector v, vec2 uv) {\n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n    vec2 texCoords = (rotatedUV - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},9095:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SimpleTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(SimpleTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},2664:e=>{e.exports="                                                                                                                        \n                        \n                                                                                                                        \n\nstruct SingleColorMaterial {\n    vec3 color;\n};\n\nvec4 render(SingleColorMaterial material, ExtVector v) {\n    return vec4(material.color, 1);\n}"},3081:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SquaresMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(SquaresMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x1 = mod(dot(uv, material.dir1) / dot(material.dir1, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2) / dot(material.dir2, material.dir2), 2.);\n    float c1 = abs(x1 - 1.);\n    float c2 = abs(x2 - 1.);\n    if (c1 < material.lengths.x && c2 < material.lengths.x){\n        color = material.color0;\n    } else if (c1 < material.lengths.y && c2 < material.lengths.y){\n        color = material.color1;\n    } else if (c1 < material.lengths.z && c2 < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n    return vec4(color, 1);\n}\n\n"},9835:e=>{e.exports="                                                                                                                        \n          \n                  \n                                                                                                                        \nstruct StripsMaterial {\n    vec2 dir;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(StripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x = mod(dot(uv, material.dir) / dot(material.dir, material.dir), 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}\n\n"},1888:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionLocalWrapMaterial {\n    GroupElement cellBoost;\n    float ratio;\n};\n"},5698:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionWrapMaterial {\n    float ratio;\n};\n"},2229:e=>{e.exports="\n\n                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoAlphaTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoAlphaTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    vec2 texCoordsUV = vec2(texCoords.x, 0.5 + 0.5 * texCoords.y);\n    vec2 texCoordsAlpha = vec2(texCoords.x, 0.5 * texCoords.y);\n    vec4 color =  texture(material.sampler, texCoordsUV);\n    float alpha = texture(material.sampler, texCoordsAlpha).x;\n    return vec4(color.rgb, alpha);\n}"},4680:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoFrameTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoFrameTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},533:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},6947:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = exposure * color.rgb;\n    pixelColor = ACESFilm(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},2690:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 postProcess(vec3 pixelColor){\n\n                      \n    pixelColor *= exposure;\n\n                   \n    pixelColor = ACESFilm(pixelColor);\n    pixelColor = LinearToSRGB(pixelColor);\n\n    return pixelColor;\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 aux = postProcess(color.rgb);\n    gl_FragColor = vec4(min(vec3(1.0), aux), color.a);\n}"},4024:e=>{e.exports="uniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = color.rgb;\n    pixelColor = LinearToSRGB(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},5348:e=>{e.exports="vec3 applyFog(vec3 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * fog.color;\n}\n\nvec4 applyFog(vec4 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * vec4(fog.color, 1);\n}"},7885:e=>{e.exports="                                                                                                                        \n  \n          \n                                 \n  \n                                                                                                                        \n\nstruct ExpFog {\n    vec3 color;                             \n    float scattering;                                                    \n};\n"},7333:e=>{e.exports="struct IntersectionShape {\n    float maxCoeff;\n};"},519:e=>{e.exports="struct UnionShape {\n    float minCoeff;\n};\n"},4750:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec3 dir = vec3(coords.xy, -1. / tan(0.5 * camera.fovRadians));\n    Vector v = createVector(ORIGIN, dir);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},8710:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fovRadians;                                          \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},6224:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},6684:e=>{e.exports="   \n                                                                                                 \n                                                                                        \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}\n\n   \n                                                                                             \n                                                               \n   \nRelVector mappingFromFlatScreen(vec2 coords) {\n                                                         \n    vec2 jitter = vec2(randomFloat(), randomFloat()) - 0.5;\n\n                                                                            \n    vec2 planeCoords = (coords - 0.5 * resolution + jitter) / (0.5 * resolution.y);\n\n                              \n    float z = - 1. / tan(radians(0.5 * camera.fov));\n\n                                                      \n    vec4 dir = vec4(planeCoords, z, 0);\n\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},6354:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n    float focalLength;                    \n    float aperture;                \n};"},9222:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}\n\n                     \n\n  \n                               \n                               \n                         \n                                             \n                                                      \n                              \n \n  "},5970:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},5682:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},4770:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}"},8415:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},190:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n\nVector geomMix(Vector v1, Vector v2, float a){\n    return add(multiplyScalar(1.-a, v1), multiplyScalar(a, v2));\n}\n\n   \n                                           \n                         \n             \n   \nVector negate(Vector v) {\n    return multiplyScalar(-1., v);\n}\n\n\n   \n                                         \n                       \n   \nfloat geomLength(Vector v){\n    return sqrt(geomDot(v, v));\n}\n\n   \n                                                          \n                            \n   \nVector geomNormalize(Vector v){\n    float a = geomLength(v);\n    return multiplyScalar(1./a, v);\n}\n\n   \n                                                     \n   \nfloat cosAngle(Vector v1, Vector v2){\n    float a1 = geomLength(v1);\n    float a2 = geomLength(v2);\n    return geomDot(v1, v2)/ (a1 * a2);\n}\n\n   \n                                                           \n                                   \n                                                                                                        \n                                     \n                                                                   \n                                                                       \n   \nVector geomReflect(Vector v, Vector n){\n    return sub(v, multiplyScalar(2. * geomDot(v, n), n));\n}\n\n\n   \n                                         \n                                                                        \n                                                                                   \n                                              \n   \nVector geomRefract(Vector v, Vector n, float r){\n    float cosTheta1 = -geomDot(n, v);\n    float sinTheta2Sq = r * r * (1. - cosTheta1 * cosTheta1);\n\n    if (sinTheta2Sq > 1.){\n               \n        return zeroVector(v.pos);\n    }\n                                                                 \n    float cosTheta2 = sqrt(1. - sinTheta2Sq);\n    float aux = r * cosTheta1 - cosTheta2;\n    return add(multiplyScalar(r, v), multiplyScalar(aux, n));\n}\n\n   \n                                                                          \n                                           \n   \nIsometry makeTranslation(Vector v) {\n    return makeTranslation(v.pos);\n}\n\n   \n                                                                          \n                                              \n   \nIsometry makeInvTranslation(Vector v) {\n    return makeInvTranslation(v.pos);\n}\n"},4168:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                                                                         \n               \n   \nVector createVector(Point p, vec3 coords, Vector[3] frame){\n    Vector c0 = multiplyScalar(coords[0], frame[0]);\n    Vector c1 = multiplyScalar(coords[1], frame[1]);\n    Vector c2 = multiplyScalar(coords[2], frame[2]);\n    return add(c0, add(c1, c2));\n}\n\n\n\n   \n                                                                                          \n               \n   \nVector createVector(Point p, vec3 coords){\n    Vector[3] f;\n    frame(p, f);\n    return createVector(p, coords, f);\n}\n\n   \n                                                                                          \n               \n   \nVector createVectorOrtho(Point p, vec3 coords){\n    Vector[3] f;\n    orthoFrame(p, f);\n    return createVector(p, coords, f);\n}\n\n\n                                                                                                                        \n  \n                   \n                                                             \n                                                                       \n  \n                                                                                                                        \n\nstruct Position {\n    Isometry boost;\n    mat4 facing;\n};\n\n\n   \n                                        \n                          \n                                           \n   \nVector applyPosition(Position p, Vector v){\n    Vector res = applyFacing(p.facing, v);\n    return applyIsometry(p.boost, res);\n}"},2311:e=>{e.exports="   \n              \n                                \n   \nPoint applyIsometry(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\nPoint applyGroupElement(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\n   \n              \n                                \n   \nVector applyIsometry(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\nVector applyGroupElement(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\n\n"},5315:e=>{e.exports="   \n                          \n   \nvarying vec3 screenPosition;\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    RelVector vector = mapping(screenPosition);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = postProcess(getColor(v));\n}"},6159:e=>{e.exports="vec4 postProcess(vec4 color) {\n    return color;\n}"},2977:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n        }\n    }\n\n                               \n                     \n       \n\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + dist;\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    v = flow(v, camera.safetyDist);\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = raymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return v.data.pixel;\n}"},9461:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec4 pixel;                                                                   \n    vec4 leftToComputeColor;                                                                      \n};"},1767:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                             \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n              \n   \nconst float PI = 3.1415926538;\n\n   \n                      \n   \nvec4 debugColor = vec4(0.5, 0, 0.8, 1);\n\n   \n                                    \n         \n   \nconst int HIT_NOTHING = 0;\n   \n                                    \n         \n   \nconst int HIT_SOLID = 1;\n   \n                                  \n         \n   \nconst int HIT_DEBUG = -1;\n"},7962:e=>{e.exports="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"},8187:e=>{e.exports="   \n                          \n   \nvarying vec3 spherePosition;\n\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    initSeed(gl_FragCoord.xy, frameSeed);\n    RelVector vector = mappingFromFlatScreen(gl_FragCoord.xy);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = getColor(v);\n}\n"},9638:e=>{e.exports="   \n                                                \n  \n   \nuint seed;\n\n   \n                                                \n                                                                  \n                                                \n                                                                                                         \n   \nvoid initSeed(vec2 coords, uint frameSeed){\n    uvec2 aux = uvec2(coords);\n    seed =  aux.x * uint(1973) + aux.y * uint(925277) + frameSeed * uint(26699) | uint(1);\n}\n\n   \n                           \n               \n                                                                                                     \n   \nuint wangHash() {\n    seed = (seed ^ uint(61)) ^ (seed >> uint(16));\n    seed = seed * uint(9);\n    seed = seed ^ (seed >> 4);\n    seed = seed * uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n   \n                                                  \n   \nfloat randomFloat() {\n    return float(wangHash()) / 4294967296.;\n}\n\n   \n                                                                           \n                                                                                                    \n                                                                                                       \n                                          \n   \nvec3 randomUnitVec3() {\n    float z = randomFloat() * 2. - 1.;\n    float theta = randomFloat() * 2. * PI;\n    float r = sqrt(1. - z * z);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x, y, z);\n}\n\n   \n                                                   \n                                                      \n   \nVector randomVector(Point p) {\n    vec3 dir = randomUnitVec3();\n    return createVectorOrtho(p, dir);\n}\n\n   \n                                                                     \n                                                                                               \n   \nvec2 randomNormal2D(){\n    float u = randomFloat();\n    float v = randomFloat();\n\n    float r = sqrt(abs(2. * log(u)));\n    float x = r * cos(2. * PI * v);\n    float y = r * sin(2. * PI * v);\n\n    return vec2(x, y);\n\n}\n\n   \n                                                      \n   \nfloat randomNormal(float mean, float stdev){\n\n                           \n    float x = randomNormal2D().x;\n\n                                   \n    return stdev * x + mean;\n}\n"},7920:e=>{e.exports="   \n                                                                                      \n  \n   \n\n\n   \n                                                                                   \n                                                                          \n                                                       \n   \nRelVector randomVector(RelVector v) {\n    v.local = randomVector(v.local.pos);\n    return v;\n}"},3499:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n                                                                  \n                                                                                         \n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + abs(dist);\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nbool doesItScatter(inout float dist, float opticalDepth){\n                          \n    if (opticalDepth>100.){\n        return false;\n    }\n    else {\n        float probScatter=1.-exp(-dist/opticalDepth);\n        float flip=randomFloat();\n        if (flip<probScatter){\n                                           \n                                                \n            dist=dist*randomFloat();\n            return true;\n        }\n                                              \n        return false;\n    }\n}\n\n\nvoid scatterRay(inout ExtVector v){\n                                         \n    RelVector w=randomVector(v.vector);\n\n                                                 \n                                                  \n    v.vector=w;\n                                             \n                                                      \n}\n\n\n\nint scatterRaymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n    float d;\n    bool doScatter;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n\n                                          \n            d=abs(dist);\n            doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                                \n            marchingStep = marchingStep + creepingDist(localV, d, camera.threshold);\n            localV = flow(localV0, marchingStep);\n\n\n                                               \n                                                                              \n\n                                                       \n            if (doScatter){\n                scatterRay(localV);\n            }\n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n\n                                      \n        d=abs(dist);\n        doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                            \n        marchingStep = marchingStep + d;\n        globalV = flow(globalV0, marchingStep);\n\n                                                   \n        if (doScatter){\n            scatterRay(globalV);\n        }\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = scatterRaymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return vec4(v.data.pixel,1);\n}"},3888:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n           \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct RayType{\n    bool diffuse;\n    bool reflect;\n    bool refract;\n    float chance;\n};\n\n                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec3 pixel;         \n    vec3 light;         \n    vec3 currentAbsorb;                                                    \n    vec3 currentEmission;                                                             \n    float currentOpticalDepth;                                                              \n    bool isInside;                                        \n};\n\n"},8351:e=>{e.exports="vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec4 postProcess(vec4 pixelColor) {\n\n                      \n    pixelColor.xyz *= exposure;\n\n                   \n    pixelColor.xyz = ACESFilm(pixelColor.xyz);\n    pixelColor.xyz = LinearToSRGB(pixelColor.xyz);\n\n    return pixelColor;\n}"},7499:e=>{e.exports="                                                                                                                        \n  \n           \n                               \n  \n                                                                                                                        \n \n struct Solid {\n    bool isRendered;\n };\n"},7970:e=>{e.exports="                                                                                                                        \n  \n                      \n                                                        \n                                                                     \n                        \n                                                                                 \n                                                                                 \n                                                                                   \n                                                                                    \n                                                                       \n                                                                                                                        \n\nstruct RelPosition {\n    Position local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n                                                                                                                        \n  \n                    \n                                  \n                                                                       \n                      \n                                                                                 \n                                                                                 \n                                                                            \n                                                                                    \n                                                                                                                        \n\nstruct RelVector {\n    Vector local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n   \n                                                            \n   \nRelVector reduceError(RelVector v){\n    v.local = reduceError(v.local);\n    return v;\n}\n\n   \n                         \n                            \n                                                      \n   \nRelVector add(RelVector v1, RelVector v2){\n    v1.local = add(v1.local, v2.local);\n    return v1;\n}\n\n   \n                              \n                            \n                                                      \n   \nRelVector sub(RelVector v1, RelVector v2){\n    v1.local = sub(v1.local, v2.local);\n    return v1;\n}\n\n   \n                                   \n                         \n                      \n   \nRelVector multiplyScalar(float s, RelVector v){\n    v.local = multiplyScalar(s, v.local);\n    return v;\n}\n\n   \n                                                                                 \n                     \n                                                        \n   \nfloat geomDot(RelVector v1, RelVector v2) {\n    return geomDot(v1.local, v2.local);\n}\n\n   \n                              \n   \nRelVector geomNormalize(RelVector v){\n    v.local = geomNormalize(v.local);\n    return v;\n}\n\n   \n                                   \n                                                        \n   \nRelVector geomMix(RelVector v1, RelVector v2, float a) {\n    v1.local = geomMix(v1.local, v2.local, a);\n    return v1;\n}\n\n   \n                                            \n   \nRelVector negate(RelVector v){\n    v.local = negate(v.local);\n    return v;\n}\n\n   \n                                                                     \n                                                       \n   \nRelVector geomReflect(RelVector v, RelVector normal){\n    v.local = geomReflect(v.local, normal.local);\n    return v;\n}\n\n\n   \n                                                                     \n                                                       \n   \nRelVector geomRefract(RelVector v, RelVector normal, float n){\n    v.local = geomRefract(v.local, normal.local, n);\n    return v;\n}\n\n   \n                         \n                                            \n                                                                         \n   \nRelVector flow(RelVector v, float t) {\n    v.local = flow(v.local, t);\n    return v;\n}\n\n   \n                                                                                          \n                                                                           \n                                                                          \n                               \n                                                                                              \n   \nRelVector smallShift(RelVector v, vec3 dp){\n    v.local = smallShift(v.local, dp);\n    return v;\n                                                 \n                                                               \n}\n\n\n   \n                                                                                                            \n                           \n                                                   \n                                                                                             \n                                            \n   \n                                                   \n                                                   \n               \n                                                             \n                                                                 \n   \n\n   \n                                                                                                            \n                                                   \n                                                                                             \n   \nRelVector createRelVector(RelVector v, vec3 coords){\n    v.local =  createVector(v.local.pos, coords);\n    return v;\n                                                           \n                                                               \n}\n\n   \n                                                                  \n                          \n                                           \n   \nRelVector applyPosition(RelPosition position, Vector v) {\n    Vector local = applyPosition(position.local, v);\n    return RelVector(local, position.cellBoost, position.invCellBoost);\n}\n\n   \n                                                                                                                    \n   \nRelVector rewrite(RelVector v, GroupElement elt, GroupElement inv){\n    v.local = applyGroupElement(elt, v.local);\n                                     \n                                       \n    v.cellBoost = multiply(v.cellBoost, inv);\n    v.invCellBoost = multiply(elt, v.invCellBoost);\n    return v;\n}\n\n\n                                                                                                                        \n  \n                    \n                                    \n                                                                              \n                  \n                                                      \n                                                                                         \n  \n                                                                                                                        \n\nstruct ExtVector {\n    RelVector vector;\n    VectorData data;\n};\n\n\nExtVector flow(ExtVector v, float t) {\n    v.vector = flow(v.vector, t);\n    v.data.lastFlowDist = t;\n    v.data.lastBounceDist = v.data.lastBounceDist + t;\n    v.data.totalDist  = v.data.totalDist + t;\n    return v;\n}\n\n\n\n"},1398:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                              \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n  \n                   \n                                            \n  \n                                                                                                                        \nstruct Isometry{\n    mat4 matrix;\n    bool isInNil;\n};\n\n   \n                    \n   \nconst Isometry IDENTITY = Isometry(mat4(1.), true);                          \nconst Isometry FLIP = Isometry(mat4(\n0, 1, 0, 0,\n1, 0, 0, 0,\n0, 0, -1, 0,\n0, 0, 0, 1\n), false);\n\n   \n                                                              \n                      \n   \nIsometry reduceError(Isometry isom){\n    return isom;\n}\n\n   \n                                     \n   \nIsometry multiply(Isometry isom1, Isometry isom2) {\n    return Isometry(isom1.matrix * isom2.matrix, isom1.isInNil && isom2.isInNil);\n}\n\n   \n                                            \n   \nIsometry geomInverse(Isometry isom) {\n    mat4 inv = inverse(isom.matrix);\n    return Isometry(inv, isom.isInNil);\n}\n\n                                                                                                                        \n  \n                \n                                        \n  \n                                                                                                                        \nstruct Point{\n    vec4 coords;\n};\n\n\nconst Point ORIGIN = Point(vec4(0, 0, 0, 1));                              \n\n\n   \n                                                           \n   \nPoint reduceError(Point p){\n    return p;\n}\n\n   \n                                       \n   \nPoint applyIsometry(Isometry isom, Point p) {\n    vec4 coords = isom.matrix * p.coords;\n    return Point(coords);\n}\n\n   \n                                                                     \n                                  \n   \n\nIsometry makeTranslation(Point p) {\n    vec4 c = p.coords;\n    mat4 matrix =  mat4(\n    1, 0., -0.5 * c.y, 0.,\n    0., 1, 0.5 * c.x, 0.,\n    0., 0., 1., 0,\n    c.x, c.y, c.z, 1.\n    );\n    return Isometry(matrix, true);\n}\n\n   \n                                                                     \n                                     \n   \nIsometry makeInvTranslation(Point p) {\n    vec4 c = p.coords;\n    mat4 matrix =  mat4(\n    1, 0., 0.5 * c.y, 0.,\n    0., 1, -0.5 * c.x, 0.,\n    0., 0., 1., 0,\n    -c.x, -c.y, -c.z, 1.\n    );\n    return Isometry(matrix, true);\n}\n\n                                                                                                                        \n  \n                 \n                                                              \n                                                                                                  \n                       \n                                                                      \n                                                                                                        \n  \n                                                                                                                        \nstruct Vector{\n    Point pos;                     \n    vec4 dir;                            \n};\n\n   \n                                \n   \nVector zeroVector(Point pos){\n    return Vector(pos, vec4(0));\n}\n\n   \n                                                            \n   \nVector reduceError(Vector v){\n    return v;\n}\n\n   \n                         \n                            \n   \nVector add(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir + v2.dir);\n}\n\n   \n                              \n                            \n   \nVector sub(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir - v2.dir);\n}\n\n   \n                                   \n                         \n                      \n   \nVector multiplyScalar(float s, Vector v){\n    return Vector(v.pos, s * v.dir);\n}\n\n\n   \n                                                                                 \n                     \n   \nfloat geomDot(Vector v1, Vector v2) {\n    return dot(v1.dir, v2.dir);\n}\n\n\n   \n                                        \n   \nVector applyIsometry(Isometry isom, Vector v) {\n    Point pos = applyIsometry(isom, v.pos);\n    if(isom.isInNil) {\n        return Vector(pos, v.dir);\n    } else {\n        Isometry push = makeTranslation(v.pos);\n        Isometry pull = makeInvTranslation(pos);\n        vec4 dir = pull.matrix * isom.matrix * push.matrix * v.dir;\n        return Vector(pos, v.dir);\n    }\n}\n\n\n   \n                                                                         \n                                                                                                           \n                                           \n   \nVector applyFacing(mat4 m, Vector v) {\n    return Vector(v.pos, m * v.dir);\n}\n\nvoid initFlow(Vector v){\n}\n"},6683:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                    \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                               \n                                                                       \n                                     \n                                                      \n                                                                                             \n                                     \n   \nvoid frame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec4(1, 0, 0, 0));\n    f[1] = Vector(p, vec4(0, 1, 0, 0));\n    f[2] = Vector(p, vec4(0, 0, 1, 0));\n}\n\n   \n                                           \n                                                                       \n                                     \n                                                      \n   \nvoid orthoFrame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec4(1, 0, 0, 0));\n    f[1] = Vector(p, vec4(0, 1, 0, 0));\n    f[2] = Vector(p, vec4(0, 0, 1, 0));\n}\n\n   \n                                                                                         \n                              \n                                                                                              \n   \nPoint smallShift(Point p, vec3 dp){\n    Point aux = Point(vec4(dp, 1));\n    Isometry isom = makeTranslation(p);\n    return applyIsometry(isom, aux);\n}\n\nVector smallShift(Vector v, vec3 dp){\n    Point pos = smallShift(v.pos, dp);\n    return Vector(pos, v.dir);\n}\n\n\n   \n                                  \n                                                 \n                                                  \n                                                         \n                                                                                    \n                                                                 \n                                                                       \n   \nVector flow(Vector v, float t){\n                                   \n                                             \n    float tolerance = 0.1;\n    float c = v.dir.z;\n    float a = sqrt(1. - c * c);\n\n    vec4 coords;\n    float ct = c * t;\n                                                           \n    mat2 rotationAlpha = mat2(\n    v.dir.x, v.dir.y,\n    -v.dir.y, v.dir.x\n    );\n\n    if (abs(ct) < tolerance){\n                                                               \n                                                         \n                                       \n        float a2t2 = a * a * t * t;\n        coords = vec4(t, 0, 0, 1);\n        coords = coords + vec4(0, t / 2., a2t2 / 12. + 1., 0) * ct;\n        float ct2 = ct * ct;\n        coords = coords + (1. / 2.) * vec4(- t / 3., 0, 0, 0) * ct2;\n                               \n                                                                                 \n                               \n                                                                     \n                               \n                                                                               \n    } else {\n        coords = vec4(\n        (2. / c) * sin(0.5 * c * t) * cos(0.5 * c * t),\n        (2. / c) * sin(0.5 * c * t) * sin(0.5 * c * t),\n        c * t + 0.5 * (a / c) * (a / c) * (c * t - sin(c * t)),\n        1\n        );\n    }\n\n    coords = vec4(rotationAlpha * coords.xy, coords.zw);\n    Point targetFromOrigin = Point(coords);\n    Isometry shift = makeTranslation(v.pos);\n    Point target = applyIsometry(shift, targetFromOrigin);\n\n                                     \n    float cosCt = cos(c * t);\n    float sinCt = sin(c * t);\n    mat2 rotationCt = mat2(\n    cosCt, sinCt,\n    -sinCt, cosCt\n    );\n    vec4 dir = vec4(rotationCt * v.dir.xy, v.dir.zw);\n\n    return Vector(target, dir);\n}"},1238:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct GroupElement {\n    ivec3 icoords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(ivec3(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    ivec3 c1 = elt1.icoords;\n    ivec3 c2 = elt2.icoords;\n    return GroupElement(ivec3(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z + c1.x * c2.y));\n}\n\nIsometry toIsometry(GroupElement elt) {\n    vec3 c = vec3(elt.icoords);\n    Point point = Point(vec4(c.x, c.y, c.z -0.5 * c.x * c.y, 1));\n    return makeTranslation(point);\n}"},39:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct GroupElement {\n    ivec3 icoords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(ivec3(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    ivec3 c1 = elt1.icoords;\n    ivec3 c2 = elt2.icoords;\n    return GroupElement(ivec3(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z + group.root * c1.x * c2.y));\n}\n\n                                              \n                            \n                                                                            \n   \n\nIsometry toIsometry(GroupElement elt) {\n    vec3 c = vec3(elt.icoords);\n    vec4 aux = c.x * group.translationA + c.y * group.translationB;\n    float root_det = group.translationC.z;\n    mat4 matrix =  mat4(\n    1, 0, -0.5 * aux.y, 0,\n    0, 1, 0.5 * aux.x, 0,\n    0, 0, 1, 0,\n    aux.x, aux.y, aux.z -0.5 * (float(group.root) * c.x * c.y - 2. * c.z) * root_det, 1\n    );\n    return Isometry(matrix, true);\n}"},6363:e=>{e.exports="                                                                                                                        \n          \n                                                                     \n                                                                                                                        \n\nstruct Group {\n    vec4 translationA;\n    vec4 translationB;\n    vec4 translationC;\n    vec4 testTranslationA;\n    vec4 testTranslationB;\n    vec4 testTranslationC;\n    int root;\n};"},2645:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct GroupElement {\n    ivec3 icoords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(ivec3(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    ivec3 c1 = elt1.icoords;\n    ivec3 c2 = elt2.icoords;\n    return GroupElement(ivec3(c1.x + c2.x, c1.y + c2.y, c1.z + c2.z + c1.x * c2.y));\n}\n\n                                              \n                            \n                                                               \n   \n\nIsometry toIsometry(GroupElement elt) {\n    vec3 c = vec3(elt.icoords);\n    vec4 aux = c.x * group.translationA + c.y * group.translationB;\n    float det = group.translationC.z;\n                          \n                            \n                           \n                 \n                                          \n        \n    mat4 matrix =  mat4(\n    1, 0, -0.5 * aux.y, 0,\n    0, 1, 0.5 * aux.x, 0,\n    0, 0, 1, 0,\n    aux.x, aux.y, aux.z -0.5 * (c.x * c.y - 2. * c.z) * det, 1\n    );\n    return Isometry(matrix, true);\n}"},2593:e=>{e.exports="                                                                                                                        \n          \n                                      \n                                                                                                                        \n\nstruct Group {\n    vec4 translationA;\n    vec4 translationB;\n    vec4 translationC;\n    vec4 testTranslationA;\n    vec4 testTranslationB;\n    vec4 testTranslationC;\n};"},8302:e=>{e.exports="                                                                                                                        \n                        \n  \n                                  \n                                                                                                                        \n\n                                             \nfloat exactDistance(Point p, Point q) {\n                                             \n    Isometry shift = makeInvTranslation(p);\n    Point qOrigin = applyIsometry(shift, q);\n\n                                                                                 \n                                                      \n    if (qOrigin.coords.z < 0.){\n        qOrigin = applyIsometry(FLIP, qOrigin);\n    }\n    float z = qOrigin.coords.z;\n    float rhoSq = pow(qOrigin.coords.x, 2.) + pow(qOrigin.coords.y, 2.);\n\n    if (z == 0.) {\n                                  \n        return sqrt(rhoSq);\n    }\n    else if (rhoSq == 0.){\n                                \n        if (z < 2. * PI) {\n            return z;\n        }\n        else {\n            return 2. * PI * sqrt(z / PI - 1.);\n        }\n    }\n    else {\n                                       \n        float phi = zero_height(rhoSq, z);\n        float length;\n        _lengthFromPhi(rhoSq, z, phi, length);\n        return length;\n    }\n}\n\nfloat exactDistance(Vector u, Vector v){\n                                                                             \n    return exactDistance(u.pos, v.pos);\n}"},2637:e=>{e.exports="   \n                              \n                                                                                         \n   \nfloat fakeHeightSq(Point p) {\n    float z = abs(p.coords.z);\n\n    if (z < sqrt(6.)){\n        return z * z;\n    }\n    else if (z < 4. * sqrt(3.)){\n        return 12. * (pow(0.75 * z, 2. / 3.) - 1.);\n    }\n    else {\n        return 2. * sqrt(3.) * z;\n    }\n}\n\n   \n                                                           \n               \n   \nfloat fakeDistance(Point p, Point q){\n    Isometry shift = makeInvTranslation(p);\n    Point qOrigin = applyIsometry(shift, q);\n                                                        \n    float x = qOrigin.coords.x;\n    float y = qOrigin.coords.y;\n    float rhosq = x * x + y * y;\n    float hsq = fakeHeightSq(qOrigin);\n\n    return pow(0.2 * rhosq * rhosq + 0.8 * hsq * hsq, 0.25);\n}\n\n    \n                                                                         \n    \nfloat fakeDistance(Vector u, Vector v){\n    return fakeDistance(u.pos, v.pos);\n}"},7462:e=>{e.exports="                                                                                                                        \n                           \n                               \n                                                                                    \n  \n                                               \n                                                                                                                        \n\nconst int MAX_NEWTON_INIT_ITERATION = 10;\nconst int MAX_NEWTON_ITERATION = 10;\nconst float NEWTON_INIT_TOLERANCE = 0.001;\nconst float NEWTON_TOLERANCE = 0.0001;\n\n                                                                    \n                                                            \n                                                                           \n                                     \n                                    \nfloat _height(float rhoSq, float z0, float phi) {\n    float res = -z0 + phi;\n\n    if (phi < 0.001) {\n                                                                                        \n        float phi2 = phi * phi;\n        float phi4 = phi2 * phi2;\n        res = res + rhoSq * phi * (phi2 + 30.) * (phi4 + 840.) / 302400.;\n    }\n    else {\n        res = res + 0.5 * rhoSq * (phi - sin(phi)) / pow(2. * sin(0.5 * phi), 2.0);\n    }\n    return res;\n}\n\n                                            \nfloat _dheight(float rhoSq, float z0, float phi) {\n    float res = 1.;\n\n    if (phi < 0.001) {\n                                                                                        \n        float phi2 = phi * phi;\n        float phi4 = phi2 * phi2;\n        float phi6 = phi4 * phi2;\n        res = res + rhoSq * (25200. + 2520. * phi2 + 150. * phi4 + 7. * phi6) / 302400.;\n    }\n    else {\n        float cPhi = cos(0.5 * phi);\n        float sPhi = sin(0.5 * phi);\n        res =  res - rhoSq * (phi * cPhi - 2. * sPhi) / (8. * pow(sPhi, 3.));\n    }\n    return res;\n}\n\n                                                   \nfloat _d2height(float rhoSq, float z0, float phi) {\n    float res;\n\n    if (phi < 0.001) {\n                                                                                        \n        float phi2 = phi * phi;\n        float phi4 = phi2 * phi2;\n        float phi6 = phi4 * phi2;\n        res = rhoSq * phi * (55440. + 6600. * phi2 + 462. * phi4 + 25. * phi6) / 3326400.;\n    }\n    else {\n        float cPhi = cos(0.5 * phi);\n        float sPhi = sin(0.5 * phi);\n        res =  rhoSq * (2. * phi * pow(cPhi, 2.) - 6. * cPhi * sPhi + phi) / (16. * pow(sPhi, 4.));\n    }\n    return res;\n}\n\n\n                                                                    \n                                          \n                                                                 \n                                            \n                                                                                        \n                                                                  \nfloat _height_newton_init(float rhoSq, float z0, float phimin, float phimax, bool increasing) {\n    float auxmin = phimin;\n    float auxmax = phimax;\n    float aux, val;\n    for (int i=0; i < MAX_NEWTON_INIT_ITERATION; i++){\n        aux = 0.5 * auxmin + 0.5 * auxmax;\n        val = _height(rhoSq, z0, aux);\n        if (val >= 0.) {\n            break;\n        }\n        else {\n            if (increasing) {\n                auxmin = aux;\n            }\n            else {\n                auxmax = aux;\n            }\n        }\n    }\n    return aux;\n}\n\n                                                        \n                     \nfloat _height_newton(float rhoSq, float z0, float phi0) {\n    float phi = phi0;\n    float aux;\n    float val;\n    for (int i=0; i < MAX_NEWTON_ITERATION; i++){\n                                  \n        val = _height(rhoSq, z0, phi);\n                                              \n        aux = phi;\n                           \n        phi = phi - val/_dheight(rhoSq, z0, phi);\n        if (abs(phi - aux) < NEWTON_TOLERANCE) {\n            break;\n        }\n    }\n    return phi;\n}\n\n\n                                                               \n                          \n                                                                            \n                                                                         \nfloat zero_height(float rhoSq, float z0) {\n    float phi0 = _height_newton_init(rhoSq, z0, 0., 2. * PI, true);\n    return _height_newton(rhoSq, z0, phi0);\n}\n\n                                                                                       \n                        \n                                                      \nfloat _dheight_newton_init(float rhosq, float z0, int n) {\n    float nFloat = float(n);\n    float auxmin = 2. * nFloat * PI;\n    float auxmax = 2. * (nFloat + 1.) * PI;\n    float aux, val;\n    for (int i=0; i < MAX_NEWTON_INIT_ITERATION; i++){\n        if (auxmax - auxmin < NEWTON_INIT_TOLERANCE) {\n            break;\n        }\n        aux = 0.5 * auxmin + 0.5 * auxmax;\n        val = _dheight(rhosq, z0, aux);\n        if (val >= 0.) {\n            auxmax = aux;\n        }\n        else {\n            auxmin = aux;\n        }\n    }\n    return aux;\n}\n\n                                                             \n                     \nfloat _dheight_newton(float rhosq, float z0, float phi0) {\n    float phi = phi0;\n    float aux;\n    float val;\n    for (int i=0; i < MAX_NEWTON_ITERATION; i++){\n        val = _dheight(rhosq, z0, phi);\n        aux = phi;\n        phi = phi - val/_d2height(rhosq, z0, phi);\n        if (abs(phi - aux) < NEWTON_TOLERANCE) {\n            break;\n        }\n    }\n    return phi;\n}\n\n\n                                                                             \n                                   \n                          \n                                                                            \n                                                   \n                                                                             \nbool zerobis_height(float rhoSq, float z0, int n, out float[2] phis) {\n    float nFloat = float(n);\n                                                      \n    float aux0 = _dheight_newton_init(rhoSq, z0, n);\n    float aux1 = _dheight_newton(rhoSq, z0, aux0);\n    float height_min = _height(rhoSq, z0, aux1);\n                                      \n    if (height_min > 0.) {\n        return false;\n    }\n    else {\n                                            \n        float phi0 = _height_newton_init(rhoSq, z0, 2. * nFloat * PI, aux1, false);\n        phis[0] = _height_newton(rhoSq, z0, phi0);\n        float phi1 = _height_newton_init(rhoSq, z0, aux1, 2. * (nFloat + 1.) * PI, true);\n        phis[1] = _height_newton(rhoSq, z0, phi1);\n        return true;\n    }\n}\n\n                                                                    \n                                                  \n                                     \n                                                               \n                                   \nvoid _lengthFromPhi(float rhoSq, float z, float phi, out float len) {\n    float c = 2. * sin(0.5 * phi) / sqrt(rhoSq + 4.0 * pow(sin(0.5 * phi), 2.));\n    len = phi / c;\n}\n"},8817:e=>{e.exports="                                                                                                                        \n          \n                       \n                                                                                                                        \n\nstruct FakePointLight {\n    int id;\n    Point position;\n    vec3 color;\n    float intensity;\n    int maxDirs;\n};\n\nbool directions(FakePointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    Point position = applyIsometry(v.invCellBoost, light.position);\n\n    float fakeDistance = fakeDistance(position, v.local.pos);\n    intensity = (1. / fakeDistance) * light.intensity;\n\n    Isometry pull = makeInvTranslation(v.local.pos);\n    vec4 aux = position.coords - v.local.pos.coords;\n    aux = pull.matrix * aux;\n    Vector local = Vector(v.local.pos, aux);\n    local = geomNormalize(local);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},653:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct ConstDirLight {\n    int id;\n    vec3 color;\n    float intensity;\n    vec3 direction;\n    int maxDirs;\n};\n\nbool directions(ConstDirLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    intensity = light.intensity;\n                                                             \n                                                                        \n    vec4 coords = vec4(light.direction, 0.);\n    Vector local = Vector(v.local.pos, coords);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},7041:e=>{e.exports="                                                                                                                        \n          \n                       \n                                                                                                                        \n\nstruct FakeLocalPointLight {\n    int id;\n    Point position;\n    vec3 color;\n    float intensity;\n    int maxDirs;\n};\n\nbool directions(FakeLocalPointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n                                                                     \n\n    float fakeDistance = fakeDistance(light.position, v.local.pos);\n    intensity = (1. / fakeDistance) * light.intensity;\n\n    Isometry pull = makeInvTranslation(v.local.pos);\n    vec4 aux = light.position.coords - v.local.pos.coords;\n    aux = pull.matrix * aux;\n    Vector local = Vector(v.local.pos, aux);\n    local = geomNormalize(local);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},6891:e=>{e.exports="                                                                                                                        \n                       \n                                                                                                                        \n\nstruct MultiColorMaterial {\n    vec3 mainColor;\n    vec3 accent1;\n    vec3 accent2;\n    vec3 accent3;\n    bool grid;\n};\n\nvec4 render(MultiColorMaterial material, ExtVector v) {\n\n    vec3 dir = normalize(v.vector.local.pos.coords.xyw);\n    vec3 color = material.mainColor;\n    color += material.accent1 * dir.x;\n    color += material.accent2 * dir.y;\n    color += material.accent3 * dir.z;\n\n    float rDist = length(v.vector.local.pos.coords.xy);\n    float theta = atan(dir.y,dir.x);\n    float height = v.vector.local.pos.coords.z;\n\n    if(material.grid){\n        float test = sin(70.*rDist)*sin(70.*theta)*sin(70.*height);\n        float sgn = sign(test);\n        if (sgn<0.){\n            color *=0.9;\n        }\n    }\n\n    return vec4(color, 1);\n}"},3022:e=>{e.exports="                                                                                                                        \n                         \n                                                                                                                        \n\nstruct VaryingColorMaterial {\n    vec3 mainColor;\n    vec3 weight;\n};\n\nvec4 render(VaryingColorMaterial material, ExtVector v) {\n    vec3 color =  material.mainColor + material.weight * v.vector.local.pos.coords.xyz;\n    return vec4(color, 1);\n}"},1407:e=>{e.exports="                                                                                                                        \n          \n              \n                                                                                                                        \n\nstruct BallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                                \n   \nfloat sdf(BallShape ball, RelVector v) {\n    Point center = applyIsometry(v.invCellBoost, ball.center);\n    float fakeDist = fakeDistance(v.local.pos, center);\n    if (fakeDist > 10. * ball.radius) {\n        return fakeDist - ball.radius;\n    }\n    else {\n        return exactDistance(v.local.pos, center) - ball.radius;\n    }\n}\n\nvec2 uvMap(BallShape ball, RelVector v){\n    Point center = applyIsometry(v.invCellBoost, ball.center);\n    vec4 dir = v.local.pos.coords - center.coords;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n"},1209:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct VerticalHalfSpaceShape {\n    Point pos;\n    vec3 normal;\n    vec3 uDir;\n    vec3 vDir;\n};\n\nfloat sdf(VerticalHalfSpaceShape halfSpace, RelVector v) {\n                                                              \n                                            \n    Point pos = halfSpace.pos;\n    Isometry invCellBoost = toIsometry(v.invCellBoost);\n    pos = applyGroupElement(v.invCellBoost, pos);\n    Isometry shift = makeInvTranslation(v.local.pos);\n    pos = applyIsometry(shift, pos);\n    vec2 p = pos.coords.xy;\n                                                        \n                                                                                           \n    vec4 normal = invCellBoost.matrix * vec4(halfSpace.normal, 0);\n    vec2 n = normalize(normal.xy);\n\n\n    float dotp = dot(p, n);\n    if (abs(dotp) < 2. * camera.threshold){\n                                                                                \n        return - dotp;\n    }\n    \n    float c = v.local.dir.z;\n    vec2 u = v.local.dir.xy;\n    float a = length(u);\n\n                                              \n                                         \n    mat2 flip = mat2(0, 1, 1, 0);\n    if (c < 0.){\n        c = -c;\n        u = flip * u;\n        n = flip * n;\n        p = flip * p;\n    }\n    \n                                                                                   \n    float sign = 1.;\n    if (dotp < 0.) {\n        dotp = - dotp;\n        n = -n;\n        sign = -1.;\n    }\n    if (abs(c) <= 0.){\n                              \n                               \n        float dotv = dot(u, n);\n        if (dotv <= 0.){\n                                                           \n            return - sign * camera.maxDist;\n        }\n        return - sign * dotp / dotv;\n    }\n\n    float aCosPhi = n.y * u.x - n.x * u.y;\n    if (aCosPhi + a  < c * dotp) {\n                                               \n                               \n        return - sign * camera.maxDist;\n    }\n\n                   \n    float aSinPhi = dot(u, n);\n    float phi = atan(aSinPhi, aCosPhi);\n    float psi = acos(max((aCosPhi - c * dotp) / a, -1.));\n                           \n    return - sign * (psi - phi) / c;\n\n\n}\n\nRelVector gradient(VerticalHalfSpaceShape halfSpace, RelVector v) {\n    Vector local = Vector(v.local.pos, vec4(halfSpace.normal, 0));\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(VerticalHalfSpaceShape halfSpace, RelVector v) {\n    Isometry invCellBoost = toIsometry(v.invCellBoost);\n    Point pos = applyGroupElement(v.invCellBoost, halfSpace.pos);\n    vec4 uDir = invCellBoost.matrix * vec4(halfSpace.uDir, 0);\n    vec4 vDir = invCellBoost.matrix * vec4(halfSpace.vDir, 0);\n    float uCoord = dot(v.local.pos.coords - pos.coords, uDir);\n    float vCoord = dot(v.local.pos.coords - pos.coords, vDir);\n    return vec2(uCoord, vCoord);\n}"},129:e=>{e.exports="                                                                                                                        \n          \n                   \n                                                                                                                        \n\nstruct FakeBallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                                \n   \nfloat sdf(FakeBallShape ball, RelVector v) {\n    Point center = applyIsometry(v.invCellBoost, ball.center);\n    return fakeDistance(v.local.pos, center) - ball.radius;\n}\n\nvec2 uvMap(FakeBallShape ball, RelVector v){\n    Point center = applyIsometry(v.invCellBoost, ball.center);\n    vec4 dir = v.local.pos.coords - center.coords;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n"},5627:e=>{e.exports="                                                                                                                        \n          \n             \n                                                                                                                        \n\nstruct LocalBallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                                \n   \nfloat sdf(LocalBallShape ball, RelVector v) {\n    float fakeDist = fakeDistance(v.local.pos, ball.center);\n    if (fakeDist > 10. * ball.radius) {\n        return fakeDist - ball.radius;\n    }\n    else {\n        return exactDistance(v.local.pos, ball.center) - ball.radius;\n    }\n}\n\nvec2 uvMap(LocalBallShape ball, RelVector v){\n    vec4 dir = v.local.pos.coords - ball.center.coords;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n\n\n"},9039:e=>{e.exports="                                                                                                                        \n          \n                  \n                                                                                                                        \n\nstruct LocalFakeBallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\nfloat sdf(LocalFakeBallShape ball, RelVector v) {\n    return fakeDistance(v.local.pos, ball.center) - ball.radius;\n}\n\nvec2 uvMap(LocalFakeBallShape ball, RelVector v){\n    vec4 dir = v.local.pos.coords - ball.center.coords;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n\n\n"},8206:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct LocalPotatoShape {\n    int id;\n    Point center;\n    float radius;\n    float coeff1;\n    float coeff2;\n    float exp;\n};\n\nfloat sdf(LocalPotatoShape potato, RelVector v) {\n    Isometry pull = makeInvTranslation(potato.center);\n    Point p = applyIsometry(pull, v.local.pos);\n    float x = p.coords.x;\n    float y = p.coords.y;\n    float rhosq = x * x + y * y;\n    float hsq = fakeHeightSq(p);\n    float aux = potato.coeff1 * pow(rhosq, 0.5 * potato.exp) + potato.coeff2 * pow(hsq, 0.5 * potato.exp);\n    return pow(aux, 1. / potato.exp) - potato.radius;\n}\n\nvec2 uvMap(LocalPotatoShape potato, RelVector v){\n    vec4 dir = v.local.pos.coords - potato.center.coords;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n"},3323:e=>{e.exports="                                                                                                                        \n          \n                                                  \n                                                                                                                        \n\nstruct LocalVerticalCylinderShape {\n    float radius;\n    Point pos;\n};\n\nfloat sdf(LocalVerticalCylinderShape cyl, RelVector v) {\n    vec2 diff = v.local.pos.coords.xy - cyl.pos.coords.xy;\n    return length(diff) - cyl.radius;\n}\n\nRelVector gradient(LocalVerticalCylinderShape cyl, RelVector v) {\n    vec2 diff = v.local.pos.coords.xy - cyl.pos.coords.xy;\n    vec4 dir = vec4(diff, 0, 0);\n    Vector local = Vector(v.local.pos, dir);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n\n}\n\nvec2 uvMap(LocalVerticalCylinderShape cyl, RelVector v) {\n    vec2 dir = v.local.pos.coords.xy - cyl.pos.coords.xy;\n    float height = v.local.pos.coords.z;\n    return vec2(atan(dir.y,dir.x),height);\n}"},7189:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct PotatoShape {\n    int id;\n    Point center;\n    float radius;\n    float coeff1;\n    float coeff2;\n    float exp;\n};\n\n   \n                                                \n   \nfloat sdf(PotatoShape potato, RelVector v) {\n    Point center = applyGroupElement(v.invCellBoost, potato.center);\n    Isometry pull = makeInvTranslation(center);\n    Point p = applyIsometry(pull, v.local.pos);\n    float x = p.coords.x;\n    float y = p.coords.y;\n    float rhosq = x * x + y * y;\n    float hsq = fakeHeightSq(p);\n    float aux = potato.coeff1 * pow(rhosq, 0.5 * potato.exp) + potato.coeff2 * pow(hsq, 0.5 * potato.exp);\n    return pow(aux, 1. / potato.exp) - potato.radius;\n}\n\n"},6116:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct StraightGeoShape {\n    Point pos;\n    vec4 normal;\n    vec4 trans;\n    float radius;\n};\n\n   \n                                                \n   \nfloat sdf(StraightGeoShape geo, RelVector v) {\n    Isometry isom = toIsometry(v.invCellBoost);\n    Point m = applyIsometry(isom, geo.pos);\n    vec4 n = isom.matrix * geo.normal;\n    mat4 aux = transpose(inverse(isom.matrix));\n    vec4 t = aux * geo.trans;\n\n    vec2 projV = v.local.pos.coords.xy;\n    vec2 projM = m.coords.xy;\n    float dist = abs(dot(projV - projM, n.xy)) - geo.radius;\n\n    if (dist > 2. * camera.threshold){\n        return dist;\n    }\n    else {\n        return abs(dot(t, v.local.pos.coords)) - geo.radius;\n    }\n}\n\n"},2552:e=>{e.exports="                                                                                                                        \n          \n                                                  \n                                                                                                                        \n\nstruct VerticalCylinderShape {\n    float radius;\n    Point pos;\n};\n\nfloat sdf(VerticalCylinderShape cyl, RelVector v) {\n    Isometry invCellBoost = toIsometry(v.invCellBoost);\n    Point pos = applyGroupElement(v.invCellBoost, cyl.pos);\n    vec2 diff = v.local.pos.coords.xy - pos.coords.xy;\n    return length(diff) - cyl.radius;\n}\n\nRelVector gradient(VerticalCylinderShape cyl, RelVector v) {\n    Isometry invCellBoost = toIsometry(v.invCellBoost);\n    Point pos = applyGroupElement(v.invCellBoost, cyl.pos);\n    vec2 diff = v.local.pos.coords.xy - pos.coords.xy;\n    vec4 dir = vec4(diff, 0, 0);\n    Vector local = Vector(v.local.pos, dir);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n\n}\n\nvec2 uvMap(VerticalCylinderShape cyl, RelVector v) {\n    Point p = applyGroupElement(v.cellBoost, v.local.pos);\n    vec2 dir = p.coords.xy - cyl.pos.coords.xy;\n    float height = p.coords.z;\n    return vec2(atan(dir.y,dir.x),height);\n}"},6969:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct VerticalHalfSpaceShape {\n    Point pos;\n    vec3 normal;\n    vec3 uDir;\n    vec3 vDir;\n};\n\nfloat sdf(VerticalHalfSpaceShape halfSpace, RelVector v) {\n    Isometry invCellBoost = toIsometry(v.invCellBoost);\n    Point pos = applyGroupElement(v.invCellBoost, halfSpace.pos);\n    vec4 diff = v.local.pos.coords - pos.coords;\n    vec4 normal = invCellBoost.matrix * vec4(halfSpace.normal, 0);\n    return dot(diff.xy, normal.xy);\n}\n\nRelVector gradient(VerticalHalfSpaceShape halfSpace, RelVector v) {\n    Vector local = Vector(v.local.pos, vec4(halfSpace.normal, 0));\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(VerticalHalfSpaceShape halfSpace, RelVector v) {\n    Isometry invCellBoost = toIsometry(v.invCellBoost);\n    Point pos = applyGroupElement(v.invCellBoost, halfSpace.pos);\n    vec4 uDir = invCellBoost.matrix * vec4(halfSpace.uDir, 0);\n    vec4 vDir = invCellBoost.matrix * vec4(halfSpace.vDir, 0);\n    float uCoord = dot(v.local.pos.coords - pos.coords, uDir);\n    float vCoord = dot(v.local.pos.coords - pos.coords, vDir);\n    return vec2(uCoord, vCoord);\n}"},5688:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                            \n  \n                                                                                                                        \n                                                                                                                        \n\n\n"}},n={};function r(e){var a=n[e];if(void 0!==a)return a.exports;var o=n[e]={exports:{}};return t[e](o,o.exports,r),o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})();var a={};(()=>{r.d(a,{T0:()=>Yo,FJ:()=>Qo,GU:()=>Mt,XH:()=>Te,ec:()=>tl,Yb:()=>Vi,ZH:()=>At,K9:()=>j,FT:()=>_t,cK:()=>vt,_x:()=>mt,kj:()=>bt,V1:()=>Ie,Vz:()=>ln,ck:()=>$,Iy:()=>ja,Vf:()=>$s,TB:()=>vn,F6:()=>ll,Kd:()=>Qi,Al:()=>qo,ix:()=>ur,jZ:()=>cr,c$:()=>jt,OZ:()=>el,Ao:()=>mi,x9:()=>ti,ET:()=>Zs,Qj:()=>We,mD:()=>Lo,yb:()=>St,iJ:()=>dn,ZA:()=>$e,Jz:()=>Ce,fR:()=>Jr,kK:()=>Gr,ZX:()=>sr,_f:()=>br,Ht:()=>gr,HZ:()=>Fo,TN:()=>lo,JV:()=>n,Sc:()=>Ao,Nh:()=>zo,RL:()=>Me,_k:()=>wt,uR:()=>jo,gU:()=>Jo,jo:()=>rl,Q:()=>Si,oR:()=>nl,lt:()=>wi,tl:()=>al,HI:()=>ki,IJ:()=>il,jD:()=>Oi,F5:()=>Tt,Uc:()=>os,Fh:()=>Oo,O5:()=>ii,oB:()=>Xt,pJ:()=>Ct,GW:()=>Xe,DZ:()=>ge,_K:()=>La,JF:()=>nn,Lv:()=>Rr,E9:()=>o,Ly:()=>i,Gx:()=>Di,iv:()=>as,mH:()=>es,xd:()=>rs,pX:()=>we,Dz:()=>Se,Th:()=>m,Uj:()=>Wo,bY:()=>_n,cV:()=>io,lR:()=>To,xs:()=>zt,bn:()=>Vt,oC:()=>Go,Z1:()=>xn,h8:()=>Pt,Qf:()=>Ji,jE:()=>Ue,k1:()=>er,vb:()=>cl,dh:()=>Yi,ew:()=>rr,$p:()=>Ho,xG:()=>ft,l_:()=>Ma,pk:()=>da,yI:()=>Co,E6:()=>Ne,zO:()=>Ae,cB:()=>ai,OW:()=>s,DV:()=>sl,bt:()=>Gi,Pq:()=>ol,j5:()=>Fi,n3:()=>Kn,Se:()=>Xn,PQ:()=>jn,$9:()=>Bo,wJ:()=>vs,ak:()=>ye,uZ:()=>_e,Cy:()=>Wa,qM:()=>Rn,Z:()=>Hs,aG:()=>Rs,mV:()=>ea,Gi:()=>Hr,iz:()=>gi(),de:()=>Os(),zC:()=>vi(),jV:()=>co,j9:()=>En,oc:()=>Dn,wS:()=>Fa,WT:()=>Dr,p2:()=>Ve,w0:()=>Pn,VL:()=>wa,UR:()=>ua,dV:()=>Wt,G0:()=>So,YL:()=>Hn,re:()=>Uo});const t=(e=>{var t={};return r.d(t,e),t})({BufferGeometry:()=>e.BufferGeometry,Clock:()=>e.Clock,Color:()=>e.Color,EventDispatcher:()=>e.EventDispatcher,Float32BufferAttribute:()=>e.Float32BufferAttribute,HalfFloatType:()=>e.HalfFloatType,ImageLoader:()=>e.ImageLoader,LinearFilter:()=>e.LinearFilter,MathUtils:()=>e.MathUtils,Matrix3:()=>e.Matrix3,Matrix4:()=>e.Matrix4,Mesh:()=>e.Mesh,NearestFilter:()=>e.NearestFilter,NoBlending:()=>e.NoBlending,OrthographicCamera:()=>e.OrthographicCamera,PerspectiveCamera:()=>e.PerspectiveCamera,PlaneGeometry:()=>e.PlaneGeometry,Quaternion:()=>e.Quaternion,RGBAFormat:()=>e.RGBAFormat,RepeatWrapping:()=>e.RepeatWrapping,Scene:()=>e.Scene,ShaderMaterial:()=>e.ShaderMaterial,SphereGeometry:()=>e.SphereGeometry,Texture:()=>e.Texture,TextureLoader:()=>e.TextureLoader,Uniform:()=>e.Uniform,UniformsUtils:()=>e.UniformsUtils,Vector2:()=>e.Vector2,Vector3:()=>e.Vector3,Vector4:()=>e.Vector4,VideoTexture:()=>e.VideoTexture,WebGLRenderTarget:()=>e.WebGLRenderTarget,WebGLRenderer:()=>e.WebGLRenderer});class n{constructor(){this.build(...arguments)}build(){throw new Error("This method need be overloaded.")}get isIsometry(){return!0}identity(){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}multiply(e){throw new Error("This method need be overloaded.")}premultiply(e){throw new Error("This method need be overloaded.")}invert(){return this.matrix.invert(),this}makeTranslation(e){throw new Error("This method need be overloaded.")}makeInvTranslation(e){throw new Error("This method need be overloaded.")}makeTranslationFromDir(e){throw new Error("This method need be overloaded.")}diffExpMap(e){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new n;return e.copy(this),e}}n.prototype.build=function(){this.matrix=new t.Matrix4,this.isInNil=!0},n.prototype.identity=function(){return this.matrix.identity(),this.isInNil=!0,this},n.prototype.reduceError=function(){return this},n.prototype.multiply=function(e){return this.matrix.multiply(e.matrix),this.isInNil=this.isInNil&&e.isInNil,this},n.prototype.premultiply=function(e){return this.matrix.premultiply(e.matrix),this.isInNil=this.isInNil&&e.isInNil,this},n.prototype.invert=function(){return this.matrix.invert(),this},n.prototype.makeTranslation=function(e){const[t,n,r]=e.coords.toArray();return this.matrix.set(1,0,0,t,0,1,0,n,-.5*n,.5*t,1,r,0,0,0,1),this.isInNil=!0,this},n.prototype.makeInvTranslation=function(e){const[t,n,r]=e.coords.toArray();return this.matrix.set(1,0,0,-t,0,1,0,-n,.5*n,-.5*t,1,-r,0,0,0,1),this.isInNil=!0,this},n.prototype.makeTranslationFromDir=function(e){console.warn("makeTranslationFromDir: not done yet");const[t,n,r]=e.toArray();return this.matrix.set(1,0,0,t,0,1,0,n,0,0,1,r,0,0,0,1),this.isInNil=!0,this},n.prototype.equals=function(e){return this.matrix.equals(e.matrix)},n.prototype.copy=function(e){return this.matrix.copy(e.matrix),this.isInNil=e.isInNil,this};class o{constructor(...e){this.build(...e)}build(){throw new Error("This method need be overloaded.")}get isPoint(){return!0}set(){throw new Error("This method need be overloaded.")}applyIsometry(e){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new o;return e.copy(this),e}}o.prototype.build=function(){this.coords=0===arguments.length?new t.Vector4(0,0,0,1):new t.Vector4(...arguments)},o.prototype.set=function(){this.coords.set(arguments[0],arguments[1],arguments[2],1)},o.prototype.applyIsometry=function(e){return this.coords.applyMatrix4(e.matrix),this},o.prototype.equals=function(e){return this.coords.equals(e.coords)},o.prototype.reduceError=function(){return this},o.prototype.copy=function(e){return this.coords.copy(e.coords),this};class s extends t.Vector3{get isVector(){return!0}applyMatrix4(e){const n=new t.Vector4(this.x,this.y,this.z,0);return n.applyMatrix4(e),this.set(n.x,n.y,n.z),this}applyFacing(e){return this.applyQuaternion(e.quaternion),this}}class i{constructor(){this.boost=new n,this.quaternion=new t.Quaternion}get isPosition(){return!0}get facing(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion)}setBoost(e){return this.boost.copy(e),this}setQuaternion(e){return this.quaternion.copy(e),this}reduceErrorBoost(){return this.boost.reduceError(),this}reduceErrorQuaternion(){return this.quaternion.normalize(),this}reduceError(){return this.reduceErrorBoost(),this.reduceErrorQuaternion(),this}get point(){return(new o).applyIsometry(this.boost)}reset(){return this.boost.identity(),this.quaternion.identity(),this}applyIsometry(e){return this.boost.premultiply(e),this}applyQuaternion(e){return this.quaternion.multiply(e),this}multiply(e){return this.boost.multiply(e.boost),this.quaternion.premultiply(e.quaternion),this}premultiply(e){return this.boost.premultiply(e.boost),this.quaternion.multiply(e.quaternion),this}flowFromOrigin(e){throw new Error("This method need be overloaded.")}flow(e){const t=e.clone().applyFacing(this),n=(new i).flowFromOrigin(t);return this.multiply(n),this}fakeDiffExpMap(e){const n=(new s).setFromMatrixPosition(e),r=(new t.Quaternion).setFromRotationMatrix(e);return this.flow(n),this.quaternion.multiply(r),this}equals(e){return this.boost.equals(e.boost)&&this.quaternion.equals(e.quaternion)}copy(e){return this.boost.copy(e.boost),this.quaternion.copy(e.quaternion),this}clone(){const e=new i;return e.copy(this),e}}const l=new t.Vector3(1,0,0),c=(new t.Vector3(0,1,0),new t.Vector3(0,0,1));i.prototype.flowFromOrigin=function(e){const r=e.length();if(0===r)return this.boost.identity(),this.quaternion.identity(),this;const a=e.clone().normalize(),s=a.z,i=Math.sqrt(1-s*s),h=new o;if(0===s)h.set(e.x,e.y,e.z);else{const e=new n;e.matrix.set(a.x,-a.y,0,0,a.y,a.x,0,0,0,0,1,0,0,0,0,1),h.set(2/s*Math.sin(.5*s*r)*Math.cos(.5*s*r),2/s*Math.sin(.5*s*r)*Math.sin(.5*s*r),s*r+i/s*.5*(i/s)*(s*r-Math.sin(s*r))),h.applyIsometry(e)}this.boost.makeTranslation(h);const d=(new t.Quaternion).setFromAxisAngle(c,s*r),u=(new t.Quaternion).setFromAxisAngle(l,-.5*r),p=(new t.Quaternion).setFromUnitVectors(l,a);return this.quaternion.identity().multiply(d).multiply(p).multiply(u).multiply(p.conjugate()),this.reduceErrorQuaternion(),this};var h=r(1398),d=r.n(h),u=r(6683),p=r.n(u);class m{static shader1=void 0;static shader2=void 0;constructor(e,n,r={},a={}){this.camera=e,this.scene=n,this.threeRenderer=a.isWebGLRenderer?a:new t.WebGLRenderer(a),this.globalUniforms=void 0!==r.globalUniforms?r.globalUniforms:{},void 0===this.globalUniforms.maxBounces&&(this.globalUniforms.maxBounces={type:"int",value:0}),this.globalUniforms.windowSize={type:"vec2",value:new t.Vector2(window.innerWidth,window.innerHeight)}}get set(){return this.camera.position.set}setPixelRatio(e){this.threeRenderer.setPixelRatio(e)}setSize(e,t,n=!0){this.threeRenderer.setSize(e,t,n)}setClearColor(e,t){this.threeRenderer.setClearColor(e,t)}setAnimationLoop(e){this.threeRenderer.setAnimationLoop(e)}get domElement(){return this.threeRenderer.domElement}build(){throw new Error("Renderer: this method is not implemented")}render(){throw new Error("Renderer: this method is not implemented")}}class b{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const v=new t.OrthographicCamera(-1,1,1,-1,0,1);class f extends t.BufferGeometry{constructor(){super(),this.setAttribute("position",new t.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new t.Float32BufferAttribute([0,2,0,0,2,0],2))}}const g=new f;class x{constructor(e){this._mesh=new t.Mesh(g,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,v)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class y extends b{constructor(e,n,r=null,a=null,o=null){super(),this.scene=e,this.camera=n,this.overrideMaterial=r,this.clearColor=a,this.clearAlpha=o,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new t.Color}render(e,t,n){const r=e.autoClear;let a,o;e.autoClear=!1,null!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor)),null!==this.clearAlpha&&(a=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(a),null!==this.overrideMaterial&&(this.scene.overrideMaterial=o),e.autoClear=r}}class V extends b{constructor(e,n){super(),this.textureID=void 0!==n?n:"tDiffuse",e instanceof t.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=t.UniformsUtils.clone(e.uniforms),this.material=new t.ShaderMaterial({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new x(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}const _={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class M extends b{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const r=e.getContext(),a=e.state;let o,s;a.buffers.color.setMask(!1),a.buffers.depth.setMask(!1),a.buffers.color.setLocked(!0),a.buffers.depth.setLocked(!0),this.inverse?(o=0,s=1):(o=1,s=0),a.buffers.stencil.setTest(!0),a.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),a.buffers.stencil.setFunc(r.ALWAYS,o,4294967295),a.buffers.stencil.setClear(s),a.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),a.buffers.color.setLocked(!1),a.buffers.depth.setLocked(!1),a.buffers.color.setMask(!0),a.buffers.depth.setMask(!0),a.buffers.stencil.setLocked(!1),a.buffers.stencil.setFunc(r.EQUAL,1,4294967295),a.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),a.buffers.stencil.setLocked(!0)}}class w extends b{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class T{constructor(e,n){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===n){const r=e.getSize(new t.Vector2);this._width=r.width,this._height=r.height,(n=new t.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:t.HalfFloatType})).texture.name="EffectComposer.rt1"}else this._width=n.width,this._height=n.height;this.renderTarget1=n,this.renderTarget2=n.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new V(_),this.copyPass.material.blending=t.NoBlending,this.clock=new t.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,r=this.passes.length;t<r;t++){const r=this.passes[t];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==M&&(r instanceof M?n=!0:r instanceof w&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const n=this.renderer.getSize(new t.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=n.width,this._height=n.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class C{constructor(e=1){this.useCase=e,this.code="",this.includedImports=[],this.includedClasses=[],this.includedConstants=[],this.includedUniforms=[],this.includedInstances=[],this.uniforms={}}get fragmentShader(){return this.code}addChunk(e){return this.code=this.code+"\r\n\r\n"+e,this}addImport(e){return this.includedImports.includes(e)||(this.includedImports.push(e),this.code=this.code+"\r\n\r\n"+e),this}addClass(e,t){return this.includedClasses.includes(e)||(this.includedClasses.push(e),this.code=this.code+"\r\n\r\n"+t),this}addConstant(e,t,n){return this.includedConstants.includes(e)||(this.includedConstants.push(e),this.code=this.code+"\r\n\r\n"+`const ${t} ${e} = ${n};`),this}addUniform(e,t,n){return this.includedUniforms.includes(e)||(this.includedUniforms.push(e),this.code=this.code+"\r\n\r\n"+`uniform ${t} ${e};`,this.uniforms[e]={type:t,value:n}),this}updateUniform(e,t){return this.uniforms[e].value=t,this}addInstance(e,t){return this.includedInstances.includes(e)||(this.includedInstances.push(e),this.code=this.code+"\r\n\r\n"+t),this}}var S=r(1767),I=r.n(S),R=r(190),D=r.n(R),E=r(4168),P=r.n(E),k=r(2977),B=r.n(k),U=r(2044),N=r.n(U),L=r(9461),F=r.n(L),A=r(7781),z=r.n(A),G=r(6159),H=r.n(G),q=r(5315),O=r.n(q);class j extends m{constructor(e,t,n={},r={}){super(e,t,n,r),this._fragmentBuilder=new C,this.postProcess=void 0!==n.postProcess?n.postProcess:[],this.composer=new T(this.threeRenderer)}get isBasicRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.composer.setSize(e,t)}buildFragmentShader(){this._fragmentBuilder.addChunk(I()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)})),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(D()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(P()),this._fragmentBuilder.addChunk(F()),this.set.shader(this._fragmentBuilder),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(N()(this)),this._fragmentBuilder.addChunk(z()(this)),this._fragmentBuilder.addChunk(B()),this._fragmentBuilder.addChunk(H()),this._fragmentBuilder.addChunk(O())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder);const e=new y(this.camera.threeScene,this.camera.threeCamera);e.clear=!1,this.composer.addPass(e);for(let e=0;e<this.postProcess.length;e++){const t=new V(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}render(){this.composer.render()}}class W extends b{constructor(e,n){super();const r=_;this.map=e,this.opacity=void 0!==n?n:1,this.uniforms=t.UniformsUtils.clone(r.uniforms),this.material=new t.ShaderMaterial({uniforms:this.uniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,depthTest:!1,depthWrite:!1,premultipliedAlpha:!0}),this.needsSwap=!1,this.fsQuad=new x(null)}render(e,t,n){const r=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.uniforms.opacity.value=this.opacity,this.uniforms.tDiffuse.value=this.map,this.material.transparent=this.opacity<1,e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(),this.fsQuad.render(e),e.autoClear=r}dispose(){this.material.dispose(),this.fsQuad.dispose()}}var Q=r(7962),K=r.n(Q);class Z{constructor(){}uniforms(){return{tDiffuse:{value:null}}}vertexShader(){return K()}fragmentShader(){throw new Error("Shape: this method should be implemented")}fullShader(){return{uniforms:this.uniforms(),vertexShader:this.vertexShader(),fragmentShader:this.fragmentShader()}}}var Y=r(2690),X=r.n(Y);class $ extends Z{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return X()}}var J=r(6172),ee=r.n(J),te=r(3499),ne=r.n(te),re=r(9638),ae=r.n(re),oe=r(7920),se=r.n(oe),ie=r(3888),le=r.n(ie),ce=r(6272),he=r.n(ce),de=r(8187),ue=r.n(de),pe=r(4122),me=r.n(pe);const be=new t.ShaderMaterial({uniforms:{accTex:new t.Uniform(null),newTex:new t.Uniform(null),iFrame:new t.Uniform(0)},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D accTex;\n        uniform sampler2D newTex;\n        uniform float iFrame;\n        void main() {\n            float den = 1./ (1. + iFrame);\n            gl_FragColor = den * (iFrame *  texture2D(accTex, vUv) + texture2D(newTex, vUv));\n        }"}),ve=new x(be),fe={minFilter:t.NearestFilter,magFilter:t.NearestFilter,format:t.RGBAFormat,type:t.HalfFloatType};class ge extends m{constructor(e,n,r={},a={}){super(e,n,r,a),this.globalUniforms.maxBounces.value=void 0!==r.maxBounces?r.maxBounces:50,this.postProcess=void 0!==r.postProcess?r.postProcess:[],0===this.postProcess.length&&this.postProcess.push(new $),this._fragmentBuilder=new C(3),this.sceneTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,fe),this.accReadTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,fe),this.accWriteTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,fe),this.iFrame=0,this.composer=new T(this.threeRenderer)}get isPathTracerRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.sceneTarget.setSize(e,t),this.accReadTarget.setSize(e,t),this.accWriteTarget.setSize(e,t),this.composer.setSize(e,t)}updateFrameSeed(){const e=Math.floor(1e4*Math.random());this._fragmentBuilder.updateUniform("frameSeed",e)}buildFragmentShader(){this._fragmentBuilder.addChunk(I()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)}));const e=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.addUniform("resolution","vec2",e),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(D()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(P()),this._fragmentBuilder.addUniform("frameSeed","uint",Math.floor(1e4*Math.random())),this._fragmentBuilder.addChunk(ae()),this._fragmentBuilder.addChunk(le()),this.set.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(se()),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(ee()(this)),this._fragmentBuilder.addChunk(me()(this)),this._fragmentBuilder.addChunk(he()(this)),this._fragmentBuilder.addChunk(ne()),this._fragmentBuilder.addChunk(ue())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder),this.composer.addPass(new W(this.accReadTarget.texture));for(let e=0;e<this.postProcess.length;e++){const t=new V(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}renderAccTarget(){this.threeRenderer.setRenderTarget(null),this.composer.render()}render(){let e;this.updateFrameSeed();const n=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.updateUniform("resolution",n),this.threeRenderer.setRenderTarget(this.sceneTarget),this.threeRenderer.render(this.threeScene,this.camera.threeCamera),this.threeRenderer.setRenderTarget(this.accWriteTarget),be.uniforms.accTex.value=this.accReadTarget.texture,be.uniforms.newTex.value=this.sceneTarget.texture,be.uniforms.iFrame.value=this.iFrame,ve.render(this.threeRenderer),e=this.accReadTarget,this.accReadTarget=this.accWriteTarget,this.accWriteTarget=e,this.renderAccTarget(),this.iFrame=this.iFrame+1}}class xe{static createButton(e){const t=document.createElement("button");function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",r(t),navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){let n=null;async function r(r){r.addEventListener("end",a),await e.xr.setSession(r),t.textContent="EXIT VR",n=r}function a(){n.removeEventListener("end",a),t.textContent="ENTER VR",n=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){if(null===n){const e={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};navigator.xr.requestSession("immersive-vr",e).then(r)}else n.end()}}():(n(),t.textContent="VR NOT SUPPORTED"),r&&xe.xrSessionIsGranted&&t.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{xe.xrSessionIsGranted=!0}))}}}function ye(e,t){return function(){return t.apply(e,arguments)}}function Ve(e){return e.replace(/\W/g,"_")}function _e(e,t,n){return Math.max(t,Math.min(n,e))}xe.xrSessionIsGranted=!1,xe.registerSessionGrantedListener(),t.Vector3.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}]`},t.Vector4.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Matrix3.prototype.toLog=function(){let e="\r\n";for(let t=0;t<3;t++){for(let n=0;n<3;n++)0!==n&&(e+=",\t"),e+=this.elements[t+3*n];e+="\r\n"}return e},t.Matrix3.prototype.power=function(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}},t.Matrix3.prototype.makeRotation=function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this},t.Matrix4.prototype.toLog=function(){let e="\r\n";for(let t=0;t<4;t++){for(let n=0;n<4;n++)0!==n&&(e+=",\t"),e+=this.elements[t+4*n];e+="\r\n"}return e},t.Matrix4.prototype.add=function(e){return this.set.apply(this,[].map.call(this.elements,(function(t,n){return t+e.elements[n]}))),this},t.Quaternion.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Quaternion.prototype.multiplyScalar=function(e){return this.set(e*this.x,e*this.y,e*this.z,e*this.w),this},t.Quaternion.prototype.add=function(e){return this.set(this.x+e.x,this.y+e.y,this.z+e.z,this.w+e.w),this};const Me=0,we=1,Te=2;class Ce{constructor(e){this.group=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.name=`groupElement_${this.uuid}`}identity(){throw new Error("GroupElement: This method need be overloaded.")}multiply(e){throw new Error("GroupElement: This method need be overloaded.")}premultiply(e){throw new Error("GroupElement: This method need be overloaded.")}invert(){throw new Error("GroupElement: This method need be overloaded.")}toIsometry(){throw new Error("GroupElement: This method need be overloaded.")}equals(e){throw new Error("GroupElement: This method need be overloaded.")}clone(){throw new Error("GroupElement: This method need be overloaded.")}copy(e){throw new Error("GroupElement: This method need be overloaded.")}}class Se{constructor(e){this.local=new i,this.set=e,this.cellBoost=this.set.group.element(),this.invCellBoost=this.set.group.element()}reduceErrorBoost(){return this.local.reduceErrorBoost(),this}reduceErrorFacing(){return this.local.reduceErrorFacing(),this}reduceErrorLocal(){return this.local.reduceError(),this}reduceError(){return this.reduceErrorLocal(),this}get facing(){return this.local.facing}get localPoint(){return this.local.point}get point(){return this.local.point.applyIsometry(this.cellBoost.toIsometry())}get globalBoost(){return this.cellBoost.toIsometry().multiply(this.local.boost)}get globalPosition(){const e=new i;return e.boost.copy(this.globalBoost),e.quaternion.copy(this.local.quaternion),e}reset(){this.local.reset(),this.cellBoost.identity(),this.invCellBoost.identity()}applyQuaternion(e){return this.local.applyQuaternion(e),this}teleport(){let e,t;for(;;){t=this.localPoint,e=!0;for(const n of this.set.teleportations)if(e=e&&!n.jsTest(t),!e){this.local.applyIsometry(n.elt.toIsometry()),this.cellBoost.multiply(n.inv),this.invCellBoost.premultiply(n.elt);break}if(e)break}return this}flow(e){return this.local.flow(e),this.teleport(),this}fakeDiffExpMap(e){return this.local.fakeDiffExpMap(e),this}equals(e){let t=!0;return t=t&&this.local.equals(e.local),t=t&&this.cellBoost.equals(e.cellBoost),t}copy(e){return this.cellBoost.copy(e.cellBoost),this.invCellBoost.copy(e.invCellBoost),this.local.copy(e.local),this}clone(){const e=new Se(this.set);return e.copy(this),e}}r(8415),r(4770);class Ie{constructor(e){this.threeCamera=void 0,this.threeScene=new t.Scene,this.minDist=void 0!==e.minDist?e.minDist:0,this.maxDist=void 0!==e.maxDist?e.maxDist:50,this.safetyDist=void 0!==e.safetyDist?e.safetyDist:0,this.maxSteps=void 0!==e.maxSteps?e.maxSteps:100,this.threshold=void 0!==e.threshold?e.threshold:1e-4,this.position=new Se(e.set),this.fakeCameras=[],this.setThreeCamera(e)}setThreeCamera(e){throw new Error("This method need be implemented.")}setThreeScene(){throw new Error("This method need be implemented.")}get matrix(){return this.threeCamera.matrixWorld}updateProjectionMatrix(){this.threeCamera.updateProjectionMatrix()}static glslClass(){throw new Error("Generic: this function should be implemented")}static glslMapping(){throw new Error("Generic: this function should be implemented")}shader(e,t=void 0){e.addClass("Camera",this.constructor.glslClass()),void 0===t?e.addUniform("camera","Camera",this):e.addUniform("camera","Camera",this.fakeCameras[t]),e.addChunk(this.constructor.glslMapping())}}var Re=r(5682),De=r.n(Re),Ee=r(5970),Pe=r.n(Ee),ke=r(9222),Be=r.n(ke);class Ue extends Ie{constructor(e){super(e)}setThreeCamera(e){this.threeCamera=new t.PerspectiveCamera(void 0!==e.fov?e.fov:70,window.innerWidth/window.innerHeight,.01,2e3),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}set aspect(e){this.threeCamera.aspect=e}get fov(){return this.threeCamera.fov}set fov(e){this.threeCamera.fov=e}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.SphereGeometry(1e3,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:De(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return Pe()}static glslMapping(){return Be()}}class Ne extends Ue{constructor(e){super(e),this.isStereoOn=!1,this.ipDist=void 0!==e.ipDist?e.ipDist:.03200000151991844;for(const e in[Me,we])this.fakeCameras[e]={fov:this.fov,minDist:this.minDist,maxDist:this.maxDist,maxSteps:this.maxSteps,safetyDist:this.safetyDist,threshold:this.threshold,position:this.position.clone(),matrix:this.matrix}}get isStereoOff(){return!this.isStereoOn}switchStereo(){this.isStereoOn=!this.isStereoOn}setThreeScene(e){const n=new t.SphereGeometry(50,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e[Me].uniforms,vertexShader:De(),fragmentShader:e[Me].fragmentShader}),a=new t.ShaderMaterial({uniforms:e[we].uniforms,vertexShader:De(),fragmentShader:e[Me].fragmentShader}),o=new t.Mesh(n,r),s=new t.Mesh(n,a);o.layers.set(1),s.layers.set(2),this.threeScene.add(o,s)}updateFakeCamerasPosition(){if(this.fakeCameras[Me].position.copy(this.position),this.fakeCameras[we].position.copy(this.position),this.isStereoOn){const e=new s(1,0,0).multiplyScalar(2*this.ipDist).applyMatrix4(this.matrix).negate();this.fakeCameras[Me].position.flow(e)}}get chaseThreeCamera(){if(void 0===this._chaseThreeCamera){const e=new s;this._chaseThreeCamera=function(){const t=(new s).setFromMatrixPosition(this.matrix),n=(new s).subVectors(t,e);this.position.flow(n),this.updateFakeCamerasPosition(),e.copy(t)}}return this._chaseThreeCamera}}var Le=r(8351),Fe=r.n(Le);class Ae extends m{constructor(e,t,n={},r={}){super(e,t,n,r),this.threeRenderer.xr.enabled=!0,this.threeRenderer.xr.setReferenceSpaceType("local"),this.camera.threeCamera.layers.enable(1);const a=xe.createButton(this.threeRenderer),o=ye(this.camera,this.camera.switchStereo);a.addEventListener("click",o,!1),document.body.appendChild(a),this._fragmentBuilders=[new C,new C],this.postProcess=void 0!==n.postProcess&&n.postProcess,this.exposure=void 0!==n.exposure?n.exposure:1}get isVRRenderer(){return!0}get xr(){return this.threeRenderer.xr}buildFragmentShader(){for(const e of[Me,we])this._fragmentBuilders[e].addChunk(I()),Object.keys(this.globalUniforms).forEach((t=>{const n=this.globalUniforms[t].type,r=this.globalUniforms[t].value;this._fragmentBuilders[e].addUniform(t,n,r)})),this._fragmentBuilders[e].addChunk(this.constructor.shader1),this._fragmentBuilders[e].addChunk(D()),this._fragmentBuilders[e].addChunk(this.constructor.shader2),this._fragmentBuilders[e].addChunk(P()),this._fragmentBuilders[e].addChunk(F()),this.set.shader(this._fragmentBuilders[e]),this.camera.shader(this._fragmentBuilders[e],e),this.scene.shader(this._fragmentBuilders[e]),this._fragmentBuilders[e].addChunk(N()(this)),this._fragmentBuilders[e].addChunk(z()(this)),this._fragmentBuilders[e].addChunk(B()),this.postProcess?(this._fragmentBuilders[e].addUniform("exposure","float",this.exposure),this._fragmentBuilders[e].addChunk(Fe())):this._fragmentBuilders[e].addChunk(H()),this._fragmentBuilders[e].addChunk(O())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilders)}checkShader(e=Me){console.log(this._fragmentBuilders[e].code)}render(){this.camera.chaseThreeCamera(),this.threeRenderer.render(this.camera.threeScene,this.camera.threeCamera)}}var ze=r(6224),Ge=r.n(ze),He=r(8710),qe=r.n(He),Oe=r(4750),je=r.n(Oe);class We extends Ie{constructor(e){super(e),this.fov=void 0!==e.fov?e.fov:50}setThreeCamera(){this.threeCamera=new t.OrthographicCamera(-1,1,1,-1,0,1),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.PlaneGeometry(2,2),r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:Ge(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return qe()}static glslMapping(){return je()}}var Qe=r(6354),Ke=r.n(Qe),Ze=r(6684),Ye=r.n(Ze);class Xe extends Ue{constructor(e){super(e),this.focalLength=void 0!==e.focalLength?e.focalLength:1,this.aperture=void 0!==e.aperture?e.aperture:0}static glslClass(){return Ke()}static glslMapping(){return Ye()}}class $e{constructor(){}element(){throw new Error("Group: this method should be implemented")}shader(e){throw new Error("Group: this method should be implemented")}}class Je extends Ce{constructor(e){super(e),this.fake=!0}identity(){return this}multiply(e){return this}premultiply(e){return this}invert(){return this}toIsometry(){return new n}equals(e){return!0}clone(){return new Je}copy(e){return this}}var et=r(9188),tt=r.n(et);class nt extends $e{constructor(){super()}element(){return new Je(this)}shader(e){e.addChunk(tt())}}var rt=r(3148),at=r.n(rt);const ot=/bool\s*(\w+)\(Point.*\)/m,st=/float\s*(\w+)\(ExtVector.*\)/m;class it{constructor(e,n,r,a,o=void 0,s=void 0){let i;if(this.set=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.jsTest=n,this.glslTest=r,this.glslTestName=void 0,i=r.match(ot),!i)throw new Error("Teleportation: unable to find the name of the GLSL test");if(this.glslTestName=i[1],this.elt=a,this.inv=void 0!==o?o:a.clone().invert(),this.glslCreepCustom=void 0,this.glslCreep=void 0,this.glslCreepName=void 0,void 0!==s){if(this.glslCreepCustom=!0,this.glslCreep=s,i=s.match(st),!i)throw new Error("Teleportation: unable to find the name of the GLSL creep");this.glslCreepName=i[1]}else this.glslCreepCustom=!1,this.glslCreepName=`creep${this.uuid}`,this.glslCreep=at()(this)}get name(){return void 0===this._name&&(this._name=`teleportation_${this.uuid}`),this._name}get usesCreepingCustom(){return this.set.usesCreeping&&this.glslCreepCustom}get usesCreepingBinary(){return this.set.creepingType===vt&&!this.glslCreepCustom}shader(e){e.addChunk(this.glslTest),this.set.usesCreeping&&e.addChunk(this.glslCreep),e.addUniform(this.elt.name,"GroupElement",this.elt),e.addUniform(this.elt.name,"GroupElement",this.inv)}}var lt=r(2311),ct=r.n(lt),ht=r(7970),dt=r.n(ht),ut=r(5103),pt=r.n(ut);const mt=0,bt=1,vt=2;class ft{constructor(e=[],t=!1,n=mt){this.teleportations=[],this.neighbors=e,this.usesNearestNeighbors=t,this.creepingType=n}get usesCreeping(){return this.creepingType===bt||this.creepingType===vt}add(e,t,n,r=void 0,a=void 0){return this.teleportations.push(new it(this,e,t,n,r,a)),this}get group(){return 0!==this.teleportations.length?this.teleportations[0].elt.group:new nt}shader(e){this.group.shader(e),e.addChunk(ct()),e.addChunk(dt());for(const t of this.teleportations)t.shader(e);for(const t of this.neighbors)e.addUniform(t.elt.name,"GroupElement",t.elt),e.addUniform(t.inv.name,"GroupElement",t.inv);e.addChunk(pt()(this))}}class gt{constructor(){this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.id=void 0,this.imports=[]}get className(){return this.constructor.name}get name(){return void 0===this._name&&(this._name=`${Ve(this.className)}_${this.uuid}`),this._name}get uniformType(){return""}setId(e){this.id=e.nextId,e.nextId=e.nextId+1}onAdd(e){}addImport(e){for(const e of arguments)this.imports.push(e)}static glslClass(){throw new Error("Generic: this function should be implemented")}glslInstance(){throw new Error("Generic: this function should be implemented")}shader(e){for(const t of this.imports)e.addImport(t);e.addClass(this.constructor.name,this.constructor.glslClass()),""!==this.uniformType&&e.addUniform(this.name,this.uniformType,this),e.addInstance(this.name,this.glslInstance())}}var xt=r(8266),yt=r.n(xt);class Vt extends gt{constructor(e=void 0){super(),this.isom=void 0!==e?e:new n,this.isomInv=this.isom.clone().invert(),this.parent=void 0,this._absoluteIsom=void 0,this._absoluteIsomInv=void 0}updateAbsoluteIsom(){void 0===this._absoluteIsom&&(this._absoluteIsom=new n,this._absoluteIsomInv=new n),this.isomInv=this.isom.clone().invert(),this._absoluteIsom.copy(this.isom),this._absoluteIsomInv.copy(this.isomInv),void 0!==this.parent&&(this._absoluteIsom.premultiply(this.parent.absoluteIsom),this._absoluteIsomInv.multiply(this.parent.absoluteIsomInv))}updateData(){this.updateAbsoluteIsom()}get absoluteIsom(){return void 0===this._absoluteIsom&&this.updateAbsoluteIsom(),this._absoluteIsom}get absoluteIsomInv(){return void 0===this._absoluteIsomInv&&this.updateAbsoluteIsom(),this._absoluteIsomInv}get isShape(){return!0}get isBasicShape(){throw new Error("Shape: this method should be implemented")}get isAdvancedShape(){return!this.isBasicShape}get isGlobal(){throw new Error("Shape: this method should be implemented")}get isLocal(){return!this.isGlobal}get hasUVMap(){return!1}glslSDF(){throw new Error("Shape: this method should be implemented")}glslGradient(){return yt()(this)}glslUVMap(){throw new Error("Shape: this method should be implemented")}glslInstance(){let e=this.glslSDF()+"\r\n"+this.glslGradient();return this.hasUVMap&&(e=e+"\r\n"+this.glslUVMap()),e}}class _t extends Vt{constructor(e=void 0){super(e)}get isBasicShape(){return!0}}class Mt extends Vt{constructor(e=void 0){super(e)}get isBasicShape(){return!1}}class wt extends gt{constructor(e){super(),this.maxDirs=e}get isLight(){return!0}get isGlobal(){throw new Error("Generic: this method should be implemented")}get isLocal(){return!this.isGlobal}glslDirections(){throw new Error("Light: this method should be implemented")}glslInstance(){return this.glslDirections()}}class Tt extends gt{constructor(){super(),this.lights=void 0,this.reflectivity=void 0}get isMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}get isTransparent(){return!1}onAdd(e){this.usesLight&&(this.hasOwnProperty("lights")&&void 0!==this.lights||(this.lights=e.lights))}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class Ct extends gt{constructor(){super()}get isPTMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}onAdd(e){}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class St{constructor(){}shader(e){throw new Error("Fog: this method need be implemented")}}var It=r(2664),Rt=r.n(It),Dt=r(8778),Et=r.n(Dt);class Pt extends Tt{constructor(e){super(),this.color=e}get uniformType(){return"SingleColorMaterial"}get usesNormal(){return!1}static glslClass(){return Rt()}glslRender(){return Et()(this)}}var kt=r(2143),Bt=r.n(kt),Ut=r(9606),Nt=r.n(Ut),Lt=r(5363),Ft=r.n(Lt);class At extends Ct{constructor(e){super(),this.emission=void 0!==e.emission?e.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==e.volumeEmission?e.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==e.opticalDepth?e.opticalDepth:1e3,this.diffuse=void 0!==e.diffuse?e.diffuse:new t.Color(1,1,1),this.specular=void 0!==e.specular?e.specular:new t.Color(1,1,1),this.absorb=void 0!==e.absorb?e.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==e.ior?e.ior:1,this.roughness=void 0!==e.roughness?e.roughness:.2,this.reflectionChance=void 0!==e.reflectionChance?e.reflectionChance:.1,this.refractionChance=void 0!==e.refractionChance?e.refractionChance:0,this.diffuseChance=void 0!==e.diffuseChance?e.diffuseChance:.9;const n=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/n,this.refractionChance=this.refractionChance/n,this.diffuseChance=this.diffuseChance/n,this.addImport(Ft())}get uniformType(){return"BasicPTMaterial"}static glslClass(){return Bt()}glslRender(){return Nt()(this)}}class zt{constructor(e={}){this.lights=[],this.solids=[],this.nextId=0,this.fog=e.fog,this.background=void 0!==e.background?e.background:new Pt(new t.Color(0,0,0)),this.ptBackground=void 0!==e.ptBackground?e.ptBackground:new At({diffuse:new t.Color(0,0,0),specular:new t.Color(0,0,0),absorb:new t.Color(.25,.25,.25)})}_add(e){return e.setId(this),e.onAdd(this),e.isLight&&this.lights.push(e),e.isSolid&&this.solids.push(e),this}add(e){for(const e of arguments)this._add(e);return this}shader(e){3===e.useCase?this.ptBackground.shader(e):this.background.shader(e);for(const t of this.lights)3!==e.useCase&&t.shader(e);for(const t of this.solids)t.shader(e);void 0!==this.fog&&this.fog.shader(e)}}var Gt=r(7885),Ht=r.n(Gt),qt=r(5348),Ot=r.n(qt);class jt extends St{constructor(e,t){super(),this.color=e,this.scattering=t}shader(e){e.addClass("ExpFog",Ht()),e.addUniform("fog","ExpFog",this),e.addChunk(Ot())}}const Wt=new ft;var Qt=r(3496),Kt=r.n(Qt),Zt=r(6077),Yt=r.n(Zt);class Xt extends Tt{constructor(){super()}get uniformType(){return""}static glslClass(){return Kt()}glslRender(){return Yt()(this)}}var $t=r(6045),Jt=r.n($t),en=r(8149),tn=r.n(en);class nn extends Tt{constructor(e={}){super(),this.color=void 0!==e.color?e.color:new t.Color(1,1,1),this.ambient=void 0!==e.ambient?e.ambient:.5,this.diffuse=void 0!==e.diffuse?e.diffuse:.4,this.specular=void 0!==e.specular?e.specular:.1;const n=this.ambient+this.diffuse+this.specular;this.ambient=this.ambient/n,this.diffuse=this.diffuse/n,this.specular=this.specular/n,this.shininess=void 0!==e.shininess?e.shininess:10,this._isReflecting=void 0!==e.isReflecting&&e.isReflecting,this.reflectivity=void 0!==e.reflectivity?e.reflectivity:new t.Color(0,0,0),this.lights=e.lights}get uniformType(){return"PhongMaterial"}get usesLight(){return!0}get isReflecting(){return this._isReflecting}static glslClass(){return Jt()}glslRender(){return tn()(this)}shader(e){for(const t of this.lights)t.shader(e);super.shader(e)}}var rn=r(2197),an=r.n(rn),on=r(1215),sn=r.n(on);class ln extends Tt{constructor(e,t,n,r){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"CheckerboardMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return an()}glslRender(){return sn()(this)}}var cn=r(3801),hn=r.n(cn);class dn extends Tt{constructor(e,t,n,r,a){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"GraphPaperMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return hn()}glslRender(){return sn()(this)}}var un=r(7793),pn=r.n(un),mn=r(9909),bn=r.n(mn);class vn extends Tt{constructor(){super()}get uniformType(){return""}get usesNormal(){return!1}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}static glslClass(){return pn()}glslRender(){return bn()(this)}shader(e){super.shader(e)}}var fn=r(9095),gn=r.n(fn);class xn extends Tt{constructor(e,n={}){super(),this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==n.isTransparent&&n.isTransparent}get uniformType(){return"SimpleTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return gn()}glslRender(){return sn()(this)}}var yn=r(1220),Vn=r.n(yn);class _n extends Tt{constructor(e,n=void 0,r={}){super(),this.quaternion=void 0!==n?n:new t.Quaternion,this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get uniformType(){return"RotatedSphericalTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return Vn()}glslRender(){return sn()(this)}}const Mn=r.p+"img/426f7657671a2811d4aa.png",wn=r.p+"img/953837709706027f7dc2.jpg",Tn=r.p+"img/eba62d0cff4836a949b8.png",Cn=r.p+"img/26419cb1ce4138a11aa9.jpg",Sn=r.p+"img/33960f5af615e67309e5.jpg",In=r.p+"img/4b569137334e61081651.jpg";function Rn(e){let n;switch(e){case 0:default:n=Mn;break;case 1:n=wn}return new xn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function Dn(e){let n;switch(e){case 0:default:n=Tn;break;case 1:n=Cn}return new xn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function En(){return new xn(Sn,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function Pn(e){return new xn(In,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}const kn=r.p+"img/eb3dc827520201070f7e.jpg",Bn=r.p+"img/ce3e4a6e1affece0e902.jpg",Un=r.p+"img/370531b8ba6e5bd6a61e.jpg",Nn=r.p+"img/29989970ee70af555fd4.jpg",Ln=r.p+"img/1a661a5afc65c969818f.jpg",Fn=r.p+"img/bb733e02d9f86b8b7433.jpg",An=r.p+"img/f5196bbc22091948755e.jpg",zn=r.p+"img/9e3233c13cddac942dc4.jpg",Gn=r.p+"img/2528cfc76a03ca71fb7f.jpg";function Hn(e,n,r=void 0){let a;switch(e){case"eye":switch(n){case 0:a=kn;break;case 1:a=Bn;break;case 2:a=Un;break;case 3:a=Nn;break;case 4:a=Ln;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;case"hand":switch(n){case 0:a=Fn;break;case 1:a=An;break;case 2:a=zn;break;case 3:a=Gn;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;default:throw new Error("WoodBallMaterial: this type of texture is not implemented.")}return new _n(a,r,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}var qn=r(533),On=r.n(qn);class jn extends Tt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0!==n.transparent&&n.transparent}get uniformType(){return"VideoTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return On()}glslRender(){return sn()(this)}}var Wn=r(2229),Qn=r.n(Wn);class Kn extends Tt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0===n.transparent||n.transparent}get uniformType(){return"VideoAlphaTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return Qn()}glslRender(){return sn()(this)}}var Zn=r(4680),Yn=r.n(Zn);class Xn extends Tt{static REFRESH_READY=0;static REFRESH_IN_PROGRESS=1;static REFRESH_COMPLETE=2;constructor(e,n,r={}){super(),this.files=e,this.frameNumber=e.length,this.sampler=new t.Texture,this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent,this.loop=void 0!==r.loop&&r.loop,this.callback=void 0!==r.callback?r.callback:function(){},this.fps=void 0!==r.fps&&r.fps,this.imageStatus=Xn.REFRESH_READY,this.imageLoader=new t.ImageLoader,this.imageLoader.setPath(n),this.currentFrame=0}nextFrameIndex(e){return this.loop?(e+1)%this.frameNumber:Math.min(e+1,this.frameNumber-1)}nextFrame(){if(this.imageStatus===Xn.REFRESH_READY){this.imageStatus=Xn.REFRESH_IN_PROGRESS;const e=this.files[this.currentFrame];this.currentFrame=this.nextFrameIndex(this.currentFrame);const t=this;this.imageLoader.load(e,(function(e){t.sampler.image=e,t.sampler.needsUpdate=!0,t.imageStatus=Xn.REFRESH_COMPLETE}),void 0,(function(){console.log(`Cannot load the file ${e}`)}))}}get uniformType(){return"VideoFrameTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return Yn()}glslRender(){return sn()(this)}}var $n=r(3081),Jn=r.n($n);class er extends Tt{constructor(e,n,r,a=void 0){super(),this.dir1=e,this.dir2=n;const o=void 0!==a?a:[.5,1,1,.5];let s=0;const i=[];for(let e=0;e<4;e++)void 0!==o[e]&&(s+=o[e]),i[e]=s;for(let e=0;e<4;e++)i[e]=i[e]/s;this.lengths=new t.Vector4(...i);let l=new t.Color(1,1,1);this.color0=void 0!==r[0]?r[0]:l.clone(),l=this.color0,this.color1=void 0!==r[1]?r[1]:l.clone(),l=this.color1,this.color2=void 0!==r[2]?r[2]:l.clone(),l=this.color2,this.color3=void 0!==r[3]?r[3]:l.clone()}get uniformType(){return"SquaresMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return Jn()}glslRender(){return sn()(this)}}var tr=r(9835),nr=r.n(tr);class rr extends Tt{constructor(e,n,r=void 0){super(),this.dir=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"StripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return nr()}glslRender(){return sn()(this)}}var ar=r(7685),or=r.n(ar);class sr extends Tt{constructor(e,n,r=void 0){super(),this.totalWidth=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"HypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return or()}glslRender(){return sn()(this)}}var ir=r(1917),lr=r.n(ir);class cr extends Tt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"EquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return lr()}glslRender(){return sn()(this)}}var hr=r(4743),dr=r.n(hr);class ur extends Tt{constructor(e,t,n,r){super(),this.distance=e,this.width=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"EquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return dr()}glslRender(){return sn()(this)}}var pr=r(4566),mr=r.n(pr);class br extends Tt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"ImprovedEquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return mr()}glslRender(){return sn()(this)}}var vr=r(1650),fr=r.n(vr);class gr extends Tt{constructor(e,n,r,a,o,s=void 0){super(),this.distance=e,this.halfWidth=n,this.fadingAmplitude=r,this.stripColor=a,this.bgColor=o,this.quaternion=void 0!==s?s:new t.Quaternion}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"ImprovedEquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return fr()}glslRender(){return sn()(this)}}var xr=r(5836),yr=r.n(xr),Vr=r(3838),_r=r.n(Vr),Mr=r(472),wr=r.n(Mr),Tr=r(8204),Cr=r.n(Tr),Sr=r(7660),Ir=r.n(Sr);class Rr extends Tt{constructor(e,n={}){super(),this.material=e,this.ambient=void 0!==n.ambient?n.ambient:.5,this.diffuse=void 0!==n.diffuse?n.diffuse:.5,this.specular=void 0!==n.specular?n.specular:.5,this.shininess=void 0!==n.shininess?n.shininess:10,this._isReflecting=void 0!==n.isReflecting&&n.isReflecting,this.reflectivity=void 0!==n.reflectivity?n.reflectivity:new t.Vector3(0,0,0),this.lights=n.lights}get uniformType(){return"PhongWrapMaterial"}static glslClass(){return yr()}get usesNormal(){return!0}get usesUVMap(){return this.material.usesUVMap}get usesLight(){return!0}get isReflecting(){return this._isReflecting}glslRender(){return this.material.usesNormal?this.material.usesUVMap?Ir()(this):wr()(this):this.material.usesUVMap?Cr()(this):_r()(this)}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e);for(const t of this.lights)t.shader(e);super.shader(e)}}function Dr(e,t={}){return new Rr(e,t)}var Er=r(3048),Pr=r.n(Er),kr=r(8474),Br=r.n(kr),Ur=r(5506),Nr=r.n(Ur),Lr=r(3045),Fr=r.n(Lr),Ar=r(7397),zr=r.n(Ar);class Gr extends Tt{constructor(e,t){super(),this.defaultMat=e,this.highlightMat=t,this.isHighlightOn=!1}get uniformType(){return"HighlightWrapMaterial"}static glslClass(){return Pr()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?zr()(this):Nr()(this):this.usesUVMap?Fr()(this):Br()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function Hr(e,t){return new Gr(e,t)}var qr=r(2278),Or=r.n(qr),jr=r(8906),Wr=r.n(jr),Qr=r(1998),Kr=r.n(Qr),Zr=r(4261),Yr=r.n(Zr),Xr=r(699),$r=r.n(Xr);class Jr extends Tt{constructor(e,t,n){super(),this.defaultMat=e,this.highlightMat=t,this.cellBoost=n}get uniformType(){return"HighlightLocalWrapMaterial"}static glslClass(){return Or()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?$r()(this):Kr()(this):this.usesUVMap?Yr()(this):Wr()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function ea(e,t,n){return new Jr(e,t,n)}var ta=r(5698),na=r.n(ta),ra=r(8402),aa=r.n(ra),oa=r(6158),sa=r.n(oa),ia=r(2332),la=r.n(ia),ca=r(4146),ha=r.n(ca);class da extends Tt{constructor(e,n,r=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==r?r:5,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=_e(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionWrapMaterial"}static glslClass(){return na()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?ha()(this):sa()(this):this.usesUVMap?la()(this):aa()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function ua(e,t,n){return new da(e,t,n)}var pa=r(1888),ma=r.n(pa),ba=r(5377),va=r.n(ba),fa=r(9441),ga=r.n(fa),xa=r(6766),ya=r.n(xa),Va=r(9245),_a=r.n(Va);class Ma extends Tt{constructor(e,n,r,a=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==a?a:5,this.cellBoost=r,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=_e(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionLocalWrapMaterial"}static glslClass(){return ma()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?_a()(this):ga()(this):this.usesUVMap?ya()(this):va()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function wa(e,t,n,r){return new Ma(e,t,n,r)}var Ta=r(7198),Ca=r.n(Ta),Sa=r(1202),Ia=r.n(Sa),Ra=r(2330),Da=r.n(Ra),Ea=r(588),Pa=r.n(Ea),ka=r(9040),Ba=r.n(ka),Ua=r(1365),Na=r.n(Ua);class La extends Ct{constructor(e,n){super(),this.material=e,this.emission=void 0!==n.emission?n.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==n.volumeEmission?n.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==n.opticalDepth?n.opticalDepth:0,this.specular=void 0!==n.specular?n.specular:new t.Color(1,1,1),this.absorb=void 0!==n.absorb?n.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==n.ior?n.ior:1,this.roughness=void 0!==n.roughness?n.roughness:.2,this.reflectionChance=void 0!==n.reflectionChance?n.reflectionChance:.1,this.refractionChance=void 0!==n.refractionChance?n.refractionChance:0,this.diffuseChance=void 0!==n.diffuseChance?n.diffuseChance:.9;const r=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/r,this.refractionChance=this.refractionChance/r,this.diffuseChance=this.diffuseChance/r,this.addImport(Ft())}get uniformType(){return"PathTracerWrapMaterial"}static glslClass(){return Ca()}get usesUVMap(){return this.material.usesUVMap}glslRender(){let e="";return e+=Ia()(this),this.material.usesNormal?this.material.usesUVMap?e+=Pa()(this):e+=Ba()(this):this.material.usesUVMap?e+=Na()(this):e+=Da()(this),e}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e),super.shader(e)}}function Fa(e,t={}){return new La(e,t)}var Aa=r(7939),za=r.n(Aa),Ga=r(6142),Ha=r.n(Ga),qa=r(7260),Oa=r.n(qa);class ja extends Mt{constructor(e){super(),this.shape=e,this.shape.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData()}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return za()(this)}glslGradient(){return Ha()(this)}glslUVMap(){return Oa()(this)}setId(e){this.shape.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),super.onAdd(e)}shader(e){this.shape.shader(e),super.shader(e)}}function Wa(e){return new ja(e)}var Qa=r(2093),Ka=r.n(Qa),Za=r(2076),Ya=r.n(Za),Xa=r(3335),$a=r.n(Xa),Ja=r(6428),eo=r.n(Ja),to=r(6861),no=r.n(to),ro=r(2905),ao=r.n(ro),oo=r(7333),so=r.n(oo);const io=1;class lo extends Mt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("IntersectionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.maxType=void 0!==n.maxType?n.maxType:0,this.maxCoeff=0,this.maxType===io)this.addImport(Ka()),this.maxCoeff=void 0!==n.maxCoeff?n.maxCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"IntersectionShape"}static glslClass(){return so()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.maxType===io?eo()(this):Ya()(this)}glslGradient(){return this.maxType===io?no()(this):$a()(this)}glslUVMap(){return ao()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function co(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new lo(e,arguments[r],t));return e}var ho=r(5442),uo=r.n(ho),po=r(3908),mo=r.n(po),bo=r(7762),vo=r.n(bo),fo=r(7500),go=r.n(fo),xo=r(3238),yo=r.n(xo),Vo=r(519),_o=r.n(Vo),Mo=r(8655),wo=r.n(Mo);const To=1;class Co extends Mt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("UnionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.minType=void 0!==n.minType?n.minType:0,this.minCoeff=0,this.minType===To)this.addImport(uo()),this.minCoeff=void 0!==n.minCoeff?n.minCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"UnionShape"}static glslClass(){return _o()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.minType===To?yo()(this):mo()(this)}glslGradient(){return this.minType===To?wo()(this):vo()(this)}glslUVMap(){return go()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function So(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new Co(e,arguments[r],t));return e}var Io=r(3105),Ro=r.n(Io),Do=r(6242),Eo=r.n(Do),Po=r(9338),ko=r.n(Po);class Bo extends Mt{constructor(e,t){if(e.isGlobal!==t.isGlobal)throw new Error("WrapShape: the two shapes should be both local or both global");super(),this.wrap=e,this.shape=t,this.shape.parent=this,this.wrap.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom(),this.wrap.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData(),this.wrap.updateData()}get isWrapShape(){return!0}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Ro()(this)}glslGradient(){return Eo()(this)}glslUVMap(){return ko()(this)}setId(e){this.wrap.setId(e),this.shape.setId(e),super.setId(e)}onAdd(e){this.wrap.onAdd(e),this.shape.onAdd(e),super.onAdd(e)}shader(e){this.wrap.shader(e),this.shape.shader(e),super.shader(e)}}function Uo(e,t){return new Bo(e,t)}const No={KeyA:"yawLeft",KeyD:"yawRight",KeyW:"pitchUp",KeyS:"pitchDown",KeyQ:"rollLeft",KeyE:"rollRight",ArrowUp:"forward",ArrowDown:"back",ArrowLeft:"left",ArrowRight:"right",Quote:"up",Slash:"down"};class Lo extends t.EventDispatcher{constructor(e){super(),this.camera=e,this.movementSpeed=.5,this.rollSpeed=.8,this._moveState={up:0,down:0,left:0,right:0,forward:0,back:0,pitchUp:0,pitchDown:0,yawLeft:0,yawRight:0,rollLeft:0,rollRight:0},this._moveVector=new s(0,0,0),this._rotationVector=new s(0,0,0),this._onKeyDown=ye(this,this.onKeyDown),this._onKeyUp=ye(this,this.onKeyUp),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}pause(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)}restore(){window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}onKeyDown(e){if(e.code in No){const t=No[e.code];this._moveState[t]=1,this.updateMovementVector(),this.updateRotationVector()}}onKeyUp(e){if(e.code in No){const t=No[e.code];this._moveState[t]=0,this.updateMovementVector(),this.updateRotationVector()}}updateMovementVector(){this._moveVector.x=-this._moveState.left+this._moveState.right,this._moveVector.y=-this._moveState.down+this._moveState.up,this._moveVector.z=-this._moveState.forward+this._moveState.back}updateRotationVector(){this._rotationVector.x=-this._moveState.pitchDown+this._moveState.pitchUp,this._rotationVector.y=-this._moveState.yawRight+this._moveState.yawLeft,this._rotationVector.z=-this._moveState.rollRight+this._moveState.rollLeft}update(e){const n=this._moveVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix);this.camera.position.flow(n);const r=this._rotationVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix),a=new t.Quaternion(r.x,r.y,r.z,1).normalize();this.camera.position.applyQuaternion(a)}}class Fo{constructor(e="i"){this.action=void 0,this.key=e;const t=ye(this,this.onKeyDown);window.addEventListener("keydown",t,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.action&&this.action()}}class Ao{constructor(e,t,n){this.controller=e,this.camera=t,this.solid=n,this._isSelecting=!1,this._isSqueezing=!1;const r=ye(this,this.onSelectStart),a=ye(this,this.onSelectEnd),o=ye(this,this.onSqueezeStart),s=ye(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",r),this.controller.addEventListener("selectend",a),this.controller.addEventListener("squeezestart",o),this.controller.addEventListener("squeezeend",s)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}chase(e){this.solid.isRendered=this._isSelecting;const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[we].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.solid.isom.copy(i.globalBoost),this.solid.isom.matrix.multiply(i.facing),this.solid.updateData()}}class zo{constructor(e="p"){this.actionKeyDown=void 0,this.actionKeyUp=void 0,this.key=e;const t=ye(this,this.onKeyDown),n=ye(this,this.onKeyUp);window.addEventListener("keydown",t,!1),window.addEventListener("keyup",n,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.actionKeyDown&&this.actionKeyDown()}onKeyUp(e){e.key===this.key&&void 0!==this.actionKeyUp&&this.actionKeyUp()}}class Go{constructor(e,n,r,a){this.controller=e,this.camera=n,this.solids=r,this.speed=a,this._status=0,this._nextBullet=0,this._clock=new t.Clock;const o=ye(this,this.onSelectStart),s=ye(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){0===this._status&&(this._status=1)}onSelectEnd(){}shoot(e){const t=this.solids[this._nextBullet];t.bulletData={time:this._clock.getElapsedTime(),position:e},t.isRendered=!0,this._nextBullet=(this._nextBullet+1)%this.solids.length}updateBullet(e){const t=this.solids[e];if(t.hasOwnProperty("bulletData")){const e=this._clock.getElapsedTime()-t.bulletData.time,n=t.bulletData.position.clone().flow(new s(0,0,-this.speed*e));t.isom.copy(n.boost),t.updateData()}}updateAllBullets(){for(let e=0;e<this.solids.length;e++)this.updateBullet(e)}update(e){if(1===this._status){const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[we].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.shoot(i.globalPosition),this._status=0}this.updateAllBullets()}}class Ho{constructor(e="p",t=2,n=0){this.key=e,this.stateNumber=t,this.state=n,this.justChanged=!1;const r=ye(this,this.onKeyDown);window.addEventListener("keydown",r,!1)}onKeyDown(e){e.key===this.key&&(this.state=(this.state+1)%this.stateNumber,this.justChanged=!0)}}class qo extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this._isSelecting=!1,this._isSqueezing=!1;const n=ye(this,this.onSelectStart),r=ye(this,this.onSelectEnd),a=ye(this,this.onSqueezeStart),o=ye(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}get update(){if(void 0===this._update){const e=10,n=new s,r=new s;let a=[],o=0,i=!1;this._update=function(l){const c=new s;if(this.controller.getWorldDirection(c),c.normalize().multiplyScalar(1/e),r.add(c),i&&r.sub(a[o]),a[o]=c,i&&this._isSelecting){const e=r.clone().normalize(),a=n.clone().normalize(),o=(new t.Quaternion).setFromUnitVectors(e,a).normalize();this.position.applyQuaternion(o)}n.copy(r),o=(o+1)%e,0===o&&(i=!0)}}return this._update}}class Oo extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this.movementSpeed=.5,this._isSelecting=!1,this._isSqueezing=!1;const n=ye(this,this.onSelectStart),r=ye(this,this.onSelectEnd),a=ye(this,this.onSqueezeStart),o=ye(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}update(e){if(this._isSelecting){const t=new s;this.controller.getWorldDirection(t),t.normalize().multiplyScalar(-this.movementSpeed*e),this.position.flow(t)}}}class jo{constructor(e,t,n){this.controller=e,this.camera=t,this.light=n}chase(e){const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[we].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),i=this.controller.matrixWorld.clone().setPosition(a),l=this.camera.position.clone().fakeDiffExpMap(i);this.light.position=(new o).applyIsometry(l.globalBoost)}}class Wo{constructor(e,t,n=!1,r=!1,a=void 0){if(this.position=e,this.controller=t,this._reset=0,this._alignFacing=n,this._snap=r,this._camera=a,this._alignFacing&&void 0===a)throw new Error("VRControlsReset.constructor, the camera is needed when the alignFacing option is on");const o=ye(this,this.onSelectStart),s=ye(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){this._reset=1}onSelectEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0}}}class Qo{constructor(e,t,n,r=!1,a=!1,o=void 0){if(this.position=e,this.targetPosition=t,this.controller=n,this._reset=0,this._alignFacing=r,this._snap=a,this._camera=o,this._alignFacing&&void 0===o)throw new Error("AdvancedResetVRControls.constructor, the camera is needed when the alignFacing option is on");const s=ye(this,this.onSqueezeStart),i=ye(this,this.onSqueezeEnd);this.controller.addEventListener("squeezestart",s),this.controller.addEventListener("squeezeend",i)}onSqueezeStart(){this._reset=1}onSqueezeEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0,this.position.local.boost.copy(this.targetPosition.boost),this.position.local.quaternion.premultiply(this.targetPosition.quaternion)}}}var Ko=r(6947),Zo=r.n(Ko);class Yo extends Z{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return Zo()}}var Xo=r(4024),$o=r.n(Xo);class Jo extends Z{constructor(){super()}fragmentShader(){return $o()}}class es{constructor(e,t=0,n=0){this.ring=e,this.a=t,this.b=n,this.reduce()}reduce(){return this.a=Math.round(this.a),this.b=Math.round(this.b),this}negate(){return this.a=-this.a,this.b=-this.b,this}multiply(e){const t=this.a,n=this.b;return this.a=t*e.a+this.ring.d*n*e.b,this.b=t*e.b+n*e.a,this.reduce()}add(e){return this.a=this.a+e.a,this.b=this.b+e.b,this.reduce()}sub(e){return this.a=this.a-e.a,this.b=this.b-e.b,this.reduce()}sum(){this.copy(this.ring.zero);for(const e of arguments)this.add(e);return this}product(){this.copy(this.ring.one);for(const e of arguments)this.multiply(e);return this}addProduct(){const e=new es(this.ring).product(...arguments);return this.add(e),this}subProduct(){const e=new es(this.ring).product(...arguments);return this.sub(e),this}toNumber(){return this.a+this.b*Math.sqrt(this.ring.d)}equals(e){return this.a===e.a&&this.b===e.b}isZero(){return 0===this.a&&0===this.b}clone(){const e=new es(this.ring);return e.a=this.a,e.b=this.b,e}copy(e){return this.a=e.a,this.b=e.b,this}toLog(){return`${this.a} + ${this.b} _rD`}}var ts=r(5688),ns=r.n(ts);class rs{constructor(e){this.ring=e,this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()]}get isQuadRingMatrix4(){return!0}get a(){const e=this.toArray().map((e=>e.a));return(new t.Matrix4).fromArray(e)}get b(){const e=this.toArray().map((e=>e.b));return(new t.Matrix4).fromArray(e)}getEntry(e,t){return this.elements[4*t+e]}setEntry(e,t,n){return this.elements[4*t+e].copy(n),this}set(e,t,n,r,a,o,s,i,l,c,h,d,u,p,m,b){for(let e=0;e<4;e++)for(let t=0;t<4;t++)this.setEntry(e,t,arguments[4*e+t]);return this}identity(){return this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()],this}multiplyMatrices(e,t){for(let n=0;n<4;n++)for(let r=0;r<4;r++){this.setEntry(n,r,this.ring.zero);for(let a=0;a<4;a++)this.getEntry(n,r).addProduct(e.getEntry(n,a),t.getEntry(a,r))}return this}multiply(e){return this.multiplyMatrices(this.clone(),e)}premultiply(e){return this.multiplyMatrices(e,this.clone())}multiplyScalar(e){for(let t=0;t<16;t++)this.elements[t].multiply(e);return this}transpose(){const e=this.elements;let t=this.ring.element();return t.copy(e[1]),e[1].copy(e[4]),e[4].copy(t),t.copy(e[2]),e[2].copy(e[8]),e[8].copy(t),t.copy(e[6]),e[6].copy(e[9]),e[9].copy(t),t.copy(e[3]),e[3].copy(e[12]),e[12].copy(t),t.copy(e[7]),e[7].copy(e[13]),e[13].copy(t),t.copy(e[11]),e[11].copy(e[14]),e[14].copy(t),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],a=e[3],o=e[4],s=e[5],i=e[6],l=e[7],c=e[8],h=e[9],d=e[10],u=e[11],p=e[12],m=e[13],b=e[14],v=e[15];return e[0]=this.ring.element().addProduct(h,b,l).subProduct(m,d,l).addProduct(m,i,u).subProduct(s,b,u).subProduct(h,i,v).addProduct(s,d,v),e[1]=this.ring.element().addProduct(m,d,a).subProduct(h,b,a).subProduct(m,r,u).addProduct(n,b,u).addProduct(h,r,v).subProduct(n,d,v),e[2]=this.ring.element().addProduct(s,b,a).subProduct(m,i,a).addProduct(m,r,l).subProduct(n,b,l).subProduct(s,r,v).addProduct(n,i,v),e[3]=this.ring.element().addProduct(h,i,a).subProduct(s,d,a).subProduct(h,r,l).addProduct(n,d,l).addProduct(s,r,u).subProduct(n,i,u),e[4]=this.ring.element().addProduct(p,d,l).subProduct(c,b,l).subProduct(p,i,u).addProduct(o,b,u).addProduct(c,i,v).subProduct(o,d,v),e[5]=this.ring.element().addProduct(c,b,a).subProduct(p,d,a).addProduct(p,r,u).subProduct(t,b,u).subProduct(c,r,v).addProduct(t,d,v),e[6]=this.ring.element().addProduct(p,i,a).subProduct(o,b,a).subProduct(p,r,l).addProduct(t,b,l).addProduct(o,r,v).subProduct(t,i,v),e[7]=this.ring.element().addProduct(o,d,a).subProduct(c,i,a).addProduct(c,r,l).subProduct(t,d,l).subProduct(o,r,u).addProduct(t,i,u),e[8]=this.ring.element().addProduct(c,m,l).subProduct(p,h,l).addProduct(p,s,u).subProduct(o,m,u).subProduct(c,s,v).addProduct(o,h,v),e[9]=this.ring.element().addProduct(p,h,a).subProduct(c,m,a).subProduct(p,n,u).addProduct(t,m,u).addProduct(c,n,v).subProduct(t,h,v),e[10]=this.ring.element().addProduct(o,m,a).subProduct(p,s,a).addProduct(p,n,l).subProduct(t,m,l).subProduct(o,n,v).addProduct(t,s,v),e[11]=this.ring.element().addProduct(c,s,a).subProduct(o,h,a).subProduct(c,n,l).addProduct(t,h,l).addProduct(o,n,u).subProduct(t,s,u),e[12]=this.ring.element().addProduct(p,h,i).subProduct(c,m,i).subProduct(p,s,d).addProduct(o,m,d).addProduct(c,s,b).subProduct(o,h,b),e[13]=this.ring.element().addProduct(c,m,r).subProduct(p,h,r).addProduct(p,n,d).subProduct(t,m,d).subProduct(c,n,b).addProduct(t,h,b),e[14]=this.ring.element().addProduct(p,s,r).subProduct(o,m,r).subProduct(p,n,i).addProduct(t,m,i).addProduct(o,n,b).subProduct(t,s,b),e[15]=this.ring.element().addProduct(o,h,r).subProduct(c,s,r).addProduct(c,n,i).subProduct(t,h,i).subProduct(o,n,d).addProduct(t,s,d),this}equals(e){for(let t=0;t<16;t++)if(!this.elements[t].equals(e.elements[t]))return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n].copy(e[n+t]);return this}toArray(e=[],t=0){const n=this.elements;for(let r=0;r<16;r++)e[t+r]=n[r].clone();return e}toMatrix4(){const e=this.toArray().map((e=>e.toNumber()));return(new t.Matrix4).fromArray(e)}clone(){return new rs(this.ring).fromArray(this.elements)}copy(e){return this.fromArray(e.elements)}toLog(){return this.toMatrix4().toLog()}}class as{constructor(e){this.d=e}element(e=0,t=0){return new es(this,e,t)}matrix4(){return new rs(this)}get one(){return new es(this,1)}get zero(){return new es(this,0)}shader(e){e.addChunk(ns()),e.addConstant("QUAD_RING_D","int",this.d)}}class os{constructor(){this.elements=[1,0,0,1]}set(e,t,n,r){return this.elements=[e,n,t,r],this}identity(){return this.set(1,0,0,1),this}multplyMatrices(e,t){const[n,r,a,o]=e.elements,[s,i,l,c]=t.elements;return this.elements=[n*s+a*i,r*s+o*i,n*l+a*c,r*l+o*c],this}multiply(e){return this.multplyMatrices(this,e)}premultiply(e){return this.multplyMatrices(e,this)}power(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}}determinant(){const[e,t,n,r]=this.elements;return e*r-n*t}invert(){const[e,t,n,r]=this.elements,a=this.determinant();return this.elements=[r/a,-t/a,-n/a,e/a],this}clone(){const e=new os;for(let t=0;t<4;t++)e.elements[t]=this.elements[t];return e}copy(e){for(let t=0;t<4;t++)this.elements[t]=e.elements[t];return this}equals(e){for(let t=0;t<4;t++)if(this.elements[t]!==e.elements[t])return!1;return!0}}class ss extends Ce{constructor(e,n=0,r=0,a=0){super(e),this.coords=new t.Vector3(n,r,a)}get icoords(){return this.coords.toArray()}identity(){return this.coords.set(0,0,0),this}multiply(e){const[t,n,r]=this.coords.toArray(),[a,o,s]=e.coords.toArray();return this.coords.set(t+a,n+o,r+s+t*o),this}premultiply(e){const[t,n,r]=e.coords.toArray(),[a,o,s]=this.coords.toArray();return this.coords.set(t+a,n+o,r+s+t*o),this}invert(){const[e,t,n]=this.coords.toArray();return this.coords.set(-e,-t,e*t-n),this}toIsometry(){const[e,t,r]=this.coords.toArray(),a=new o(e,t,r-.5*e*t,1);return(new n).makeTranslation(a)}equals(e){return this.coords.equals(e.coords)}clone(){const e=new ss(this.group);return e.coords.copy(this.coords),e}copy(e){return this.coords.copy(e.coords),this}}var is=r(1238),ls=r.n(is);const cs=new class extends $e{constructor(){super()}element(){return new ss(this,arguments.length>0?arguments[0]:0,arguments.length>1?arguments[1]:0,arguments.length>2?arguments[2]:0)}shader(e){e.addChunk(ls())}};const hs=cs.element(-1,0,0),ds=cs.element(1,0,0),us=cs.element(0,-1,0),ps=cs.element(0,1,0),ms=cs.element(0,0,-1),bs=cs.element(0,0,1),vs=new ft([{elt:hs,inv:ds},{elt:ds,inv:hs},{elt:us,inv:ps},{elt:ps,inv:us},{elt:ms,inv:bs},{elt:bs,inv:ms}]).add((function(e){return e.coords.x>.5}),"//\nbool testXp(Point p){\n    return p.coords.x > 0.5;\n}\n",hs,ds).add((function(e){return e.coords.x<-.5}),"//\nbool testXn(Point p){\n    return p.coords.x < -0.5;\n}\n",ds,hs).add((function(e){return e.coords.y>.5}),"//\nbool testYp(Point p){\n    return p.coords.y > 0.5;\n}\n",us,ps).add((function(e){return e.coords.y<-.5}),"//\nbool testYn(Point p){\n    return p.coords.y < -0.5;\n}\n",ps,us).add((function(e){return e.coords.z>.5}),"//\nbool testZp(Point p){\n    return p.coords.z > 0.5;\n}\n",ms,bs).add((function(e){return e.coords.z<-.5}),"//\nbool testZn(Point p){\n    return p.coords.z < -0.5;\n}\n",bs,ms);class fs extends Ce{constructor(e,n=0,r=0,a=0){super(e),this.coords=new t.Vector3(n,r,a)}get icoords(){return this.coords.toArray()}identity(){return this.coords.set(0,0,0),this}multiply(e){const[t,n,r]=this.coords.toArray(),[a,o,s]=e.coords.toArray();return this.coords.set(t+a,n+o,r+s+t*o),this}premultiply(e){const[t,n,r]=e.coords.toArray(),[a,o,s]=this.coords.toArray();return this.coords.set(t+a,n+o,r+s+t*o),this}invert(){const[e,t,n]=this.coords.toArray();return this.coords.set(-e,-t,e*t-n),this}toIsometry(){const[e,r,a]=this.coords.toArray(),o=(new t.Vector4).add(this.group.translationA.clone().multiplyScalar(e)).add(this.group.translationB.clone().multiplyScalar(r)),[s,i,l,c]=o.toArray(),h=this.group.translationC.z,d=new n;return d.matrix.set(1,0,0,s,0,1,0,i,-.5*i,.5*s,1,l-.5*(e*r-2*a)*h,0,0,0,1),d}equals(e){return this.coords.equals(e.coords)}clone(){const e=new fs(this.group);return e.coords.copy(this.coords),e}copy(e){return this.coords.copy(e.coords),this}}var gs=r(2645),xs=r.n(gs),ys=r(2593),Vs=r.n(ys);const _s=new class extends $e{constructor(e=void 0,n=void 0){super(),this._translationA=void 0!==e?e:new t.Vector4(1,0,0,0),this._translationB=void 0!==n?n:new t.Vector4(0,1,0,0),this._testTranslationA=void 0,this._testTranslationB=void 0,this._testTranslationC=void 0,this.updateTranslationC(),this.updateDotMatrix()}get translationA(){return this._translationA}set translationA(e){this._translationA=void 0!==e?e:new t.Vector4(1,0,0,0),this.updateTranslationC(),this.updateDotMatrix()}get testTranslationA(){return void 0===this._testTranslationA&&(this._testTranslationA=this.translationA.clone().applyMatrix4(this.dotMatrix)),this._testTranslationA}get translationB(){return this._translationB}set translationB(e){this._translationB=void 0!==e?e:new t.Vector4(0,1,0,0),this.updateTranslationC(),this.updateDotMatrix()}get testTranslationB(){return void 0===this._testTranslationB&&(this._testTranslationB=this.translationA.clone().applyMatrix4(this.dotMatrix)),this._testTranslationB}updateTranslationC(){const[e,n,r,a]=this._translationA.toArray(),[o,s,i,l]=this._translationB.toArray();this._halfTranslationC=new t.Vector4(0,0,e*s-o*n,0)}get translationC(){return this._halfTranslationC}get testTranslationC(){return void 0===this._testTranslationC&&(this._testTranslationC=this.translationA.clone().applyMatrix4(this.dotMatrix)),this._testTranslationC}updateDotMatrix(){void 0===this._dotMatrix&&(this._dotMatrix=new t.Matrix4);const e=(new t.Matrix4).set(this.translationA.x,this.translationB.x,this.translationC.x,0,this.translationA.y,this.translationB.y,this.translationC.y,0,this.translationA.z,this.translationB.z,this.translationC.z,0,0,0,0,1).invert();this._dotMatrix.copy(e).transpose().multiply(e),this._testTranslationA=this.translationA.clone().applyMatrix4(this.dotMatrix),this._testTranslationB=this.translationB.clone().applyMatrix4(this.dotMatrix),this._testTranslationC=this.translationC.clone().applyMatrix4(this.dotMatrix)}get dotMatrix(){return this._dotMatrix}element(){return new fs(this,arguments.length>0?arguments[0]:0,arguments.length>1?arguments[1]:0,arguments.length>2?arguments[2]:0)}shader(e){e.addChunk(Vs()),e.addUniform("group","Group",this),e.addChunk(xs())}};const Ms=_s.element(-1,0,0),ws=_s.element(1,0,0),Ts=_s.element(0,-1,0),Cs=_s.element(0,1,0),Ss=_s.element(0,0,-1),Is=_s.element(0,0,1),Rs=new ft([{elt:Ms,inv:ws},{elt:ws,inv:Ms},{elt:Ts,inv:Cs},{elt:Cs,inv:Ts},{elt:Ss,inv:Is},{elt:Is,inv:Ss}]).add((function(e){return e.coords.dot(_s.testTranslationA)>.5}),"//\nbool testXp(Point p){\n    return dot(p.coords, group.testTranslationA) > 0.5;\n}\n",Ms,ws,"//\nfloat creepXp(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 - dot(coords, group.testTranslationA)) / length(group.testTranslationA);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(_s.testTranslationA)<-.5}),"//\nbool testXn(Point p){\n    return dot(p.coords, group.testTranslationA) < -0.5;\n}\n",ws,Ms,"//\nfloat creepXn(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 + dot(coords, group.testTranslationA)) / length(group.testTranslationA);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(_s.testTranslationB)>.5}),"//\nbool testYp(Point p){\n    return dot(p.coords, group.testTranslationB) > 0.5;\n}\n",Ts,Cs,"//\nfloat creepYp(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 - dot(coords, group.testTranslationB)) / length(group.testTranslationB);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(_s.testTranslationB)<-.5}),"//\nbool testYn(Point p){\n    return dot(p.coords, group.testTranslationB) < -0.5;\n}\n",Cs,Ts,"//\nfloat creepYn(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 + dot(coords, group.testTranslationB)) / length(group.testTranslationB);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(_s.testTranslationC)>.5}),"//\nbool testZp(Point p){\n    return dot(p.coords, group.testTranslationC) > 0.5;\n}\n",Ss,Is).add((function(e){return e.coords.dot(_s.testTranslationC)<-.5}),"//\nbool testZn(Point p){\n    return dot(p.coords, group.testTranslationC) < -0.5;\n}\n",Is,Ss);class Ds extends Ce{constructor(e,n=0,r=0,a=0){super(e),this.coords=new t.Vector3(n,r,a)}get icoords(){return this.coords.toArray()}identity(){return this.coords.set(0,0,0),this}multiply(e){const[t,n,r]=this.coords.toArray(),[a,o,s]=e.coords.toArray();return this.coords.set(t+a,n+o,r+s+this.group.root*t*o),this}premultiply(e){const[t,n,r]=e.coords.toArray(),[a,o,s]=this.coords.toArray();return this.coords.set(t+a,n+o,r+s+this.group.root*t*o),this}invert(){const[e,t,n]=this.coords.toArray();return this.coords.set(-e,-t,-n+this.group.root*e*t),this}toIsometry(){const[e,r,a]=this.coords.toArray(),o=(new t.Vector4).add(this.group.translationA.clone().multiplyScalar(e)).add(this.group.translationB.clone().multiplyScalar(r)),[s,i,l,c]=o.toArray(),h=this.group.translationC.z,d=new n;return d.matrix.set(1,0,0,s,0,1,0,i,-.5*i,.5*s,1,l-.5*(this.group.root*e*r-2*a)*h,0,0,0,1),d}equals(e){return this.coords.equals(e.coords)}clone(){const e=new Ds(this.group);return e.coords.copy(this.coords),e}copy(e){return this.coords.copy(e.coords),this}}var Es=r(39),Ps=r.n(Es),ks=r(6363),Bs=r.n(ks);const Us=new class extends $e{constructor(e=void 0,n=void 0,r=1){super(),this._root=r,this._translationA=void 0!==e?e:new t.Vector4(1,0,0,0),this._translationB=void 0!==n?n:new t.Vector4(0,1,0,0),this._testTranslationA=void 0,this._testTranslationB=void 0,this._testTranslationC=void 0,this.updateTranslationC(),this.updateDotMatrix()}get root(){return this._root}set root(e){this._root=e,this.updateTranslationC(),this.updateDotMatrix()}get translationA(){return this._translationA}set translationA(e){this._translationA=void 0!==e?e:new t.Vector4(1,0,0,0),this.updateTranslationC(),this.updateDotMatrix()}get testTranslationA(){return void 0===this._testTranslationA&&(this._testTranslationA=this.translationA.clone().applyMatrix4(this.dotMatrix)),this._testTranslationA}get translationB(){return this._translationB}set translationB(e){this._translationB=void 0!==e?e:new t.Vector4(0,1,0,0),this.updateTranslationC(),this.updateDotMatrix()}get testTranslationB(){return void 0===this._testTranslationB&&(this._testTranslationB=this.translationA.clone().applyMatrix4(this.dotMatrix)),this._testTranslationB}updateTranslationC(){const[e,n,r,a]=this._translationA.toArray(),[o,s,i,l]=this._translationB.toArray();this._halfTranslationC=new t.Vector4(0,0,(e*s-o*n)/this.root,0)}get translationC(){return this._halfTranslationC}get testTranslationC(){return void 0===this._testTranslationC&&(this._testTranslationC=this.translationA.clone().applyMatrix4(this.dotMatrix)),this._testTranslationC}updateDotMatrix(){void 0===this._dotMatrix&&(this._dotMatrix=new t.Matrix4);const e=(new t.Matrix4).set(this.translationA.x,this.translationB.x,this.translationC.x,0,this.translationA.y,this.translationB.y,this.translationC.y,0,this.translationA.z,this.translationB.z,this.translationC.z,0,0,0,0,1).invert();this._dotMatrix.copy(e).transpose().multiply(e),this._testTranslationA=this.translationA.clone().applyMatrix4(this.dotMatrix),this._testTranslationB=this.translationB.clone().applyMatrix4(this.dotMatrix),this._testTranslationC=this.translationC.clone().applyMatrix4(this.dotMatrix)}get dotMatrix(){return this._dotMatrix}element(){return new Ds(this,arguments.length>0?arguments[0]:0,arguments.length>1?arguments[1]:0,arguments.length>2?arguments[2]:0)}shader(e){e.addChunk(Bs()),e.addUniform("group","Group",this),e.addChunk(Ps())}};const Ns=Us.element(-1,0,0),Ls=Us.element(1,0,0),Fs=Us.element(0,-1,0),As=Us.element(0,1,0),zs=Us.element(0,0,-1),Gs=Us.element(0,0,1),Hs=(new ft).add((function(e){return e.coords.dot(Us.testTranslationA)>.5}),"//\nbool testXp(Point p){\n    return dot(p.coords, group.testTranslationA) > 0.5;\n}\n",Ns,Ls,"//\nfloat creepXp(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 - dot(coords, group.testTranslationA)) / length(group.testTranslationA);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(Us.testTranslationA)<-.5}),"//\nbool testXn(Point p){\n    return dot(p.coords, group.testTranslationA) < -0.5;\n}\n",Ls,Ns,"//\nfloat creepXn(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 + dot(coords, group.testTranslationA)) / length(group.testTranslationA);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(Us.testTranslationB)>.5}),"//\nbool testYp(Point p){\n    return dot(p.coords, group.testTranslationB) > 0.5;\n}\n",Fs,As,"//\nfloat creepYp(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 - dot(coords, group.testTranslationB)) / length(group.testTranslationB);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(Us.testTranslationB)<-.5}),"//\nbool testYn(Point p){\n    return dot(p.coords, group.testTranslationB) < -0.5;\n}\n",As,Fs,"//\nfloat creepYn(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    float dist = (0.5 + dot(coords, group.testTranslationB)) / length(group.testTranslationB);\n    return dist + offset;\n}\n").add((function(e){return e.coords.dot(Us.testTranslationC)>.5}),"//\nbool testZp(Point p){\n    return dot(p.coords, group.testTranslationC) > 0.5;\n}\n",zs,Gs).add((function(e){return e.coords.dot(Us.testTranslationC)<-.5}),"//\nbool testZn(Point p){\n    return dot(p.coords, group.testTranslationC) < -0.5;\n}\n",Gs,zs);var qs=r(2637),Os=r.n(qs),js=r(8817),Ws=r.n(js),Qs=r(7577),Ks=r.n(Qs);class Zs extends wt{constructor(e,t,n=1){super(1),this.addImport(Os()),this.position=e,this.color=t,this.intensity=n}get isGlobal(){return!0}get uniformType(){return"FakePointLight"}static glslClass(){return Ws()}glslDirections(){return Ks()(this)}}var Ys=r(653),Xs=r.n(Ys);class $s extends wt{constructor(e,t=1,n){super(1),this.color=e,this.intensity=t,this.direction=n.clone().normalize()}get isGlobal(){return!0}get uniformType(){return"ConstDirLight"}static glslClass(){return Xs()}glslDirections(){return Ks()(this)}}var Js=r(7041),ei=r.n(Js);class ti extends wt{constructor(e,t,n=1){super(1),this.addImport(Os()),this.position=e,this.color=t,this.intensity=n}get isGlobal(){return!0}get uniformType(){return"FakeLocalPointLight"}static glslClass(){return ei()}glslDirections(){return Ks()(this)}}var ni=r(3022),ri=r.n(ni);class ai extends Tt{constructor(e,t){super(),this.mainColor=e,this.weight=t}get uniformType(){return"VaryingColorMaterial"}get usesNormal(){return!1}static glslClass(){return ri()}glslRender(){return Et()(this)}}var oi=r(6891),si=r.n(oi);class ii extends Tt{constructor(e,t,n,r,a){super(),this.mainColor=e,this.accent1=t,this.accent2=n,this.accent3=r,this.grid=null!=a&&a}get uniformType(){return"MultiColorMaterial"}get usesNormal(){return!1}static glslClass(){return si()}glslRender(){return Et()(this)}}var li=r(129),ci=r.n(li),hi=r(3707),di=r.n(hi),ui=r(4355),pi=r.n(ui);class mi extends _t{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");r.makeTranslation(e)}super(r),this.addImport(Os()),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!0}get isFakeBallShape(){return!0}get uniformType(){return"FakeBallShape"}get hasUVMap(){return!0}static glslClass(){return ci()}glslSDF(){return di()(this)}glslUVMap(){return pi()(this)}}var bi=r(7462),vi=r.n(bi),fi=r(8302),gi=r.n(fi),xi=r(1407),yi=r.n(xi);class Vi extends _t{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");r.makeTranslation(e)}super(r),this.addImport(vi()),this.addImport(Os()),this.addImport(gi()),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!0}get isFakeBallShape(){return!0}get uniformType(){return"BallShape"}get hasUVMap(){return!0}static glslClass(){return yi()}glslSDF(){return di()(this)}glslUVMap(){return pi()(this)}}var _i=r(9039),Mi=r.n(_i);class wi extends _t{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("LocalFakeBallShape: the type of location is not implemented");r.makeTranslation(e)}super(r),this.addImport(Os()),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get isLocalFakeBallShape(){return!0}get uniformType(){return"LocalFakeBallShape"}get hasUVMap(){return!0}static glslClass(){return Mi()}glslSDF(){return di()(this)}glslUVMap(){return pi()(this)}}var Ti=r(5627),Ci=r.n(Ti);class Si extends _t{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("LocalFakeBallShape: the type of location is not implemented");r.makeTranslation(e)}super(r),this.addImport(vi()),this.addImport(Os()),this.addImport(gi()),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get isLocalFakeBallShape(){return!0}get uniformType(){return"LocalBallShape"}get hasUVMap(){return!0}static glslClass(){return Ci()}glslSDF(){return di()(this)}glslUVMap(){return pi()(this)}}var Ii=r(7189),Ri=r.n(Ii);class Di extends _t{constructor(e,t,r,a,o){const s=new n;if(e.isIsometry)s.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");s.makeTranslation(e)}super(s),this.addImport(Os()),this.radius=t,this.coeff1=r,this.coeff2=a,this.exp=o,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!0}get isLocalPotatoShape(){return!0}get uniformType(){return"PotatoShape"}static glslClass(){return Ri()}glslSDF(){return di()(this)}}var Ei=r(8206),Pi=r.n(Ei);class ki extends _t{constructor(e,t,r,a,o){const s=new n;if(e.isIsometry)s.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");s.makeTranslation(e)}super(s),this.addImport(Os()),this.radius=t,this.coeff1=r,this.coeff2=a,this.exp=o,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get isLocalPotatoShape(){return!0}get uniformType(){return"LocalPotatoShape"}get hasUVMap(){return!0}static glslClass(){return Pi()}glslSDF(){return di()(this)}glslUVMap(){return pi()(this)}}var Bi=r(6969),Ui=r.n(Bi),Ni=r(5030),Li=r.n(Ni);class Fi extends _t{constructor(e){super(e),this._pos=void 0,this._normal=void 0,this._uDir=void 0,this._vDir=new s(0,0,1)}updateData(){super.updateData(),this._pos=(new o).applyIsometry(this.absoluteIsom),this._pos.coords.setZ(0),this._normal=new s(1,0,0).applyMatrix4(this.absoluteIsom.matrix),this._normal.setZ(0),this._normal.normalize(),this._uDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix),this._uDir.setZ(0),this._uDir.normalize()}get pos(){return void 0===this._pos&&this.updateData(),this._pos}get normal(){return void 0===this._normal&&this.updateData(),this._normal}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return this._vDir}get isGlobal(){return!0}get isVerticalHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"VerticalHalfSpaceShape"}static glslClass(){return Ui()}glslSDF(){return di()(this)}glslGradient(){return Li()(this)}glslUVMap(){return pi()(this)}}var Ai=r(2552),zi=r.n(Ai);class Gi extends _t{constructor(e,t){super(),this.radius=t,this.isom=e,this._pos=void 0}updateData(){super.updateData(),this._pos=(new o).applyIsometry(this.absoluteIsom),this._pos.coords.setZ(0)}get pos(){return void 0===this._pos&&this.updateData(),this._pos}get isGlobal(){return!0}get hasUVMap(){return!0}get uniformType(){return"VerticalCylinderShape"}static glslClass(){return zi()}glslSDF(){return di()(this)}glslGradient(){return Li()(this)}glslUVMap(){return pi()(this)}}var Hi=r(3323),qi=r.n(Hi);class Oi extends _t{constructor(e,t){super(),this.radius=t,this.isom=e,this._pos=void 0}updateData(){super.updateData(),this._pos=(new o).applyIsometry(this.absoluteIsom),this._pos.coords.setZ(0)}get pos(){return void 0===this._pos&&this.updateData(),this._pos}get isGlobal(){return!1}get hasUVMap(){return!0}get uniformType(){return"LocalVerticalCylinderShape"}static glslClass(){return qi()}glslSDF(){return di()(this)}glslGradient(){return Li()(this)}glslUVMap(){return pi()(this)}}var ji=r(1209),Wi=r.n(ji);class Qi extends _t{constructor(e){super(e),this._pos=void 0,this._normal=void 0,this._uDir=void 0,this._vDir=new s(0,0,1)}updateData(){super.updateData(),this._pos=(new o).applyIsometry(this.absoluteIsom),this._pos.coords.setZ(0),this._normal=new s(1,0,0).applyMatrix4(this.absoluteIsom.matrix),this._normal.setZ(0),this._normal.normalize(),this._uDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix),this._uDir.setZ(0),this._uDir.normalize()}get pos(){return void 0===this._pos&&this.updateData(),this._pos}get normal(){return void 0===this._normal&&this.updateData(),this._normal}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return this._vDir}get isGlobal(){return!0}get isVerticalHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"VerticalHalfSpaceShape"}static glslClass(){return Wi()}glslSDF(){return di()(this)}glslGradient(){return Li()(this)}glslUVMap(){return pi()(this)}}var Ki=r(6116),Zi=r.n(Ki);class Yi extends _t{constructor(e,t){const r=new n;if(!e.isIsometry)throw new Error("FakeBallShape: the type of location is not implemented");r.copy(e),super(r),this.radius=t,this._pos=void 0,this._normal=void 0,this._trans=void 0}updateData(){super.updateData(),this._pos=(new o).applyIsometry(this.isom),this._pos.coords.setZ(0),this._normal=new t.Vector4(0,1,0,0).applyMatrix4(this.isom.matrix),this._normal.setZ(0).normalize();const e=this.isom.matrix.clone().invert().transpose();this._trans=new t.Vector4(0,0,1,0).applyMatrix4(e)}get pos(){return void 0===this._pos&&this.updateData(),this._pos}get normal(){return void 0===this._normal&&this.updateData(),this._normal}get trans(){return void 0===this._trans&&this.updateData(),this._trans}get isGlobal(){return!0}get isStraightGeoShape(){return!0}get uniformType(){return"StraightGeoShape"}static glslClass(){return Zi()}glslSDF(){return di()(this)}}var Xi=r(7499),$i=r.n(Xi);class Ji extends gt{constructor(e,t,n=void 0){if(!e.hasUVMap){if(t.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map");if(void 0!==n&&n.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map")}super(),this.shape=e,this.material=t,this.ptMaterial=n,this.isRendered=!0,this.addImport($i())}get isSolid(){return!0}get isom(){return this.shape.isom}get absoluteIsom(){return this.shape.absoluteIsom}get isGlobal(){return this.shape.isGlobal}get isLocal(){return this.shape.isLocal}get uniformType(){return"Solid"}updateData(){this.shape.updateData()}setId(e){this.shape.setId(e),this.material.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),this.material.onAdd(e),super.onAdd(e)}static glslClass(){return""}glslInstance(){return`\n            bool ${this.name}_isRenderedHack = true;\n        `}shader(e){this.shape.shader(e),3===e.useCase&&void 0!==this.ptMaterial?this.ptMaterial.shader(e):this.material.shader(e),super.shader(e)}}class el extends Ji{constructor(e,t,n,r=void 0){super(new mi(e,t),n,r)}}class tl extends Ji{constructor(e,t,n,r=void 0){super(new Vi(e,t),n,r)}}class nl extends Ji{constructor(e,t,n,r=void 0){super(new wi(e,t),n,r)}}class rl extends Ji{constructor(e,t,n,r=void 0){super(new Si(e,t),n,r)}}class al extends Ji{constructor(e,t,n,r,a,o,s=void 0){super(new ki(e,t,n,r,a),o,s)}}class ol extends Ji{constructor(e,t,n=void 0){super(new Fi(e),t,n)}}class sl extends Ji{constructor(e,t,n,r=void 0){super(new Gi(e,t),n,r)}}class il extends Ji{constructor(e,t,n,r=void 0){super(new Oi(e,t),n,r)}}class ll extends Ji{constructor(e,t,n=void 0){super(new Qi(e),t,n)}}class cl extends Ji{constructor(e,t,n,r=void 0){super(new Yi(e,t),n,r)}}m.prototype.constructor.shader1=d(),m.prototype.constructor.shader2=p()})();var o=a.T0,s=a.FJ,i=a.GU,l=a.XH,c=a.ec,h=a.Yb,d=a.ZH,u=a.K9,p=a.FT,m=a.cK,b=a._x,v=a.kj,f=a.V1,g=a.Vz,x=a.ck,y=a.Iy,V=a.Vf,_=a.TB,M=a.F6,w=a.Kd,T=a.Al,C=a.ix,S=a.jZ,I=a.c$,R=a.OZ,D=a.Ao,E=a.x9,P=a.ET,k=a.Qj,B=a.mD,U=a.yb,N=a.iJ,L=a.ZA,F=a.Jz,A=a.fR,z=a.kK,G=a.ZX,H=a._f,q=a.Ht,O=a.HZ,j=a.TN,W=a.JV,Q=a.Sc,K=a.Nh,Z=a.RL,Y=a._k,X=a.uR,$=a.gU,J=a.jo,ee=a.Q,te=a.oR,ne=a.lt,re=a.tl,ae=a.HI,oe=a.IJ,se=a.jD,ie=a.F5,le=a.Uc,ce=a.Fh,he=a.O5,de=a.oB,ue=a.pJ,pe=a.GW,me=a.DZ,be=a._K,ve=a.JF,fe=a.Lv,ge=a.E9,xe=a.Ly,ye=a.Gx,Ve=a.iv,_e=a.mH,Me=a.xd,we=a.pX,Te=a.Dz,Ce=a.Th,Se=a.Uj,Ie=a.bY,Re=a.cV,De=a.lR,Ee=a.xs,Pe=a.bn,ke=a.oC,Be=a.Z1,Ue=a.h8,Ne=a.Qf,Le=a.jE,Fe=a.k1,Ae=a.vb,ze=a.dh,Ge=a.ew,He=a.$p,qe=a.xG,Oe=a.l_,je=a.pk,We=a.yI,Qe=a.E6,Ke=a.zO,Ze=a.cB,Ye=a.OW,Xe=a.DV,$e=a.bt,Je=a.Pq,et=a.j5,tt=a.n3,nt=a.Se,rt=a.PQ,at=a.$9,ot=a.wJ,st=a.ak,it=a.uZ,lt=a.Cy,ct=a.qM,ht=a.Z,dt=a.aG,ut=a.mV,pt=a.Gi,mt=a.iz,bt=a.de,vt=a.zC,ft=a.jV,gt=a.j9,xt=a.oc,yt=a.wS,Vt=a.WT,_t=a.p2,Mt=a.w0,wt=a.VL,Tt=a.UR,Ct=a.dV,St=a.G0,It=a.YL,Rt=a.re;export{o as AcesFilmPostProcess,s as AdvancedResetVRControls,i as AdvancedShape,l as BOTH,c as Ball,h as BallShape,d as BasicPTMaterial,u as BasicRenderer,p as BasicShape,m as CREEPING_FULL,b as CREEPING_OFF,v as CREEPING_STRICT,f as Camera,g as CheckerboardMaterial,x as CombinedPostProcess,y as ComplementShape,V as ConstDirLight,_ as DebugMaterial,M as DirectedVerticalHalfSpace,w as DirectedVerticalHalfSpaceShape,T as DragVRControls,C as EquidistantHypStripsMaterial,S as EquidistantSphStripsMaterial,I as ExpFog,R as FakeBall,D as FakeBallShape,E as FakeLocalPointLight,P as FakePointLight,k as FlatCamera,B as FlyControls,U as Fog,N as GraphPaperMaterial,L as Group,F as GroupElement,A as HighlightLocalWrapMaterial,z as HighlightWrapMaterial,G as HypStripsMaterial,H as ImprovedEquidistantHypStripsMaterial,q as ImprovedEquidistantSphStripsMaterial,O as InfoControls,j as IntersectionShape,W as Isometry,Q as IsotropicChaseVRControls,K as KeyGenericControls,Z as LEFT,Y as Light,X as LightVRControls,$ as LinearToSRGBPostProcess,J as LocalBall,ee as LocalBallShape,te as LocalFakeBall,ne as LocalFakeBallShape,re as LocalPotato,ae as LocalPotatoShape,oe as LocalVerticalCylinder,se as LocalVerticalCylinderShape,ie as Material,le as Matrix2,ce as MoveVRControls,he as MultiColorMaterial,de as NormalMaterial,ue as PTMaterial,pe as PathTracerCamera,me as PathTracerRenderer,be as PathTracerWrapMaterial,ve as PhongMaterial,fe as PhongWrapMaterial,ge as Point,xe as Position,ye as PotatoShape,Ve as QuadRing,_e as QuadRingElement,Me as QuadRingMatrix4,we as RIGHT,Te as RelPosition,Ce as Renderer,Se as ResetVRControls,Ie as RotatedSphericalTextureMaterial,Re as SMOOTH_MAX_POLY,De as SMOOTH_MIN_POLY,Ee as Scene,Pe as Shape,ke as ShootVRControls,Be as SimpleTextureMaterial,Ue as SingleColorMaterial,Ne as Solid,Le as SphereCamera,Fe as SquaresMaterial,Ae as StraightGeo,ze as StraightGeoShape,Ge as StripsMaterial,He as SwitchControls,qe as TeleportationSet,Oe as TransitionLocalWrapMaterial,je as TransitionWrapMaterial,We as UnionShape,Qe as VRCamera,Ke as VRRenderer,Ze as VaryingColorMaterial,Ye as Vector,Xe as VerticalCylinder,$e as VerticalCylinderShape,Je as VerticalHalfSpace,et as VerticalHalfSpaceShape,tt as VideoAlphaTextureMaterial,nt as VideoFrameTextureMaterial,rt as VideoTextureMaterial,at as WrapShape,ot as basicHeisenbergSet,st as bind,it as clamp,lt as complement,ct as earthTexture,ht as extendedHeisenbergSet,dt as heisenbergSet,ut as highlightLocalWrap,pt as highlightWrap,mt as importExactDistance,bt as importFakeDistance,vt as importUtils,ft as intersection,gt as marsTexture,xt as moonTexture,yt as pathTracerWrap,Vt as phongWrap,_t as safeString,Mt as sunTexture,wt as transitionLocalWrap,Tt as transitionWrap,Ct as trivialSet,St as union,It as woodBallMaterial,Rt as wrap};