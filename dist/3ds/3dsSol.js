import*as e from"three";var t={9397:(e,t)=>{!function(e){var t=/\S/,n=/\"/g,r=/\n/g,a=/\r/g,o=/\\/g,s=/\u2028/,i=/\u2029/;function l(e){"}"===e.n.substr(e.n.length-1)&&(e.n=e.n.substring(0,e.n.length-1))}function c(e){return e.trim?e.trim():e.replace(/^\s*|\s*$/g,"")}function d(e,t,n){if(t.charAt(n)!=e.charAt(0))return!1;for(var r=1,a=e.length;r<a;r++)if(t.charAt(n+r)!=e.charAt(r))return!1;return!0}e.tags={"#":1,"^":2,"<":3,$:4,"/":5,"!":6,">":7,"=":8,_v:9,"{":10,"&":11,_t:12},e.scan=function(n,r){var a=n.length,o=0,s=null,i=null,u="",h=[],p=!1,m=0,b=0,v="{{",f="}}";function g(){u.length>0&&(h.push({tag:"_t",text:new String(u)}),u="")}function x(n,r){if(g(),n&&function(){for(var n=!0,r=b;r<h.length;r++)if(!(n=e.tags[h[r].tag]<e.tags._v||"_t"==h[r].tag&&null===h[r].text.match(t)))return!1;return n}())for(var a,o=b;o<h.length;o++)h[o].text&&((a=h[o+1])&&">"==a.tag&&(a.indent=h[o].text.toString()),h.splice(o,1));else r||h.push({tag:"\n"});p=!1,b=h.length}function y(e,t){var n="="+f,r=e.indexOf(n,t),a=c(e.substring(e.indexOf("=",t)+1,r)).split(" ");return v=a[0],f=a[a.length-1],r+n.length-1}for(r&&(r=r.split(" "),v=r[0],f=r[1]),m=0;m<a;m++)0==o?d(v,n,m)?(--m,g(),o=1):"\n"==n.charAt(m)?x(p):u+=n.charAt(m):1==o?(m+=v.length-1,"="==(s=(i=e.tags[n.charAt(m+1)])?n.charAt(m+1):"_v")?(m=y(n,m),o=0):(i&&m++,o=2),p=m):d(f,n,m)?(h.push({tag:s,n:c(u),otag:v,ctag:f,i:"/"==s?p-v.length:m+f.length}),u="",m+=f.length-1,o=0,"{"==s&&("}}"==f?m++:l(h[h.length-1]))):u+=n.charAt(m);return x(p,!0),h};var u={_t:!0,"\n":!0,$:!0,"/":!0};function h(t,n,r,a){var o,s=[],i=null,l=null;for(o=r[r.length-1];t.length>0;){if(l=t.shift(),o&&"<"==o.tag&&!(l.tag in u))throw new Error("Illegal content in < super tag.");if(e.tags[l.tag]<=e.tags.$||p(l,a))r.push(l),l.nodes=h(t,l.tag,r,a);else{if("/"==l.tag){if(0===r.length)throw new Error("Closing tag without opener: /"+l.n);if(i=r.pop(),l.n!=i.n&&!m(l.n,i.n,a))throw new Error("Nesting error: "+i.n+" vs. "+l.n);return i.end=l.i,s}"\n"==l.tag&&(l.last=0==t.length||"\n"==t[0].tag)}s.push(l)}if(r.length>0)throw new Error("missing closing tag: "+r.pop().n);return s}function p(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n].o==e.n)return e.tag="#",!0}function m(e,t,n){for(var r=0,a=n.length;r<a;r++)if(n[r].c==e&&n[r].o==t)return!0}function b(e){var t=[];for(var n in e.partials)t.push('"'+f(n)+'":{name:"'+f(e.partials[n].name)+'", '+b(e.partials[n])+"}");return"partials: {"+t.join(",")+"}, subs: "+function(e){var t=[];for(var n in e)t.push('"'+f(n)+'": function(c,p,t,i) {'+e[n]+"}");return"{ "+t.join(",")+" }"}(e.subs)}e.stringify=function(t,n,r){return"{code: function (c,p,i) { "+e.wrapMain(t.code)+" },"+b(t)+"}"};var v=0;function f(e){return e.replace(o,"\\\\").replace(n,'\\"').replace(r,"\\n").replace(a,"\\r").replace(s,"\\u2028").replace(i,"\\u2029")}function g(e){return~e.indexOf(".")?"d":"f"}function x(e,t){var n="<"+(t.prefix||"")+e.n+v++;return t.partials[n]={name:e.n,partials:{}},t.code+='t.b(t.rp("'+f(n)+'",c,p,"'+(e.indent||"")+'"));',n}function y(e,t){t.code+="t.b(t.t(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'}function V(e){return"t.b("+e+");"}e.generate=function(t,n,r){v=0;var a={code:"",subs:{},partials:{}};return e.walk(t,a),r.asString?this.stringify(a,n,r):this.makeTemplate(a,n,r)},e.wrapMain=function(e){return'var t=this;t.b(i=i||"");'+e+"return t.fl();"},e.template=e.Template,e.makeTemplate=function(e,t,n){var r=this.makePartials(e);return r.code=new Function("c","p","i",this.wrapMain(e.code)),new this.template(r,t,this,n)},e.makePartials=function(e){var t,n={subs:{},partials:e.partials,name:e.name};for(t in n.partials)n.partials[t]=this.makePartials(n.partials[t]);for(t in e.subs)n.subs[t]=new Function("c","p","t","i",e.subs[t]);return n},e.codegen={"#":function(t,n){n.code+="if(t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,0,'+t.i+","+t.end+',"'+t.otag+" "+t.ctag+'")){t.rs(c,p,function(c,p,t){',e.walk(t.nodes,n),n.code+="});c.pop();}"},"^":function(t,n){n.code+="if(!t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,1,0,0,"")){',e.walk(t.nodes,n),n.code+="};"},">":x,"<":function(t,n){var r={partials:{},code:"",subs:{},inPartial:!0};e.walk(t.nodes,r);var a=n.partials[x(t,n)];a.subs=r.subs,a.partials=r.partials},$:function(t,n){var r={subs:{},code:"",partials:n.partials,prefix:t.n};e.walk(t.nodes,r),n.subs[t.n]=r.code,n.inPartial||(n.code+='t.sub("'+f(t.n)+'",c,p,i);')},"\n":function(e,t){t.code+=V('"\\n"'+(e.last?"":" + i"))},_v:function(e,t){t.code+="t.b(t.v(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'},_t:function(e,t){t.code+=V('"'+f(e.text)+'"')},"{":y,"&":y},e.walk=function(t,n){for(var r,a=0,o=t.length;a<o;a++)(r=e.codegen[t[a].tag])&&r(t[a],n);return n},e.parse=function(e,t,n){return h(e,0,[],(n=n||{}).sectionTags||[])},e.cache={},e.cacheKey=function(e,t){return[e,!!t.asString,!!t.disableLambda,t.delimiters,!!t.modelGet].join("||")},e.compile=function(t,n){n=n||{};var r=e.cacheKey(t,n),a=this.cache[r];if(a){var o=a.partials;for(var s in o)delete o[s].instance;return a}return a=this.generate(this.parse(this.scan(t,n.delimiters),t,n),t,n),this.cache[r]=a}}(t)},5485:(e,t,n)=>{var r=n(9397);r.Template=n(2882).Template,r.template=r.Template,e.exports=r},2882:(e,t)=>{!function(e){function t(e,t,n){var r;return t&&"object"==typeof t&&(void 0!==t[e]?r=t[e]:n&&t.get&&"function"==typeof t.get&&(r=t.get(e))),r}e.Template=function(e,t,n,r){e=e||{},this.r=e.code||this.r,this.c=n,this.options=r||{},this.text=t||"",this.partials=e.partials||{},this.subs=e.subs||{},this.buf=""},e.Template.prototype={r:function(e,t,n){return""},v:function(e){return e=l(e),i.test(e)?e.replace(n,"&amp;").replace(r,"&lt;").replace(a,"&gt;").replace(o,"&#39;").replace(s,"&quot;"):e},t:l,render:function(e,t,n){return this.ri([e],t||{},n)},ri:function(e,t,n){return this.r(e,t,n)},ep:function(e,t){var n=this.partials[e],r=t[n.name];if(n.instance&&n.base==r)return n.instance;if("string"==typeof r){if(!this.c)throw new Error("No compiler available.");r=this.c.compile(r,this.options)}if(!r)return null;if(this.partials[e].base=r,n.subs){for(key in t.stackText||(t.stackText={}),n.subs)t.stackText[key]||(t.stackText[key]=void 0!==this.activeSub&&t.stackText[this.activeSub]?t.stackText[this.activeSub]:this.text);r=function(e,t,n,r,a,o){function s(){}function i(){}var l;s.prototype=e,i.prototype=e.subs;var c=new s;for(l in c.subs=new i,c.subsText={},c.buf="",r=r||{},c.stackSubs=r,c.subsText=o,t)r[l]||(r[l]=t[l]);for(l in r)c.subs[l]=r[l];for(l in a=a||{},c.stackPartials=a,n)a[l]||(a[l]=n[l]);for(l in a)c.partials[l]=a[l];return c}(r,n.subs,n.partials,this.stackSubs,this.stackPartials,t.stackText)}return this.partials[e].instance=r,r},rp:function(e,t,n,r){var a=this.ep(e,n);return a?a.ri(t,n,r):""},rs:function(e,t,n){var r=e[e.length-1];if(c(r))for(var a=0;a<r.length;a++)e.push(r[a]),n(e,t,this),e.pop();else n(e,t,this)},s:function(e,t,n,r,a,o,s){var i;return(!c(e)||0!==e.length)&&("function"==typeof e&&(e=this.ms(e,t,n,r,a,o,s)),i=!!e,!r&&i&&t&&t.push("object"==typeof e?e:t[t.length-1]),i)},d:function(e,n,r,a){var o,s=e.split("."),i=this.f(s[0],n,r,a),l=this.options.modelGet,d=null;if("."===e&&c(n[n.length-2]))i=n[n.length-1];else for(var u=1;u<s.length;u++)void 0!==(o=t(s[u],i,l))?(d=i,i=o):i="";return!(a&&!i)&&(a||"function"!=typeof i||(n.push(d),i=this.mv(i,n,r),n.pop()),i)},f:function(e,n,r,a){for(var o=!1,s=!1,i=this.options.modelGet,l=n.length-1;l>=0;l--)if(void 0!==(o=t(e,n[l],i))){s=!0;break}return s?(a||"function"!=typeof o||(o=this.mv(o,n,r)),o):!a&&""},ls:function(e,t,n,r,a){var o=this.options.delimiters;return this.options.delimiters=a,this.b(this.ct(l(e.call(t,r)),t,n)),this.options.delimiters=o,!1},ct:function(e,t,n){if(this.options.disableLambda)throw new Error("Lambda features disabled.");return this.c.compile(e,this.options).render(t,n)},b:function(e){this.buf+=e},fl:function(){var e=this.buf;return this.buf="",e},ms:function(e,t,n,r,a,o,s){var i,l=t[t.length-1],c=e.call(l);return"function"==typeof c?!!r||(i=this.activeSub&&this.subsText&&this.subsText[this.activeSub]?this.subsText[this.activeSub]:this.text,this.ls(c,l,n,i.substring(a,o),s)):c},mv:function(e,t,n){var r=t[t.length-1],a=e.call(r);return"function"==typeof a?this.ct(l(a.call(r)),r,n):a},sub:function(e,t,n,r){var a=this.subs[e];a&&(this.activeSub=e,a(t,n,this,r),this.activeSub=!1)}};var n=/&/g,r=/</g,a=/>/g,o=/\'/g,s=/\"/g,i=/[&<>\"\']/;function l(e){return String(null==e?"":e)}var c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}}(t)},9606:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n, r);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, rayType);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n, r);\n}\n\nvec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    return render({{name}}, v, rayType);\n}",r);return e.render.apply(e,arguments)}},9909:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);"),r.b("\n"+n),r.b("    //return vec4(debugColor,1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);\n    //return vec4(debugColor,1);\n}",r);return e.render.apply(e,arguments)}},8906:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},1998:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,220,289,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,481,540,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},699:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,405,478,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,580,881,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,764,845,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1119,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1289,1570,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1464,1535,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},4261:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,210,275,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,463,518,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},8474:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},5506:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,171,240,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,432,491,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},7397:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,356,429,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,531,832,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,715,796,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1070,1133,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1240,1521,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1415,1486,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},3045:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,161,226,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,414,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},6077:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    return normalMaterialRender(v, normal);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    return normalMaterialRender(v, normal);\n}",r);return e.render.apply(e,arguments)}},1202:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n,r);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n,r);\n}",r);return e.render.apply(e,arguments)}},2330:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v).rgb;\n}",r);return e.render.apply(e,arguments)}},9040:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, normal).rgb;\n}",r);return e.render.apply(e,arguments)}},588:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;   "),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;   \n    }\n    return {{material.name}}_render(v, normal, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},1365:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("      return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n      return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},8149:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,204,519,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongMaterial material = {{name}};\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},3838:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,261,587,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},472:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,269,595,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},7660:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,282,608,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},8204:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,275,601,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},5377:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.b("        color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    color0 = {{mat0.name}}_render(v);\n\n    if(v.vector.cellBoost == material.cellBoost){\n        color1 = {{mat1.name}}_render(v);\n    } else{\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},9441:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,156,212,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,405,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else {"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionLocalWrapMaterial material = {{name}};\n    vec4 color0, color1;\n    {{#mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v, normal);\n        {{/mat1.usesNormal}}\n        {{^mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v);\n        {{/mat1.usesNormal}}\n    } else {\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},9245:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,296,355,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,429,658,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,567,634,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,834,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,1017,1274,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1171,1246,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            {{^mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal);\n            {{/mat1.usesUVMap}}\n            {{#mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal, uv);\n            {{/mat1.usesUVMap}}\n        {{/mat1.usesNormal}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},6766:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,147,198,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,386,445,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},8402:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    TransitionWrapMaterial material = {{name}};\n\n    vec4 color0 = {{mat0.name}}_render(v);\n    vec4 color1 = {{mat1.name}}_render(v);\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},6158:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,127,188,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,332,393,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    {{#mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v, normal);\n    {{/mat1.usesNormal}}\n    {{^mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v);\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},4146:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,271,335,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,409,648,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,552,624,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,829,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,967,1206,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1110,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n    \n    {{#mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},2332:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,117,173,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,312,368,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    {{#mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v, uv);\n    {{/mat1.usesUVMap}}\n    {{^mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v);\n    {{/mat1.usesUVMap}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},6142:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return negate("),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v));"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the complement of a shape\n */\nRelVector {{name}}_gradient(RelVector v){\n    return negate({{shape.name}}_gradient(v));\n}",r);return e.render.apply(e,arguments)}},7939:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    return - "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the complement of a shape\n */\nfloat {{name}}_sdf(RelVector v){\n    return - {{shape.name}}_sdf(v);\n}",r);return e.render.apply(e,arguments)}},7260:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},6861:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMaxPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMaxPoly(dist1, dist2, grad1, grad2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},3335:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the intersection of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6428:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMaxPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMaxPoly(dist1, dist2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},2076:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return max(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the intersection of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return max(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},2905:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},8655:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMinPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMinPoly(dist1, dist2, grad1, grad2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},7762:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},3238:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMinPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMinPoly(dist1, dist2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},3908:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return min(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return min(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},7500:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6242:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for a wrapping\n */\nRelVector {{name}}_gradient(RelVector v){\n    return {{shape.name}}_gradient(v);\n}",r);return e.render.apply(e,arguments)}},3105:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float wrap = "),r.b(r.v(r.d("wrap.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(wrap > camera.threshold){"),r.b("\n"+n),r.b("        return wrap;"),r.b("\n"+n),r.b("    } else {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for a wrapping\n */\nfloat {{name}}_sdf(RelVector v){\n    float wrap = {{wrap.name}}_sdf(v);\n    if(wrap > camera.threshold){\n        return wrap;\n    } else {\n        return {{shape.name}}_sdf(v);\n    }\n}",r);return e.render.apply(e,arguments)}},9338:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},7577:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("bool "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(RelVector v, int i, out RelVector dir, out float intensity) {"),r.b("\n"+n),r.b("    return directions("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, i, dir, intensity);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"bool {{name}}_directions(RelVector v, int i, out RelVector dir, out float intensity) {\n    return directions({{name}}, v, i, dir, intensity);\n}",r);return e.render.apply(e,arguments)}},8778:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return render({{name}}, v);\n}\n",r);return e.render.apply(e,arguments)}},1215:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, uv);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    return render({{name}}, v, uv);\n}\n",r);return e.render.apply(e,arguments)}},2044:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1403,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1386,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representation of v can be updated"),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2169,2585,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2232,2533,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3143,3524,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3165,3506,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representation of v can be updated\n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},7781:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec4 color;"),r.b("\n"+n),r.b("    vec4 reflectivity;"),r.b("\n"+n),r.b("    float opacity;"),r.b("\n"+n),r.b("    float t;"),r.b("\n"),r.b("\n"+n),r.b("    switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,315,5918,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,0,373,2190,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,589,724,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,822,1314,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,1071,1278,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("            if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                opacity = 1.;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else {"),r.b("\n"+n),r.b("                opacity = color.a;"),r.b("\n"+n),r.b("            }"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,1525,1604,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                //color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("            if(opacity == 1.) {"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else{"),r.b("\n"+n),r.b("                v.data.stop = false;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;"),r.b("\n"+n),r.b("            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;"),r.b("\n"+n),r.b("            "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack = false;"),r.b("\n"+n),r.b("            v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("            v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("            //v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,1,0,0,"")||(r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,0,2294,4409,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("                if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                    reflectivity = vec4(0);"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else {"),r.b("\n"+n),r.b("                    reflectivity = vec4("),r.b(r.v(r.d("material.name",e,t,0))),r.b(".reflectivity,1);"),r.b("\n"+n),r.b("                }"),r.b("\n"),r.b("\n"+n),r.b("                normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                // in general the gradient is not necessarily a unit vector"),r.b("\n"+n),r.b("                normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,2944,3091,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,3197,3593,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,3398,3553,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,3649,3734,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                if(length(reflectivity) == 0.) {"),r.b("\n"+n),r.b("                    v.data.stop = true;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else{"),r.b("\n"+n),r.b("                    v.data.stop = false;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;"),r.b("\n"+n),r.b("                v.vector = geomReflect(v.vector,normal);"),r.b("\n"+n),r.b("                v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("                v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("                v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,4710,4857,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,4963,5495,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,5232,5455,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,5551,5636,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n)),r.b("\n"+n)),r.b("        break;"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec4 color = "),r.b(r.v(r.d("scene.background.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));\n}\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    vec2 uv;\n    vec4 color;\n    vec4 reflectivity;\n    float opacity;\n    float t;\n\n    switch(objId){\n    {{#scene.solids}}\n\n        case {{id}}:\n        {{#material.isTransparent}}\n\n            {{^material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color =  {{material.name}}_render(v);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            {{#material.usesNormal}}\n                {{^material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    color = {{material.name}}_render(v, normal);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, normal, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            if(v.data.iBounce == maxBounces){\n                opacity = 1.;\n            }\n            else {\n                opacity = color.a;\n            }\n\n            {{#scene.fog}}\n                //color = applyFog(color, v.data.lastBounceDist);\n            {{/scene.fog}}\n\n            if(opacity == 1.) {\n                v.data.stop = true;\n            }\n            else{\n                v.data.stop = false;\n            }\n            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;\n            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;\n            {{name}}_isRenderedHack = false;\n            v.data.lastBounceDist = 0.;\n            v.data.iBounce = v.data.iBounce + 1;\n            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n            //v = flow(v, t);\n\n        {{/material.isTransparent}}\n\n        {{^material.isTransparent}}\n\n            {{#material.isReflecting}}\n\n                if(v.data.iBounce == maxBounces){\n                    reflectivity = vec4(0);\n                }\n                else {\n                    reflectivity = vec4({{material.name}}.reflectivity,1);\n                }\n\n                normal = {{shape.name}}_gradient(v.vector);\n                // in general the gradient is not necessarily a unit vector\n                normal = geomNormalize(normal);\n\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                if(length(reflectivity) == 0.) {\n                    v.data.stop = true;\n                }\n                else{\n                    v.data.stop = false;\n                }\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;\n                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;\n                v.vector = geomReflect(v.vector,normal);\n                v.data.lastBounceDist = 0.;\n                v.data.iBounce = v.data.iBounce + 1;\n                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n                v = flow(v, t);\n\n            {{/material.isReflecting}}\n\n            {{^material.isReflecting}}\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n                v.data.leftToComputeColor = vec4(0);\n                v.data.stop = true;\n            {{/material.isReflecting}}\n\n        {{/material.isTransparent}}\n        break;\n\n    {{/scene.solids}}\n    }\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec4 color = {{scene.background.name}}_render(v);\n        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},4122:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * We assume that we are inside a solid"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("void nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    ior = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.ior; // index of the "air"'),r.b("\n"+n),r.b("    absorb = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.absorb; // absorb of the "air"'),r.b("\n"+n),r.b("    emission=vec3(0,0,0);//no emission from 'air'"),r.b("\n"+n),r.b("    opticalDepth="),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.opticalDepth; // opticalDepth of the "air"'),r.b("\n"+n),r.b("    isInside = false;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    RelVector v = flow(normal, 2. * camera.threshold);"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,579,1010,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("            dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("            if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                ior = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("                absorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("                emission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("                opticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("                isInside = true;"),r.b("\n"+n),r.b("                return;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("}"),r.fl()},partials:{},subs:{}},'/**\n * We assume that we are inside a solid\n */\nvoid nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){\n    float dist;\n    ior = {{scene.ptBackground.name}}.ior; // index of the "air"\n    absorb = {{scene.ptBackground.name}}.absorb; // absorb of the "air"\n    emission=vec3(0,0,0);//no emission from \'air\'\n    opticalDepth={{scene.ptBackground.name}}.opticalDepth; // opticalDepth of the "air"\n    isInside = false;\n    \n    RelVector v = flow(normal, 2. * camera.threshold);\n    {{#scene.solids}}\n        if({{name}}.isRendered){\n            dist = {{shape.name}}_sdf(v);\n            if(dist < camera.threshold) {\n                ior = {{ptMaterial.name}}.ior;\n                absorb = {{ptMaterial.name}}.absorb;\n                emission = {{ptMaterial.name}}.volumeEmission;\n                opticalDepth = {{ptMaterial.name}}.opticalDepth;\n                isInside = true;\n                return;\n            }\n        }\n    {{/scene.solids}}\n}',r);return e.render.apply(e,arguments)}},6172:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1381,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1364,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representatiion of v can be updated "),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2149,2565,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2212,2513,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3123,3482,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3145,3464,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representatiion of v can be updated \n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},6272:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".absorb, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".volumeEmission, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".opticalDepth, false);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void roulette(inout ExtVector v){"),r.b("\n"+n),r.b("    // as the light left gets smaller, the ray is more likely to get terminated early."),r.b("\n"+n),r.b("    // survivors have their value boosted to make up for fewer samples being in the average."),r.b("\n"+n),r.b("    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));"),r.b("\n"+n),r.b("    if (randomFloat() > p){"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    // add the energy we 'lose' by randomly terminating paths"),r.b("\n"+n),r.b("    v.data.light = v.data.light / p;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    RayType rayType;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec3 color;"),r.b("\n"+n),r.b("    vec3 reflectivity;"),r.b("\n"+n),r.b("    float hackCoeff = 1.;"),r.b("\n"+n),r.b("    float r; /** ratio of IOR */"),r.b("\n"+n),r.b("    float nextIOR; /** IOR of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextAbsorb; /** absorb of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextEmission;/** volumetric emission of the neighbor solid */"),r.b("\n"+n),r.b("    float nextOpticalDepth;/** optical depth of the neighbor solid */"),r.b("\n"+n),r.b("    bool nextIsInside = true;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector diffuseDir;"),r.b("\n"+n),r.b("    RelVector reflectDir;"),r.b("\n"+n),r.b("    RelVector refractDir;"),r.b("\n"),r.b("\n"+n),r.b("    // get a uniformly distributed vector on the sphere"),r.b("\n"+n),r.b("    RelVector random = randomVector(v.vector);"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("    //get volumetric coloring:"),r.b("\n"+n),r.b("    //portion of light is absorbed."),r.b("\n"+n),r.b("    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    //light is emitted along the journey (linear or expoenential pickup)"),r.b("\n"+n),r.b("    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;"),r.b("\n"+n),r.b("    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);"),r.b("\n"),r.b("\n"+n),r.b("    //use these quantities to update pixel and light:"),r.b("\n"+n),r.b("    v.data.light = v.data.light * volAbsorb;"),r.b("\n"+n),r.b("    v.data.pixel = v.data.pixel + v.data.light*volEmit;"),r.b("\n"+n),r.b("    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output"),r.b("\n"+n),r.b("    "),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,2036,5260,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("    "),r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.b("            normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("            normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.b("            "),r.b("\n"+n),r.b("            // get info and reset normal based on which side we are on."),r.b("\n"+n),r.b('            // starting assumption: in the "air"'),r.b("\n"+n),r.b("            r = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".ior / "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("            nextAbsorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("            nextEmission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("            nextOpticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(v.data.isInside){"),r.b("\n"+n),r.b("                //things to change if we are inside a material instead:"),r.b("\n"+n),r.b("                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);"),r.b("\n"+n),r.b("                r = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior / nextIOR;"),r.b("\n"+n),r.b("                normal = negate(normal);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            rayType = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_setRayType(v, normal,r);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color =  "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, rayType);"),r.b("\n"+n)),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,0,3160,3302,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                color = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, uv, rayType);"),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("        // hack to make sure that lights are not too bright"),r.b("\n"+n),r.b("            if(v.data.iBounce == 0){"),r.b("\n"+n),r.b("                hackCoeff = 0.2;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            //apply surface effects"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".emission;"),r.b("\n"+n),r.b("            if(!rayType.refract){"),r.b("\n"+n),r.b("                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);"),r.b("\n"+n),r.b("             }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            // update the ray direction"),r.b("\n"+n),r.b("            // diffuse uses a normal oriented cosine weighted hemisphere sample."),r.b("\n"+n),r.b("            diffuseDir = geomNormalize(add(normal, random));"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.diffuse){"),r.b("\n"+n),r.b("                v.vector = diffuseDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.reflect){"),r.b("\n"+n),r.b("                // perfectly smooth specular uses the reflection ray."),r.b("\n"+n),r.b("                reflectDir = geomReflect(v.vector, normal);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                v.vector = reflectDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.refract){"),r.b("\n"+n),r.b("                    refractDir = geomRefract(v.vector,normal, r);"),r.b("\n"+n),r.b("                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                    v.data.isInside = nextIsInside;"),r.b("\n"+n),r.b("                    v.data.currentAbsorb = nextAbsorb;"),r.b("\n"+n),r.b("                    v.data.currentEmission = nextEmission;"),r.b("\n"+n),r.b("                    v.data.currentOpticalDepth = nextOpticalDepth;"),r.b("\n"+n),r.b("                    v.vector = refractDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("    v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("    // be carefull, v is not normal to the surface"),r.b("\n"+n),r.b("    // if the time we flow is too small, we are still below the camera threshold"),r.b("\n"+n),r.b("    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("    v = flow(v, t);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor.rgb;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec3 bgColor = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".diffuse;"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.light * bgColor;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        roulette(v);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), {{scene.ptBackground.name}}.absorb, {{scene.ptBackground.name}}.volumeEmission, {{scene.ptBackground.name}}.opticalDepth, false);\n}\n\n\n\nvoid roulette(inout ExtVector v){\n    // as the light left gets smaller, the ray is more likely to get terminated early.\n    // survivors have their value boosted to make up for fewer samples being in the average.\n    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));\n    if (randomFloat() > p){\n        v.data.stop = true;\n    }\n    // add the energy we 'lose' by randomly terminating paths\n    v.data.light = v.data.light / p;\n}\n\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    RayType rayType;\n    vec2 uv;\n    vec3 color;\n    vec3 reflectivity;\n    float hackCoeff = 1.;\n    float r; /** ratio of IOR */\n    float nextIOR; /** IOR of the neighbor solid */\n    vec3 nextAbsorb; /** absorb of the neighbor solid */\n    vec3 nextEmission;/** volumetric emission of the neighbor solid */\n    float nextOpticalDepth;/** optical depth of the neighbor solid */\n    bool nextIsInside = true;\n\n    RelVector diffuseDir;\n    RelVector reflectDir;\n    RelVector refractDir;\n\n    // get a uniformly distributed vector on the sphere\n    RelVector random = randomVector(v.vector);\n\n\n\n\n\n    //get volumetric coloring:\n    //portion of light is absorbed.\n    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);\n    \n    //light is emitted along the journey (linear or expoenential pickup)\n    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;\n    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);\n\n    //use these quantities to update pixel and light:\n    v.data.light = v.data.light * volAbsorb;\n    v.data.pixel = v.data.pixel + v.data.light*volEmit;\n    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output\n    \n\n\n\n\n\n\nswitch(objId){\n    {{#scene.solids}}\n    \n        case {{id}}:\n            normal = {{shape.name}}_gradient(v.vector);\n            normal = geomNormalize(normal);\n\n            \n            // get info and reset normal based on which side we are on.\n            // starting assumption: in the \"air\"\n            r = {{scene.ptBackground.name}}.ior / {{ptMaterial.name}}.ior;\n            nextAbsorb = {{ptMaterial.name}}.absorb;\n            nextEmission = {{ptMaterial.name}}.volumeEmission;\n            nextOpticalDepth = {{ptMaterial.name}}.opticalDepth;\n        \n            if(v.data.isInside){\n                //things to change if we are inside a material instead:\n                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);\n                r = {{ptMaterial.name}}.ior / nextIOR;\n                normal = negate(normal);\n            }\n        \n            rayType = {{ptMaterial.name}}_setRayType(v, normal,r);\n        \n            {{^ptMaterial.usesUVMap}}\n                color =  {{ptMaterial.name}}_render(v, normal, rayType);\n            {{/ptMaterial.usesUVMap}}\n            {{#ptMaterial.usesUVMap}}\n                uv = {{shape.name}}_uvMap(v.vector);\n                color = {{ptMaterial.name}}_render(v, normal, uv, rayType);\n            {{/ptMaterial.usesUVMap}}\n        \n        \n        // hack to make sure that lights are not too bright\n            if(v.data.iBounce == 0){\n                hackCoeff = 0.2;\n            }\n        \n            //apply surface effects\n            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * {{ptMaterial.name}}.emission;\n            if(!rayType.refract){\n                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);\n             }\n        \n            // update the ray direction\n            // diffuse uses a normal oriented cosine weighted hemisphere sample.\n            diffuseDir = geomNormalize(add(normal, random));\n        \n            if(rayType.diffuse){\n                v.vector = diffuseDir;\n            }\n        \n            if(rayType.reflect){\n                // perfectly smooth specular uses the reflection ray.\n                reflectDir = geomReflect(v.vector, normal);\n        \n                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                v.vector = reflectDir;\n            }\n        \n            if(rayType.refract){\n                    refractDir = geomRefract(v.vector,normal, r);\n                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                    v.data.isInside = nextIsInside;\n                    v.data.currentAbsorb = nextAbsorb;\n                    v.data.currentEmission = nextEmission;\n                    v.data.currentOpticalDepth = nextOpticalDepth;\n                    v.vector = refractDir;\n            }\n            break;\n    \n    {{/scene.solids}}\n    }\n\n    v.data.lastBounceDist = 0.;\n    v.data.iBounce = v.data.iBounce + 1;\n    // be carefull, v is not normal to the surface\n    // if the time we flow is too small, we are still below the camera threshold\n    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n    v = flow(v, t);\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor.rgb;\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec3 bgColor = {{scene.ptBackground.name}}.diffuse;\n        v.data.pixel = v.data.pixel + v.data.light * bgColor;\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        roulette(v);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},5030:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return gradient("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    return gradient({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},8266:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float newEp = 0.001;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));"),r.b("\n"+n),r.b("    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));"),r.b("\n"),r.b("\n"+n),r.b("    float vgx = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPX) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMX);"),r.b("\n"+n),r.b("    float vgy = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPY) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMY);"),r.b("\n"+n),r.b("    float vgz = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPZ) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMZ);"),r.b("\n"+n),r.b("    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));"),r.b("\n"),r.b("\n"+n),r.b("    n = geomNormalize(n);"),r.b("\n"+n),r.b("    return n;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    float newEp = 0.001;\n\n    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));\n    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));\n    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));\n    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));\n    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));\n    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));\n\n    float vgx = {{name}}_sdf(shiftPX) - {{name}}_sdf(shiftMX);\n    float vgy = {{name}}_sdf(shiftPY) - {{name}}_sdf(shiftMY);\n    float vgz = {{name}}_sdf(shiftPZ) - {{name}}_sdf(shiftMZ);\n    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));\n\n    n = geomNormalize(n);\n    return n;\n}",r);return e.render.apply(e,arguments)}},3707:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v) {"),r.b("\n"+n),r.b("    return sdf("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"float {{name}}_sdf(RelVector v) {\n    return sdf({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},4355:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return uvMap("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return uvMap({{name}}, v);\n}",r);return e.render.apply(e,arguments)}},3148:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Default creeping function (binary search)"),r.b("\n"+n),r.b(" * @param start starting point of the creeping"),r.b("\n"+n),r.b(" * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)"),r.b("\n"+n),r.b(" * @param offset how long we flow after passing the boundary"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(ExtVector v, ExtVector outside,  float offset){"),r.b("\n"+n),r.b("    ExtVector try = outside;"),r.b("\n"+n),r.b("    float sIn = 0.;"),r.b("\n"+n),r.b("    float sOut = try.data.lastFlowDist;"),r.b("\n"+n),r.b("    float s;"),r.b("\n"+n),r.b("    for(int i=0; i < 100; i++){"),r.b("\n"+n),r.b("        if(sOut - sIn < offset){"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("        s = 0.5 * sIn + 0.5 * sOut;"),r.b("\n"+n),r.b("        try = flow(v,s);"),r.b("\n"+n),r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("            sOut = s;"),r.b("\n"+n),r.b("            outside = try;"),r.b("\n"+n),r.b("        } else {"),r.b("\n"+n),r.b("            sIn = s;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return sOut;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Default creeping function (binary search)\n * @param start starting point of the creeping\n * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)\n * @param offset how long we flow after passing the boundary\n */\nfloat {{glslCreepName}}(ExtVector v, ExtVector outside,  float offset){\n    ExtVector try = outside;\n    float sIn = 0.;\n    float sOut = try.data.lastFlowDist;\n    float s;\n    for(int i=0; i < 100; i++){\n        if(sOut - sIn < offset){\n            break;\n        }\n        s = 0.5 * sIn + 0.5 * sOut;\n        try = flow(v,s);\n        if({{glslTestName}}(try.vector.local.pos)){\n            sOut = s;\n            outside = try;\n        } else {\n            sIn = s;\n        }\n    }\n    return sOut;\n}",r);return e.render.apply(e,arguments)}},5103:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* Teleportation."),r.b("\n"+n),r.b("* Check if the local vector is still in the fundamental domain define by the teleportation tests."),r.b("\n"+n),r.b("* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true"),r.b("\n"+n),r.b("* Otherwise, do nothing and set teleported to false"),r.b("\n"+n),r.b("* @param[in] v the relative vector to teleport."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("ExtVector teleport(ExtVector v){"),r.b("\n"+n),r.b("    v.data.isTeleported = false;"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,424,621,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(v.vector.local.pos)){"),r.b("\n"+n),r.b("            v.vector = rewrite(v.vector, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("            v.data.isTeleported = true;"),r.b("\n"+n),r.b("            return v;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    return v;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Does one of the two following transformation:"),r.b("\n"+n),r.b("* flow the vector by the given time, if the vector escape the fundamental domain,"),r.b("\n"+n),r.b("* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain"),r.b("\n"+n),r.b("* (and even a bit further)"),r.b("\n"+n),r.b("*"),r.b("\n"+n),r.b("* @param[inout] v the relative vector to flow / teleport / creep."),r.b("\n"+n),r.b("* @param[in] t the (maximal) time to flow"),r.b("\n"+n),r.b("* @param[in] offset the amount we march passed the boundary"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float creepingDist(ExtVector v, float t, float offset){"),r.b("\n"+n),r.b("    float res = t;"),r.b("\n"+n),r.b("    ExtVector try = flow(v, t);"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,1233,1638,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.f("usesCreepingCustom",e,t,1),e,t,0,1266,1407,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.f("usesCreepingBinary",e,t,1),e,t,0,1463,1609,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, try, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n)})),e.pop()),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"/**\n* Teleportation.\n* Check if the local vector is still in the fundamental domain define by the teleportation tests.\n* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true\n* Otherwise, do nothing and set teleported to false\n* @param[in] v the relative vector to teleport.\n*/\nExtVector teleport(ExtVector v){\n    v.data.isTeleported = false;\n    {{#teleportations}}\n        if({{glslTestName}}(v.vector.local.pos)){\n            v.vector = rewrite(v.vector, {{elt.name}}, {{inv.name}});\n            v.data.isTeleported = true;\n            return v;\n        }\n    {{/teleportations}}\n    return v;\n}\n\n\n/**\n* Does one of the two following transformation:\n* flow the vector by the given time, if the vector escape the fundamental domain,\n* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain\n* (and even a bit further)\n*\n* @param[inout] v the relative vector to flow / teleport / creep.\n* @param[in] t the (maximal) time to flow\n* @param[in] offset the amount we march passed the boundary\n*/\nfloat creepingDist(ExtVector v, float t, float offset){\n    float res = t;\n    ExtVector try = flow(v, t);\n    {{#teleportations}}\n\n        {{#usesCreepingCustom}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, offset));\n            }\n        {{/usesCreepingCustom}}\n\n        {{#usesCreepingBinary}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, try, offset));\n            }\n        {{/usesCreepingBinary}}\n\n    {{/teleportations}}\n    return res;\n}\n\n\n",r);return e.render.apply(e,arguments)}},6097:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                                    \n                                                                                                                        \n\nstruct GroupElement {\n    Isometry isom;                                 \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(IDENTITY);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(multiply(elt1.isom, elt2.isom));\n}\n\n                                              \n                                                 \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return elt.isom;\n}"},9188:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                               \n                                                                                                                        \n\nstruct GroupElement {\n    bool fake;                                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(true);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(true);\n}\n\n                                              \n                                \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return IDENTITY;\n}"},5363:e=>{e.exports="   \n                                                                \n   \nfloat fresnelReflectAmount(RelVector incident, RelVector normal, float r, float reflecAt0, float relfectAt90) {\n                           \n    float r0 = (r - 1.) / (r + 1.);\n    r0 = r0 * r0;\n    float cosX = -geomDot(normal, incident);\n    if (r > 1.)\n    {\n        float sinT2 = r * r * (1. - cosX * cosX);\n                                    \n        if (sinT2 > 1.){\n            return relfectAt90;\n        }\n        cosX = sqrt(1. - sinT2);\n    }\n    float x = 1.- cosX;\n    float ret = clamp(r0 + (1. - r0) * x * x * x * x * x, 0., 1.);\n\n                                                        \n                               \n    return reflecAt0 + (relfectAt90 - reflecAt0) * ret;\n}"},2093:e=>{e.exports="   \n                                  \n   \nfloat smoothMaxPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return max(a, b) + 0.25 * k * h * h;\n}\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMaxPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n    return add(multiplyScalar(1. - 0.5 * h, gradMax), multiplyScalar(0.5 * h, gradMin));\n}\n"},5442:e=>{e.exports="float smoothMinPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return min(a, b) - 0.25 * k * h * h;\n}\n\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMinPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n\n    return add(multiplyScalar(1. - 0.5 * h, gradMin), multiplyScalar(0.5 * h, gradMax));\n}\n"},2143:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct BasicPTMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(BasicPTMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n                                                         \n                                  \n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\nvec3 render(BasicPTMaterial material, ExtVector v, RayType rayType) {\n    if (rayType.reflect){\n        return material.specular;\n    }\n                               \n                                              \n                                         \n       \n    return material.diffuse;\n}\n\n"},2197:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct CheckerboardMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\nvec4 render(CheckerboardMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    if (x1 < 1. && x2 < 1.){\n        return vec4(material.color1, 1);\n    } else if (x1 >= 1. && x2 >= 1.) {\n        return vec4(material.color1, 1);\n    } else {\n        return vec4(material.color2, 1);\n    }\n}\n\n"},7793:e=>{e.exports="\n                                                                                                                        \n                       \n                                                                                                                        \n"},4743:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct EquidistantHypStripsMaterial {\n    float distance;\n    float width;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(EquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float distP = atanh(uv.x);\n    float k = round(distP / material.distance);\n    vec2 q = horizontalTranslate(uv, -k * material.distance);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1917:e=>{e.exports="                                                                                                                        \n                                                  \n                                                                                                                        \n\nstruct EquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n\nvec4 render(EquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n    float theta = uv.x;\n    float phi = uv.y;\n    theta = theta - round(theta / material.distance) * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n                                                                                            \n    if (cosDistSq > material.cosHalfWidthSq) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},3801:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct GraphPaperMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\n\nfloat gridLines(vec2 uv, float size){\n    float brightness = 1./(2.*sqrt(size));\n    float gridPattern = abs(sin(3.14*size*uv.x)*sin(1.*3.14*size*uv.y));\n                                   \n    gridPattern = 1.-clamp(pow(gridPattern,0.05),0.,1.);\n    return gridPattern*brightness;\n}\n\nfloat grid(vec2 uv){\n    float grid1 = gridLines(uv,1.);\n    float grid2 = gridLines(uv,5.);\n    float grid3 = gridLines(uv,10.);\n    float grid4 = gridLines(uv,50.);\n    float gridTotal = grid1+grid2+grid3+grid4;\n    gridTotal *=5.;\n   return gridTotal;\n}\n\nvec4 render(GraphPaperMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    float gridPattern = grid(vec2(x1,x2));\n\n    vec3 col1 = material.color1*(1.-gridPattern);\n    vec3 col2 = material.color2*gridPattern;\n    return vec4(col1+col2,1.);\n\n}\n\n"},2278:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightLocalWrapMaterial {\n    GroupElement cellBoost;\n    bool isHighlightOn;\n};\n"},3048:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightWrapMaterial {\n    bool isHighlightOn;\n};\n"},7685:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct HypStripsMaterial {\n    float totalWidth;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n};\n\nvec4 render(HypStripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float aux = clamp(uv.x, -1., 1.);\n    float dist = atanh(aux);\n    float x = mod(dist / material.totalWidth, 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}"},4566:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantHypStripsMaterial {\n    float distance;\n    float halfWidth;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(ImprovedEquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float t = atanh(uv.x) - material.distance;\n    vec2 m = horizontalTranslate(uv, -t);\n    float distM = abs(distToYAxis(m));\n    float n = floor(log(distM / material.distance) / log(2.));\n\n    float distP = atanh(uv.x);\n    float period = pow(2., -n) * material.distance;\n    float k = round(distP / period);\n    vec2 q = horizontalTranslate(uv, -k * period);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1650:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    float fadingAmplitude;\n    vec3 stripColor;\n    vec3 bgColor;\n    mat4 rotation;\n};\n\nvec4 render(ImprovedEquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n                         \n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n\n\n                                                                                              \n    float ln2 = 0.6931471;                               \n\n    float theta = rotatedUV.x;\n    float phi = rotatedUV.y;\n    float k = round(theta / material.distance);\n    theta = theta - k * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n\n                                                                                            \n    if (cosDistSq < material.cosHalfWidthSq) {\n                                                               \n        return vec4(material.bgColor, 1);\n    }\n    if (k == 0.) {\n        return vec4(material.stripColor, 1);\n    }\n\n                                                                        \n                                                                             \n    int kInt = int(k);\n    int nInt = kInt & (~kInt + 1);\n    float n = float(nInt);\n                                \n                                                                                        \n    float theta0 = material.distance;\n    float theta1 = n * theta0;\n\n                                                    \n                                   \n                                                  \n           \n\n    float c = 0.66;\n    float sinPh1 = sin(c * theta0) / sin(theta1);\n    float phi1 = asin(clamp(sinPh1, 0., 1.));\n\n    float coeff = ((0.5 * PI - phi1) - abs(0.5 * PI - phi)) / material.fadingAmplitude + 0.5;\n    coeff = clamp(coeff, 0., 1.);\n    vec3 base = coeff * material.stripColor + (1. - coeff) * material.bgColor;\n    return vec4(base, 1);\n\n                         \n                                                                                       \n                                                                           \n                                       \n                                                        \n      \n                                                        \n}"},3496:e=>{e.exports="                                                                                                                        \n                  \n                                            \n                                                     \n                                                                                                                        \n\nvec4 normalMaterialRender(ExtVector v, RelVector normal) {\n    Vector[3] f;\n    Point pos = applyGroupElement(v.vector.cellBoost, v.vector.local.pos);\n    frame(pos, f);\n\n    f[0] = applyGroupElement(v.vector.invCellBoost, f[0]);\n    f[1] = applyGroupElement(v.vector.invCellBoost, f[1]);\n    f[2] = applyGroupElement(v.vector.invCellBoost, f[2]);\n    \n                  \n                            \n    float r =  geomDot(normal.local, f[0]);\n    float g =  geomDot(normal.local, f[1]);\n    float b =  geomDot(normal.local, f[2]);\n    return abs(vec4(r, g, b, 1));\n}"},7198:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct PathTracerWrapMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(PathTracerWrapMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\n"},6045:e=>{e.exports="                                                                                                                        \n                 \n                                                                                                                        \n\nstruct PhongMaterial {\n    vec3 color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, PhongMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * material.color;\n    vec3 ambient = ambientCoeff * ambientLight * material.color;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},5836:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct PhongWrapMaterial {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, vec3 baseColor, PhongWrapMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * baseColor;\n    vec3 ambient = ambientCoeff * ambientLight * baseColor;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},1220:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct RotatedSphericalTextureMaterial {\n    sampler2D sampler;\n    mat4 rotation;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(RotatedSphericalTextureMaterial material, ExtVector v, vec2 uv) {\n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n    vec2 texCoords = (rotatedUV - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},9095:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SimpleTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(SimpleTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},2664:e=>{e.exports="                                                                                                                        \n                        \n                                                                                                                        \n\nstruct SingleColorMaterial {\n    vec3 color;\n};\n\nvec4 render(SingleColorMaterial material, ExtVector v) {\n    return vec4(material.color, 1);\n}"},3081:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SquaresMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(SquaresMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x1 = mod(dot(uv, material.dir1) / dot(material.dir1, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2) / dot(material.dir2, material.dir2), 2.);\n    float c1 = abs(x1 - 1.);\n    float c2 = abs(x2 - 1.);\n    if (c1 < material.lengths.x && c2 < material.lengths.x){\n        color = material.color0;\n    } else if (c1 < material.lengths.y && c2 < material.lengths.y){\n        color = material.color1;\n    } else if (c1 < material.lengths.z && c2 < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n    return vec4(color, 1);\n}\n\n"},9835:e=>{e.exports="                                                                                                                        \n          \n                  \n                                                                                                                        \nstruct StripsMaterial {\n    vec2 dir;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(StripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x = mod(dot(uv, material.dir) / dot(material.dir, material.dir), 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}\n\n"},1888:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionLocalWrapMaterial {\n    GroupElement cellBoost;\n    float ratio;\n};\n"},5698:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionWrapMaterial {\n    float ratio;\n};\n"},2229:e=>{e.exports="\n\n                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoAlphaTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoAlphaTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    vec2 texCoordsUV = vec2(texCoords.x, 0.5 + 0.5 * texCoords.y);\n    vec2 texCoordsAlpha = vec2(texCoords.x, 0.5 * texCoords.y);\n    vec4 color =  texture(material.sampler, texCoordsUV);\n    float alpha = texture(material.sampler, texCoordsAlpha).x;\n    return vec4(color.rgb, alpha);\n}"},4680:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoFrameTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoFrameTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},533:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},6947:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = exposure * color.rgb;\n    pixelColor = ACESFilm(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},2690:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 postProcess(vec3 pixelColor){\n\n                      \n    pixelColor *= exposure;\n\n                   \n    pixelColor = ACESFilm(pixelColor);\n    pixelColor = LinearToSRGB(pixelColor);\n\n    return pixelColor;\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 aux = postProcess(color.rgb);\n    gl_FragColor = vec4(min(vec3(1.0), aux), color.a);\n}"},4024:e=>{e.exports="uniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = color.rgb;\n    pixelColor = LinearToSRGB(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},5348:e=>{e.exports="vec3 applyFog(vec3 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * fog.color;\n}\n\nvec4 applyFog(vec4 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * vec4(fog.color, 1);\n}"},7885:e=>{e.exports="                                                                                                                        \n  \n          \n                                 \n  \n                                                                                                                        \n\nstruct ExpFog {\n    vec3 color;                             \n    float scattering;                                                    \n};\n"},7333:e=>{e.exports="struct IntersectionShape {\n    float maxCoeff;\n};"},519:e=>{e.exports="struct UnionShape {\n    float minCoeff;\n};\n"},4750:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec3 dir = vec3(coords.xy, -1. / tan(0.5 * camera.fovRadians));\n    Vector v = createVector(ORIGIN, dir);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},8710:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fovRadians;                                          \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},6224:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},6684:e=>{e.exports="   \n                                                                                                 \n                                                                                        \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}\n\n   \n                                                                                             \n                                                               \n   \nRelVector mappingFromFlatScreen(vec2 coords) {\n                                                         \n    vec2 jitter = vec2(randomFloat(), randomFloat()) - 0.5;\n\n                                                                            \n    vec2 planeCoords = (coords - 0.5 * resolution + jitter) / (0.5 * resolution.y);\n\n                              \n    float z = - 1. / tan(radians(0.5 * camera.fov));\n\n                                                      \n    vec4 dir = vec4(planeCoords, z, 0);\n\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},6354:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n    float focalLength;                    \n    float aperture;                \n};"},9222:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}\n\n                     \n\n  \n                               \n                               \n                         \n                                             \n                                                      \n                              \n \n  "},5970:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},5682:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},4770:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}"},8415:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},190:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n\nVector geomMix(Vector v1, Vector v2, float a){\n    return add(multiplyScalar(1.-a, v1), multiplyScalar(a, v2));\n}\n\n   \n                                           \n                         \n             \n   \nVector negate(Vector v) {\n    return multiplyScalar(-1., v);\n}\n\n\n   \n                                         \n                       \n   \nfloat geomLength(Vector v){\n    return sqrt(geomDot(v, v));\n}\n\n   \n                                                          \n                            \n   \nVector geomNormalize(Vector v){\n    float a = geomLength(v);\n    return multiplyScalar(1./a, v);\n}\n\n   \n                                                     \n   \nfloat cosAngle(Vector v1, Vector v2){\n    float a1 = geomLength(v1);\n    float a2 = geomLength(v2);\n    return geomDot(v1, v2)/ (a1 * a2);\n}\n\n   \n                                                           \n                                   \n                                                                                                        \n                                     \n                                                                   \n                                                                       \n   \nVector geomReflect(Vector v, Vector n){\n    return sub(v, multiplyScalar(2. * geomDot(v, n), n));\n}\n\n\n   \n                                         \n                                                                        \n                                                                                   \n                                              \n   \nVector geomRefract(Vector v, Vector n, float r){\n    float cosTheta1 = -geomDot(n, v);\n    float sinTheta2Sq = r * r * (1. - cosTheta1 * cosTheta1);\n\n    if (sinTheta2Sq > 1.){\n               \n        return zeroVector(v.pos);\n    }\n                                                                 \n    float cosTheta2 = sqrt(1. - sinTheta2Sq);\n    float aux = r * cosTheta1 - cosTheta2;\n    return add(multiplyScalar(r, v), multiplyScalar(aux, n));\n}\n\n   \n                                                                          \n                                           \n   \nIsometry makeTranslation(Vector v) {\n    return makeTranslation(v.pos);\n}\n\n   \n                                                                          \n                                              \n   \nIsometry makeInvTranslation(Vector v) {\n    return makeInvTranslation(v.pos);\n}\n"},4168:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                                                                         \n               \n   \nVector createVector(Point p, vec3 coords, Vector[3] frame){\n    Vector c0 = multiplyScalar(coords[0], frame[0]);\n    Vector c1 = multiplyScalar(coords[1], frame[1]);\n    Vector c2 = multiplyScalar(coords[2], frame[2]);\n    return add(c0, add(c1, c2));\n}\n\n\n\n   \n                                                                                          \n               \n   \nVector createVector(Point p, vec3 coords){\n    Vector[3] f;\n    frame(p, f);\n    return createVector(p, coords, f);\n}\n\n   \n                                                                                          \n               \n   \nVector createVectorOrtho(Point p, vec3 coords){\n    Vector[3] f;\n    orthoFrame(p, f);\n    return createVector(p, coords, f);\n}\n\n\n                                                                                                                        \n  \n                   \n                                                             \n                                                                       \n  \n                                                                                                                        \n\nstruct Position {\n    Isometry boost;\n    mat4 facing;\n};\n\n\n   \n                                        \n                          \n                                           \n   \nVector applyPosition(Position p, Vector v){\n    Vector res = applyFacing(p.facing, v);\n    return applyIsometry(p.boost, res);\n}"},2311:e=>{e.exports="   \n              \n                                \n   \nPoint applyIsometry(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\nPoint applyGroupElement(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\n   \n              \n                                \n   \nVector applyIsometry(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\nVector applyGroupElement(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\n\n"},5315:e=>{e.exports="   \n                          \n   \nvarying vec3 screenPosition;\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    RelVector vector = mapping(screenPosition);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = postProcess(getColor(v));\n}"},6159:e=>{e.exports="vec4 postProcess(vec4 color) {\n    return color;\n}"},2977:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n        }\n    }\n\n                               \n                     \n       \n\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + dist;\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    v = flow(v, camera.safetyDist);\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = raymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return v.data.pixel;\n}"},9461:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec4 pixel;                                                                   \n    vec4 leftToComputeColor;                                                                      \n};"},1767:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                             \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n              \n   \nconst float PI = 3.1415926538;\n\n   \n                      \n   \nvec4 debugColor = vec4(0.5, 0, 0.8, 1);\n\n   \n                                    \n         \n   \nconst int HIT_NOTHING = 0;\n   \n                                    \n         \n   \nconst int HIT_SOLID = 1;\n   \n                                  \n         \n   \nconst int HIT_DEBUG = -1;\n"},7962:e=>{e.exports="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"},8187:e=>{e.exports="   \n                          \n   \nvarying vec3 spherePosition;\n\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    initSeed(gl_FragCoord.xy, frameSeed);\n    RelVector vector = mappingFromFlatScreen(gl_FragCoord.xy);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = getColor(v);\n}\n"},9638:e=>{e.exports="   \n                                                \n  \n   \nuint seed;\n\n   \n                                                \n                                                                  \n                                                \n                                                                                                         \n   \nvoid initSeed(vec2 coords, uint frameSeed){\n    uvec2 aux = uvec2(coords);\n    seed =  aux.x * uint(1973) + aux.y * uint(925277) + frameSeed * uint(26699) | uint(1);\n}\n\n   \n                           \n               \n                                                                                                     \n   \nuint wangHash() {\n    seed = (seed ^ uint(61)) ^ (seed >> uint(16));\n    seed = seed * uint(9);\n    seed = seed ^ (seed >> 4);\n    seed = seed * uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n   \n                                                  \n   \nfloat randomFloat() {\n    return float(wangHash()) / 4294967296.;\n}\n\n   \n                                                                           \n                                                                                                    \n                                                                                                       \n                                          \n   \nvec3 randomUnitVec3() {\n    float z = randomFloat() * 2. - 1.;\n    float theta = randomFloat() * 2. * PI;\n    float r = sqrt(1. - z * z);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x, y, z);\n}\n\n   \n                                                   \n                                                      \n   \nVector randomVector(Point p) {\n    vec3 dir = randomUnitVec3();\n    return createVectorOrtho(p, dir);\n}\n\n   \n                                                                     \n                                                                                               \n   \nvec2 randomNormal2D(){\n    float u = randomFloat();\n    float v = randomFloat();\n\n    float r = sqrt(abs(2. * log(u)));\n    float x = r * cos(2. * PI * v);\n    float y = r * sin(2. * PI * v);\n\n    return vec2(x, y);\n\n}\n\n   \n                                                      \n   \nfloat randomNormal(float mean, float stdev){\n\n                           \n    float x = randomNormal2D().x;\n\n                                   \n    return stdev * x + mean;\n}\n"},7920:e=>{e.exports="   \n                                                                                      \n  \n   \n\n\n   \n                                                                                   \n                                                                          \n                                                       \n   \nRelVector randomVector(RelVector v) {\n    v.local = randomVector(v.local.pos);\n    return v;\n}"},3499:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n                                                                  \n                                                                                         \n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + abs(dist);\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nbool doesItScatter(inout float dist, float opticalDepth){\n                          \n    if (opticalDepth>100.){\n        return false;\n    }\n    else {\n        float probScatter=1.-exp(-dist/opticalDepth);\n        float flip=randomFloat();\n        if (flip<probScatter){\n                                           \n                                                \n            dist=dist*randomFloat();\n            return true;\n        }\n                                              \n        return false;\n    }\n}\n\n\nvoid scatterRay(inout ExtVector v){\n                                         \n    RelVector w=randomVector(v.vector);\n\n                                                 \n                                                  \n    v.vector=w;\n                                             \n                                                      \n}\n\n\n\nint scatterRaymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n    float d;\n    bool doScatter;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n\n                                          \n            d=abs(dist);\n            doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                                \n            marchingStep = marchingStep + creepingDist(localV, d, camera.threshold);\n            localV = flow(localV0, marchingStep);\n\n\n                                               \n                                                                              \n\n                                                       \n            if (doScatter){\n                scatterRay(localV);\n            }\n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n\n                                      \n        d=abs(dist);\n        doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                            \n        marchingStep = marchingStep + d;\n        globalV = flow(globalV0, marchingStep);\n\n                                                   \n        if (doScatter){\n            scatterRay(globalV);\n        }\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = scatterRaymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return vec4(v.data.pixel,1);\n}"},3888:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n           \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct RayType{\n    bool diffuse;\n    bool reflect;\n    bool refract;\n    float chance;\n};\n\n                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec3 pixel;         \n    vec3 light;         \n    vec3 currentAbsorb;                                                    \n    vec3 currentEmission;                                                             \n    float currentOpticalDepth;                                                              \n    bool isInside;                                        \n};\n\n"},8351:e=>{e.exports="vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec4 postProcess(vec4 pixelColor) {\n\n                      \n    pixelColor.xyz *= exposure;\n\n                   \n    pixelColor.xyz = ACESFilm(pixelColor.xyz);\n    pixelColor.xyz = LinearToSRGB(pixelColor.xyz);\n\n    return pixelColor;\n}"},7499:e=>{e.exports="                                                                                                                        \n  \n           \n                               \n  \n                                                                                                                        \n \n struct Solid {\n    bool isRendered;\n };\n"},7970:e=>{e.exports="                                                                                                                        \n  \n                      \n                                                        \n                                                                     \n                        \n                                                                                 \n                                                                                 \n                                                                                   \n                                                                                    \n                                                                       \n                                                                                                                        \n\nstruct RelPosition {\n    Position local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n                                                                                                                        \n  \n                    \n                                  \n                                                                       \n                      \n                                                                                 \n                                                                                 \n                                                                            \n                                                                                    \n                                                                                                                        \n\nstruct RelVector {\n    Vector local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n   \n                                                            \n   \nRelVector reduceError(RelVector v){\n    v.local = reduceError(v.local);\n    return v;\n}\n\n   \n                         \n                            \n                                                      \n   \nRelVector add(RelVector v1, RelVector v2){\n    v1.local = add(v1.local, v2.local);\n    return v1;\n}\n\n   \n                              \n                            \n                                                      \n   \nRelVector sub(RelVector v1, RelVector v2){\n    v1.local = sub(v1.local, v2.local);\n    return v1;\n}\n\n   \n                                   \n                         \n                      \n   \nRelVector multiplyScalar(float s, RelVector v){\n    v.local = multiplyScalar(s, v.local);\n    return v;\n}\n\n   \n                                                                                 \n                     \n                                                        \n   \nfloat geomDot(RelVector v1, RelVector v2) {\n    return geomDot(v1.local, v2.local);\n}\n\n   \n                              \n   \nRelVector geomNormalize(RelVector v){\n    v.local = geomNormalize(v.local);\n    return v;\n}\n\n   \n                                   \n                                                        \n   \nRelVector geomMix(RelVector v1, RelVector v2, float a) {\n    v1.local = geomMix(v1.local, v2.local, a);\n    return v1;\n}\n\n   \n                                            \n   \nRelVector negate(RelVector v){\n    v.local = negate(v.local);\n    return v;\n}\n\n   \n                                                                     \n                                                       \n   \nRelVector geomReflect(RelVector v, RelVector normal){\n    v.local = geomReflect(v.local, normal.local);\n    return v;\n}\n\n\n   \n                                                                     \n                                                       \n   \nRelVector geomRefract(RelVector v, RelVector normal, float n){\n    v.local = geomRefract(v.local, normal.local, n);\n    return v;\n}\n\n   \n                         \n                                            \n                                                                         \n   \nRelVector flow(RelVector v, float t) {\n    v.local = flow(v.local, t);\n    return v;\n}\n\n   \n                                                                                          \n                                                                           \n                                                                          \n                               \n                                                                                              \n   \nRelVector smallShift(RelVector v, vec3 dp){\n    v.local = smallShift(v.local, dp);\n    return v;\n                                                 \n                                                               \n}\n\n\n   \n                                                                                                            \n                           \n                                                   \n                                                                                             \n                                            \n   \n                                                   \n                                                   \n               \n                                                             \n                                                                 \n   \n\n   \n                                                                                                            \n                                                   \n                                                                                             \n   \nRelVector createRelVector(RelVector v, vec3 coords){\n    v.local =  createVector(v.local.pos, coords);\n    return v;\n                                                           \n                                                               \n}\n\n   \n                                                                  \n                          \n                                           \n   \nRelVector applyPosition(RelPosition position, Vector v) {\n    Vector local = applyPosition(position.local, v);\n    return RelVector(local, position.cellBoost, position.invCellBoost);\n}\n\n   \n                                                                                                                    \n   \nRelVector rewrite(RelVector v, GroupElement elt, GroupElement inv){\n    v.local = applyGroupElement(elt, v.local);\n                                     \n                                       \n    v.cellBoost = multiply(v.cellBoost, inv);\n    v.invCellBoost = multiply(elt, v.invCellBoost);\n    return v;\n}\n\n\n                                                                                                                        \n  \n                    \n                                    \n                                                                              \n                  \n                                                      \n                                                                                         \n  \n                                                                                                                        \n\nstruct ExtVector {\n    RelVector vector;\n    VectorData data;\n};\n\n\nExtVector flow(ExtVector v, float t) {\n    v.vector = flow(v.vector, t);\n    v.data.lastFlowDist = t;\n    v.data.lastBounceDist = v.data.lastBounceDist + t;\n    v.data.totalDist  = v.data.totalDist + t;\n    return v;\n}\n\n\n\n"},5595:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                    \n  \n                                                                                                                        \n                                                                                                                        \n\n\n                                                                                                                        \n  \n                       \n  \n                                                                                                                        \n\n  \n                                              \n                                                                                                                 \n                                     \n                                                                                        \n                                                \n  \n\n                                                                  \nfloat ell_k;\nfloat ell_kprime;\nfloat ell_m;\nfloat ell_K;\nfloat ell_E;\n\n                                                                                                                 \nfloat ell_mu;\nfloat ell_L;\n\n  \n                                       \n                                                          \n                                                                             \n                                       \n                                                                                 \n                                           \n                                     \n                                          \n                                                                                      \n                                       \n                        \n                                                                      \n                                  \n                           \n         \n                                                                           \n                                                                                       \n                                      \n                                                                                              \n                                                                  \n  \n\n\n                                               \nconst int AGMSteps = 20;\n                                 \nconst float AGMTolerance = 0.000001;\n                                                                       \n                                                                \n                        \n                       \n              \nvec3 AGMList[AGMSteps];\n                                                                                                                       \nint AGMLength;\n\n\n\nvoid agm() {\n                                                                 \n                                     \n                                            \n                                             \n                                        \n\n                     \n                                              \n                                   \n           \n    AGMList[0] = vec3(1., ell_kprime, ell_k);\n\n    AGMLength = 1;\n\n                                         \n    float a0;\n    float g0;\n    float error;\n\n                \n    for (int i = 1; i < AGMSteps; i++) {\n        a0 = AGMList[i - 1].x;\n        g0 = AGMList[i - 1].y;\n        error = 0.5 * (a0 - g0);\n\n        if (error < AGMTolerance) {\n            break;\n        }\n\n        AGMList[i] = vec3(0.5 * (a0 + g0), sqrt(a0 * g0), error);\n        AGMLength = AGMLength + 1;\n    }\n}\n\nvec2 ellipke() {\n                                                                 \n                                                       \n\n                                           \n    float aux = 0.;\n\n                \n    for (int i = 0; i < AGMLength; i++) {\n        aux = aux + pow(2., float(i - 1)) * AGMList[i].z * AGMList[i].z;\n    }\n\n                              \n    float K = 0.5 * PI / AGMList[AGMLength - 1].x;\n    float E = K * (1. - aux);\n    return vec2(K, E);\n}\n\nvec3 ellipj1(float u) {\n                                                                          \n                                            \n                                                           \n                                                                 \n                                            \n\n                                          \n    float a0 = AGMList[AGMLength - 1].x;\n    float g0 = AGMList[AGMLength - 1].y;\n\n    float eps = 1.;\n    if (sin(u * a0) < 0.) {\n        eps = -1.;\n    }\n\n                                                 \n\n    float c = a0 * cos(u * a0) / sin(u * a0);\n    float d = 1.;\n    float aux_c;\n    float aux_d;\n    float num;\n    float den;\n\n    for (int j = 1; j < AGMLength; j++) {\n        aux_c = c * d;\n        num = (c * c / AGMList[AGMLength - j].x + AGMList[AGMLength - 1 - j].y);\n        den = (c * c / AGMList[AGMLength - j].x + AGMList[AGMLength - 1 - j].x);\n        aux_d = num / den;\n        c = aux_c;\n        d = aux_d;\n    }\n\n                           \n    float sn = eps / sqrt(1. + c * c);\n    float cn = c * sn;\n    float dn = d;\n\n    return vec3(sn, cn, dn);\n}\n\n\nvec3 ellipj2(float u) {\n                                                                          \n                                            \n                                                              \n                                            \n\n                                                    \n    float phi0 = pow(2., float(AGMLength - 1)) * AGMList[AGMLength - 1].x * u;\n    float phi1;\n    float aux;\n\n\n    for (int i = 1; i < AGMLength; i++) {\n        aux = AGMList[AGMLength - i].z / AGMList[AGMLength - i].x;\n        phi1 = 0.5 * (phi0 + asin(aux * sin(phi0)));\n        phi0 = phi1;\n    }\n\n    float sn = sin(phi0);\n    float cn = cos(phi0);\n    float dn = sqrt(1. - ell_m * sn * sn);\n    return vec3(sn, cn, dn);\n\n}\n\n\nvec3 ellipj3(float u) {\n                                                                          \n                                                                  \n\n    float emc = 1.0 - ell_m;\n    float a, b, c;\n    const int N = 4;\n    float em[N], en[N];\n    a = 1.0;\n    float dn = 1.0;\n    for (int i = 0; i < N; i++) {\n        em[i] = a;\n        emc = sqrt(emc);\n        en[i] = emc;\n        c = 0.5 * (a + emc);\n        emc = a * emc;\n        a = c;\n    }\n                                          \n                              \n    u = c * u;\n    float sn = sin(u);\n    float cn = cos(u);\n    if (sn != 0.0) {\n        a = cn / sn; c = a * c;\n        for (int i = N - 1; i >= 0; i--) {\n            b = em[i];\n            a = c * a;\n            c = dn * c;\n            dn = (en[i] + a) / (b + a);\n            a = c / b;\n        }\n        a = 1.0 / sqrt(c * c + 1.0);\n        if (sn < 0.0) sn = -a;\n        else sn = a;\n        cn = c * sn;\n    }\n\n    return vec3(sn, cn, dn);\n}\n\n\nvec3 ellipjAtZero(float u) {\n                                                                                       \n                                                       \n\n    float k2 = ell_m;\n    float k4 = ell_m * ell_m;\n    float k6 = k4 * ell_m;\n\n    float u1 = u;\n    float u2 = u1 * u;\n    float u3 = u2 * u;\n    float u4 = u3 * u;\n    float u5 = u4 * u;\n    float u6 = u5 * u;\n    float u7 = u6 * u;\n\n    return vec3(\n        u1\n        - (1. + k2) * u3 / 6.\n        + (1. + 14. * k2 + k4) * u5 / 120.\n        - (1. + 135. * k2 + 135. * k4 + k6) * u7 / 5040.,\n\n        1.\n        - u2 / 2.\n        + (1. + 4. * k2) * u4 / 24.\n        - (1. + 44. * k2 + 16. * k4) * u6 / 720.,\n\n        1.\n        - k2 * u2 / 2.\n        + k2 * (4. + k2) * u4 / 24.\n        - k2 * (16. + 44. * k2 + k4) * u6 / 720.\n    );\n}\n\n\n\nvec3 ellipj(float u) {\n                                                                                                     \n                                                                \n    float tolerance = 0.001;\n\n\n    float u1 = mod(u, 4. * ell_K);\n    float sign = 1.;\n    if (u1 > 2. * ell_K) {\n        u1 = 4. * ell_K - u1;\n        sign = -1.;\n    }\n\n    vec3 aux;\n\n    if (u1 < tolerance) {\n        aux = ellipjAtZero(u1);\n    }\n    else {\n        aux = ellipj3(u1);\n                                                     \n                             \n    }\n\n    return vec3(sign * aux.x, aux.y, aux.z);\n}\n\n\nfloat ellipz(float tanPhi) {\n                                                                                               \n                                                   \n                                                                                                         \n                                   \n                                                              \n                                                                  \n    float tolerance = 0.001;\n\n\n    float sign = 1.;\n    float t0 = tanPhi;\n    if (t0 < 0.) {\n        t0 = -t0;\n        sign = -1.;\n    }\n\n    float res = 0.;\n\n                                                                        \n                               \n    if (t0 < tolerance) {\n        float k2 = ell_m;\n        float k4 = k2 * ell_m;\n        float k6 = k4 * ell_m;\n        res = -(ell_E / ell_K - 1.) * t0;\n        res = res - (1. / 6.) * (ell_E * k2 / ell_K + k2 - 2. * ell_E / ell_K + 2.) * pow(t0, 3.);\n        res = res - (1. / 40.) * (3. * ell_E * k4 / ell_K + k4 - 8. * ell_E * k2 / ell_K - 8. * k2 + 8. * ell_E / ell_K - 8.) * pow(t0, 5.);\n        res = res - (1. / 112.) * (5. * ell_E * k6 / ell_K + k6 - 18. * ell_E * k4 / ell_K - 6. * k4 + 24. * ell_E * k2 / ell_K + 24. * k2 - 16. * ell_E / ell_K + 16.) * pow(t0, 7.);\n    }\n    else {\n                                                       \n\n        float t1;                           \n        float s1;                           \n        float aux;\n\n        for (int i = 0; i < AGMLength; i++) {\n            aux = AGMList[i].y / AGMList[i].x;\n            t1 = t0 * (1. + aux) / (1. - aux * t0 * t0);\n            s1 = t0 * (1. + aux) / sqrt((1. + t0 * t0) * (1. + aux * aux * t0 * t0));\n            res = res + AGMList[i + 1].z * s1;\n\n            t0 = t1;\n        }\n    }\n    return sign * res;\n}\n\n                                                                                                                        \n  \n                   \n                                            \n                            \n             \n                                                                              \n  \n                                                                                                                        \nstruct Isometry {\n    mat4 matrix;\n    bool isInSol;\n};\n\n   \n                    \n   \nconst Isometry IDENTITY = Isometry(mat4(1.), true);                          \n\n   \n                                                              \n                      \n   \nIsometry reduceError(Isometry isom) {\n    return isom;\n}\n\n   \n                                     \n   \nIsometry multiply(Isometry isom1, Isometry isom2) {\n    return Isometry(isom1.matrix * isom2.matrix, isom1.isInSol && isom2.isInSol);\n}\n\n   \n                                            \n   \nIsometry geomInverse(Isometry isom) {\n    mat4 inv = inverse(isom.matrix);\n    return Isometry(inv, isom.isInSol);\n}\n\n                                                                                                                        \n  \n                \n                                        \n  \n                                                                                                                        \nstruct Point {\n    vec4 coords;\n};\n\n\nconst Point ORIGIN = Point(vec4(0, 0, 0, 1));                              \n\n\n   \n                                                           \n   \nPoint reduceError(Point p) {\n    return p;\n}\n\n   \n                                       \n   \nPoint applyIsometry(Isometry isom, Point p) {\n    vec4 coords = isom.matrix * p.coords;\n    return Point(coords);\n}\n\n  \n                                         \n   \nPoint flip(Point p) {\n    return Point(vec4(p.coords.y, p.coords.x, -p.coords.z, 1.));\n}\n\n   \n                                                                     \n                                  \n   \n\nIsometry makeTranslation(Point p) {\n    vec4 c = p.coords;\n    mat4 matrix = mat4(\n        exp(c.z), 0., 0., 0.,\n        0., exp(-c.z), 0., 0.,\n        0., 0., 1., 0,\n        c.x, c.y, c.z, 1.\n    );\n    return Isometry(matrix, true);\n}\n\n   \n                                                                     \n                                     \n   \nIsometry makeInvTranslation(Point p) {\n    vec4 c = p.coords;\n    mat4 matrix = mat4(\n        exp(-c.z), 0., 0., 0.,\n        0., exp(c.z), 0., 0.,\n        0., 0., 1., 0,\n        -exp(-c.z) * c.x, -exp(c.z) * c.y, -c.z, 1.\n    );\n    return Isometry(matrix, true);\n}\n\n                                                                                                                        \n  \n                 \n                                                              \n                                                                                                  \n                       \n                                                                      \n                                                                                                        \n  \n                                                                                                                        \nstruct Vector {\n    Point pos;                     \n    vec4 dir;                            \n};\n\n\n   \n                                \n   \nVector zeroVector(Point pos) {\n    return Vector(pos, vec4(0));\n}\n\n   \n                                                            \n   \nVector reduceError(Vector v) {\n    return v;\n}\n\n   \n                         \n                            \n   \nVector add(Vector v1, Vector v2) {\n    return Vector(v1.pos, v1.dir + v2.dir);\n}\n\n   \n                              \n                            \n   \nVector sub(Vector v1, Vector v2) {\n    return Vector(v1.pos, v1.dir - v2.dir);\n}\n\n   \n                                   \n                         \n                      \n   \nVector multiplyScalar(float s, Vector v) {\n    return Vector(v.pos, s * v.dir);\n}\n\n   \n                                                                                 \n                     \n   \nfloat geomDot(Vector v1, Vector v2) {\n    return dot(v1.dir, v2.dir);\n}\n\n   \n                                        \n   \nVector applyIsometry(Isometry isom, Vector v) {\n    Point pos = applyIsometry(isom, v.pos);\n    if (isom.isInSol) {\n        return Vector(pos, v.dir);\n    } else {\n        Isometry push = makeTranslation(v.pos);\n        Isometry pull = makeInvTranslation(pos);\n        vec4 dir = pull.matrix * isom.matrix * push.matrix * v.dir;\n        return Vector(pos, v.dir);\n    }\n}\n\n  \n                                         \n   \nVector flip(Vector v) {\n    Point pos = flip(v.pos);\n    return Vector(pos, vec4(v.dir.y, v.dir.x, -v.dir.z, 0.));\n}\n\n   \n                                                                         \n                                                                                                           \n                                           \n   \nVector applyFacing(mat4 m, Vector v) {\n    return Vector(v.pos, m * v.dir);\n}\n\nvoid initFlow(Vector v) {\n                                                                                      \n                                                     \n                                                                        \n                                             \n                                                                                        \n                                                              \n\n                                             \n                                        \n    float ab = abs(v.dir.x * v.dir.y);\n\n                                                                      \n    float aux1 = sqrt(1. - 2. * ab);\n    float aux2 = 2. * sqrt(ab);\n\n                \n    ell_mu = sqrt(1. + 2. * ab);\n\n                                           \n    ell_k = aux1 / ell_mu;\n    ell_kprime = aux2 / ell_mu;\n    ell_m = (1. - 2. * ab) / (1. + 2. * ab);\n\n                                                         \n    agm();\n    vec2 KE = ellipke();\n    ell_K = KE.x;\n    ell_E = KE.y;\n\n                                                                                                             \n    if (ab != 0.) {\n        ell_L = ell_E / (ell_kprime * ell_K) - 0.5 * ell_kprime;\n    }\n}\n"},9395:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                    \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                               \n                                                                       \n                                     \n                                                      \n   \nvoid frame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec4(1, 0, 0, 0));\n    f[1] = Vector(p, vec4(0, 1, 0, 0));\n    f[2] = Vector(p, vec4(0, 0, 1, 0));\n}\n\n   \n                                           \n                                                                       \n                                     \n                                                      \n   \nvoid orthoFrame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec4(1, 0, 0, 0));\n    f[1] = Vector(p, vec4(0, 1, 0, 0));\n    f[2] = Vector(p, vec4(0, 0, 1, 0));\n}\n\n   \n                                                                                         \n                              \n                                                                                              \n   \nPoint smallShift(Point p, vec3 dp){\n    Point aux = Point(vec4(dp, 1));\n    Isometry isom = makeTranslation(p);\n    return applyIsometry(isom, aux);\n}\n\nVector smallShift(Vector v, vec3 dp){\n    Point pos = smallShift(v.pos, dp);\n    return Vector(pos, v.dir);\n}\n\n   \n                                 \n               \n                                                   \n   \nVector numFlow(Vector v, float t){\n    float NUM_STEP = 0.0002;\n    Isometry shift = makeTranslation(v.pos);\n\n    Vector aux = Vector(ORIGIN, v.dir);\n    vec4 field_p;\n    vec4 field_u;\n    int n = int(floor(t/NUM_STEP));\n    for (int i=0; i<n; i++){\n        field_p = vec4(\n        exp(aux.pos.coords.z) * aux.dir.x,\n        exp(-aux.pos.coords.z) * aux.dir.y,\n        aux.dir.z,\n        0.\n        );\n        field_u = vec4(\n        aux.dir.x * aux.dir.z,\n        -aux.dir.y * aux.dir.z,\n        - aux.dir.x *  aux.dir.x + aux.dir.y * aux.dir.y,\n        0\n        );\n        aux.pos.coords = aux.pos.coords + NUM_STEP * field_p;\n        aux.dir = aux.dir + NUM_STEP * field_u;\n        aux = geomNormalize(aux);\n    }\n    return applyIsometry(shift, aux);\n}\n\nVector hypXFlow(Vector v, float t){\n                                                                  \n                                                          \n                                                        \n                                                            \n    \n                                                        \n    Isometry shift = makeTranslation(v.pos);\n                             \n    Vector resOrigin;\n\n                                                                              \n    float a = v.dir.x;\n    float b = v.dir.y;\n    float c = v.dir.z;\n\n                                                                      \n                                      \n                                                                  \n    float b2 = b * b;\n    float c2 = c * c;\n                                                                                          \n    float n1 = sqrt(b2 + c2);\n    float n2 = n1 * n1;\n    float n3 = n1 * n2;\n    float n4 = n1 * n3;\n                \n    float sign = 1.;\n    if (b < 0.) {\n        sign = -1.;\n    }\n                                                      \n    float shs = (c * cosh(n1 * t) + n1 * sinh(n1 * t)) / abs(b);\n    float chs = (n1 * cosh(n1 * t) + c * sinh(n1 * t)) / abs(b);\n    float ths = shs / chs;\n\n\n    vec4 u0 = vec4(\n    0.,\n    sign * n1 / chs,\n    n1 * ths,\n    0.\n    );\n\n    vec4 u1 = vec4(\n    abs(b) * chs / n1,\n    0.,\n    0.,\n    0.\n    );\n\n    vec4 u2 = vec4(\n    0.,\n    sign * b2 * chs / (4. * n3)\n    + sign * (b2 - 2. * c2)  * (n1 * t * shs / pow(chs, 2.) - 1. / chs) / (4. * n3)\n    - 3. * sign * c * shs / (4. * n2 * pow(chs, 2.)),\n    - b2 * shs * chs / (2. * n3)\n    - (b2 - 2. * c2) * (ths - n1 * t / pow(chs, 2.)) / (4. * n3)\n    + 3. * c / (4. * n2 * pow(chs, 2.)),\n    0.\n    );\n\n    resOrigin.dir = u0  + a * u1 + a * a * u2;\n\n\n    vec4 p0 = vec4(\n    0.,\n    n1 * ths / b - c / b,\n    log(abs(b) * chs / n1),\n    1.\n    );\n\n    vec4 p1 = vec4(\n    b2 * (shs * chs + n1 * t) / (2. * n3) - c / (2. * n2),\n    0.,\n    0.,\n    0.\n    );\n\n    vec4 p2 = vec4(\n    0.,\n    b * n1 * t / (2. * n3)\n    - (b2 - 2. * c2) * ( n1 * t / pow(chs, 2.) + ths) / (4. * b * n3)\n    + 3. * c / (4. * b * n2 * pow(chs, 2.))\n    - c / (2. * b * n2),\n    - b2 * pow(chs, 2.) / (4. * n4)\n    - (b2 - 2. * c2) * (n1 * t * ths - 1.) / (4. * n4)\n    + 3. * c * ths / (4. * n3),\n    0.\n    );\n\n    resOrigin.pos.coords = p0 + a * p1 + a * a * p2;\n    \n    resOrigin = geomNormalize(resOrigin);\n    return applyIsometry(shift, resOrigin);\n}\n\nVector hypYFlow(Vector v, float t) {\n                                                                  \n                                                      \n    Vector res = flip(v);\n    res = hypXFlow(res, t);\n    res = flip(res);\n    return res;\n}\n\n\nVector ellFlow(Vector v, float t){\n                                               \n                   \n\n                                                        \n    Isometry shift = makeTranslation(v.pos);\n\n                             \n    Vector resOrigin;\n\n                                                                              \n    float a = v.dir.x;\n    float b = v.dir.y;\n    float c = v.dir.z;\n    \n                                                                          \n                                                                                                       \n                                                                                                                    \n                                                                              \n\n                                                       \n\n                        \n                                                                                               \n                                            \n       \n            \n\n                                                                           \n\n                                                     \n        float aux = sqrt(1. - 2. * abs(a * b));\n                                                                                         \n        vec3 jacobi_s0 = vec3(\n        - c / aux,\n        (abs(a) - abs(b)) / aux,\n        (abs(a) + abs(b)) / ell_mu\n        );\n\n\n                              \n        float signa = 1.;\n        if (a < 0.) {\n            signa = -1.;\n        }\n        float signb = 1.;\n        if (b < 0.) {\n            signb = -1.;\n        }\n\n                                               \n        float kOkprime = ell_k / ell_kprime;\n        float oneOkprime = 1. / ell_kprime;\n\n                                                                         \n\n                                                    \n                                                                                                        \n        float s = mod(ell_mu * t, 4. * ell_K);\n                                                      \n        vec3 jacobi_s = ellipj(s);\n\n                                                                                     \n        float den = 1. - ell_m * jacobi_s.x * jacobi_s.x * jacobi_s0.x * jacobi_s0.x;\n        vec3 jacobi_ss0 = vec3(\n        (jacobi_s.x * jacobi_s0.y * jacobi_s0.z + jacobi_s0.x * jacobi_s.y * jacobi_s.z) / den,\n        (jacobi_s.y * jacobi_s0.y - jacobi_s.x * jacobi_s.z * jacobi_s0.x * jacobi_s0.z) / den,\n        (jacobi_s.z * jacobi_s0.z - ell_m * jacobi_s.x * jacobi_s.y * jacobi_s0.x * jacobi_s0.y) / den\n        );\n\n                                                                 \n        float zetaj = ellipz(jacobi_s.x / jacobi_s.y) - ell_m * jacobi_s.x * jacobi_s0.x * jacobi_ss0.x;\n\n\n                                       \n        resOrigin.pos.coords = vec4(\n\n        signa * sqrt(abs(b / a)) * (\n        oneOkprime * zetaj\n        + kOkprime * (jacobi_ss0.x - jacobi_s0.x)\n        + ell_L * ell_mu * t\n        ),\n        signb * sqrt(abs(a / b)) * (\n        oneOkprime * zetaj\n        - kOkprime * (jacobi_ss0.x - jacobi_s0.x)\n        + ell_L * ell_mu * t\n        ),\n        0.5 * log(abs(b / a)) + asinh(kOkprime * jacobi_ss0.y),\n        1.\n        );\n\n        resOrigin.dir = vec4(\n        a * sqrt(abs(b/a)) * (kOkprime * jacobi_ss0.y + oneOkprime * jacobi_ss0.z),\n        - b * sqrt(abs(a/b)) * (kOkprime * jacobi_ss0.y - oneOkprime * jacobi_ss0.z),\n        - ell_k * ell_mu * jacobi_ss0.x,\n        0.\n        );\n       \n\n    resOrigin = geomNormalize(resOrigin);\n    return applyIsometry(shift, resOrigin);\n}\n\n\n   \n                                  \n                                                 \n   \nVector flow(Vector v, float t){\n    float tolerance = 0.0001;\n\n    if (abs(t) < 0.002) {\n        return numFlow(v, t);\n                                \n    }\n    else {\n        if (abs(v.dir.x * t) < tolerance) {\n                                  \n            return hypXFlow(v, t);\n        }\n        else if (abs(v.dir.y * t) < tolerance) {\n                                       \n            return hypYFlow(v, t);\n        }\n        else {\n            return ellFlow(v, t);\n                                   \n        }\n    }\n}\n"},1360:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\nconst float PHI = 0.5 * (1. + sqrt(5.));\nconst float DENUM = 1. / (PHI + 2.);\n\n                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct GroupElement {\n    vec2 coords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(vec2(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    vec2 coords = elt1.coords + elt2.coords;\n    return GroupElement(coords);\n}\n\nIsometry toIsometry(GroupElement elt) {\n    float a = elt.coords.x;\n    float b = elt.coords.y;\n    vec4 coords = vec4((a * PHI + b) * DENUM, (-a + b * PHI) * DENUM, 0, 1);\n    return makeTranslation(Point(coords));\n}"},7802:e=>{e.exports="struct GroupElement {\n    vec3 coords;                                           \n    mat3 matrix;                                                 \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(vec3(0), mat3(1));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    vec3 coords = elt1.coords + elt1.matrix * elt2.coords;\n    mat3 matrix = elt1.matrix * elt2.matrix;\n    return GroupElement(coords, matrix);\n}\n\nIsometry toIsometry(GroupElement elt) {\n    float a = elt.coords.x;\n    float b = elt.coords.y;\n    float c = elt.coords.z;\n    vec4 coords = vec4(\n    (a * PHI + b) * group.length * DENUM,\n    (-a + b * PHI) * group.length * DENUM,\n    c * TAU,\n    1\n    );\n    return makeTranslation(Point(coords));\n}"},607:e=>{e.exports="const float PHI = 0.5 * (1. + sqrt(5.));\nconst float DENUM = 1. / (PHI + 2.);\nconst float TAU = 2. * log(PHI);\n\nstruct Group {\n    float length;\n};"},9136:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n\n                                                                                                                        \n          \n                                                    \n                                                                                                                        \n\nstruct GroupElement {\n    vec2 coords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(vec2(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    vec2 coords = elt1.coords + elt2.coords;\n    return GroupElement(coords);\n}\n\nIsometry toIsometry(GroupElement elt) {\n    float a = elt.coords.x;\n    float b = elt.coords.y;\n    vec4 coords = a * group.dirA + b * group.dirB;\n    return makeTranslation(Point(coords));\n}"},5846:e=>{e.exports="                                                                                                                        \n          \n                                      \n                                                                                                                        \n\nstruct Group {\n    vec4 dirA;\n    vec4 dirB;\n    mat4 dotMatrix;\n};"},3573:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct ConstDirLight {\n    int id;\n    vec3 color;\n    float intensity;\n    vec3 direction;\n    int maxDirs;\n};\n\nbool directions(ConstDirLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    intensity = light.intensity;\n                                                             \n                                                                        \n    vec4 coords = vec4(light.direction, 0.);\n    Vector local = Vector(v.local.pos, coords);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},3019:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct LocalFakePointLight {\n    int id;\n    vec3 color;\n    float intensity;\n    Point position;\n    int maxDirs;\n};\n\nbool directions(LocalFakePointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    float fakeDistance = length(light.position.coords - v.local.pos.coords);\n    intensity = (1. / fakeDistance) * light.intensity;\n\n    Isometry pull = makeInvTranslation(v.local.pos);\n    vec4 aux = light.position.coords - v.local.pos.coords;\n    aux = pull.matrix * aux;\n    Vector local = Vector(v.local.pos, aux);\n    local = geomNormalize(local);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},6010:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct ZSun {\n    int id;\n    vec3 color;\n    float intensity;\n    float direction;\n    int maxDirs;\n};\n\nbool directions(ZSun light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    intensity = light.intensity;\n    Vector local=Vector(v.local.pos, vec4(0, 0, light.direction, 0));\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},5238:e=>{e.exports="                                                                                                                        \n                       \n                                                                                                                        \n\nstruct MultiColorMaterial {\n    vec3 mainColor;\n    vec3 accent1;\n    vec3 accent2;\n    vec3 accent3;\n    bool grid;\n};\n\nvec4 render(MultiColorMaterial material, ExtVector v) {\n\n    vec3 dir = normalize(v.vector.local.pos.coords.xyw);\n    vec3 color = material.mainColor;\n    color += material.accent1 * dir.x;\n    color += material.accent2 * dir.y;\n    color += material.accent3 * dir.z;\n\n    float rDist = length(v.vector.local.pos.coords.xy);\n    float theta = atan(dir.y,dir.x);\n    float height = v.vector.local.pos.coords.z;\n\n    if(material.grid){\n        float test = sin(70.*rDist)*sin(70.*theta)*sin(70.*height);\n        float sgn = sign(test);\n        if (sgn<0.){\n            color *=0.9;\n        }\n    }\n\n    return vec4(color, 1);\n}"},1228:e=>{e.exports="                                                                                                                        \n          \n                                     \n                                                                                                                        \nstruct NaryMaterial {\n    float t;\n    int n;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(NaryMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float nfloat = float(material.n);\n    float logn = log(nfloat);\n\n    float scaledY = uv.y / logn;\n    float k = round(scaledY);\n    float c1 = 2. * abs(scaledY - k);\n\n    float scaledX = uv.x / (pow(nfloat, -k) * material.t);\n    float aux = floor(scaledX);\n    float c2 = abs(2. * (scaledX - aux) - 1.);\n\n    if (c1 < material.lengths.x && c2 < material.lengths.x){\n        color = material.color0;\n    } else if (c1 < material.lengths.y && c2 < material.lengths.y){\n        color = material.color1;\n    } else if (c1 < material.lengths.z && c2 < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n    return vec4(color, 1);\n}\n\n"},8803:e=>{e.exports="                                                                                                                        \n          \n                                     \n                                                                                                                        \nstruct NaryMaterialEquidistant {\n    float t;\n    int n;\n    vec4 heights;\n    vec3 widths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(NaryMaterialEquidistant material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float nfloat = float(material.n);\n    float logn = log(nfloat);\n\n    float scaledY = uv.y / logn;\n    float k = round(scaledY);\n    float y = 2. * (scaledY - k);\n    float testY = abs(y);\n\n    float scaledX = uv.x / (pow(nfloat, -k) * material.t);\n    float aux = floor(scaledX);\n    float x = 2. * (scaledX - aux) - 1.;\n    float testX = -y - 2. * log(1. - abs(x)) / logn;\n\n    if (testY < material.heights.x && testX < material.widths.x){\n        color = material.color0;\n    } else if (testY < material.heights.y && testX < material.widths.y){\n        color = material.color1;\n    } else if (testY < material.heights.z && testX < material.widths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}\n\n"},3275:e=>{e.exports="                                                                                                                        \n                         \n                                                                                                                        \n\nstruct VaryingColorMaterial {\n    vec3 mainColor;\n    vec3 weight;\n};\n\nvec4 render(VaryingColorMaterial material, ExtVector v) {\n    vec3 color = material.mainColor + material.weight * v.vector.local.pos.coords.xyz;\n    return vec4(color, 1);\n}"},2361:e=>{e.exports="                                                                                                                        \n          \n                   \n                                                                                                                        \n\nstruct FakeBallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                                \n   \nfloat sdf(FakeBallShape ball, RelVector v) {\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    vec4 diff = v.local.pos.coords - center.coords;\n    return length(diff) - ball.radius;\n}\n\n   \n                                             \n   \nRelVector gradient(FakeBallShape ball, RelVector v){\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    Vector local = Vector(v.local.pos, v.local.pos.coords - center.coords);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\n"},9277:e=>{e.exports="                                                                                                                        \n          \n                    \n                                                                                                                        \n\nstruct LocalCube {\n    int id;\n    vec4 testX;\n    vec4 testY;\n    vec4 testZ;\n    float smoothness;\n    vec3 sides;\n};\n\n   \n                                            \n   \nfloat sdf(LocalCube cube, RelVector v) {\n    float dotX = dot(v.local.pos.coords, cube.testX);\n    float dotY = dot(v.local.pos.coords, cube.testY);\n    float dotZ = dot(v.local.pos.coords, cube.testZ);\n\n    float distX = asinh((abs(dotX) - 0.5 * cube.sides.x) * exp(-dotZ));\n    float distY = asinh((abs(dotY) - 0.5 * cube.sides.y) * exp(dotZ));\n    float distZ = abs(dotZ) - 0.5 * cube.sides.z;\n\n    float aux = smoothMaxPoly(distX, distY, cube.smoothness);\n    return smoothMaxPoly(aux, distZ, cube.smoothness);\n}\n\n   \n                                         \n   \nRelVector gradient(LocalCube cube, RelVector v){\n    float dotX = dot(v.local.pos.coords, cube.testX);\n    float dotY = dot(v.local.pos.coords, cube.testY);\n    float dotZ = dot(v.local.pos.coords, cube.testZ);\n\n    float auxX = abs(dotX) - 0.5 * cube.sides.x;\n    float auxY = abs(dotY) - 0.5 * cube.sides.y;\n    float auxZX = exp(-dotZ);\n    float auxZY = exp(dotZ);\n    float distX = asinh(auxX * auxZX);\n    float distY = asinh(auxY * auxZY);\n    float distZ = abs(dotZ) - 0.5 * cube.sides.z;\n\n    float den;\n    vec4 dir;\n\n    den = sqrt(auxX * auxX + auxZX * auxZX + 1.);\n    dir = (auxZX / den) * (-auxX * cube.testZ + sign(auxX) * cube.testX);\n    dir.w = 0.;\n    RelVector gradX = RelVector(Vector(v.local.pos, dir), v.cellBoost, v.invCellBoost);\n\n    den = sqrt(auxY * auxY + auxZY * auxZY + 1.);\n    dir = (auxZY / den) * (auxY * cube.testZ + sign(auxY) * cube.testY);\n    dir.w = 0.;\n    RelVector gradY = RelVector(Vector(v.local.pos, dir), v.cellBoost, v.invCellBoost);\n\n    dir = sign(dotZ) * cube.testZ;\n    dir.w = 0.;\n    RelVector gradZ = RelVector(Vector(v.local.pos, dir), v.cellBoost, v.invCellBoost);\n\n    float distAux = smoothMaxPoly(distX, distY, cube.smoothness);\n    RelVector gradAux = gradientMaxPoly(distX, distY, gradX, gradY, cube.smoothness);\n\n    return gradientMaxPoly(distAux, distZ, gradAux, gradZ, cube.smoothness);\n}\n\n"},6290:e=>{e.exports="                                                                                                                        \n          \n                   \n                                                                                                                        \n\nstruct LocalFakeBallShape {\n    int id;\n    Point center;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                                \n   \nfloat sdf(LocalFakeBallShape ball, RelVector v) {\n    vec4 diff = v.local.pos.coords - ball.center.coords;\n    return length(diff) - ball.radius;\n}\n\n   \n                                             \n   \nRelVector gradient(LocalFakeBallShape ball, RelVector v){\n    Vector local = Vector(v.local.pos, v.local.pos.coords - ball.center.coords);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalFakeBallShape ball, RelVector v){\n    vec4 dir = v.local.pos.coords - ball.center.coords;\n    dir.w = 0.;\n    dir = ball.absoluteIsomInv.matrix * dir;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n\n"},4090:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct LocalXAxisShape {\n    int id;\n    Isometry absoluteIsom;\n    Isometry absoluteIsomInv;\n    float radius;\n};\n\n   \n                                              \n   \nfloat sdf(LocalXAxisShape a, RelVector v) {\n    Point aux = applyIsometry(a.absoluteIsomInv, v.local.pos);\n    float y = aux.coords.y;\n    float z = aux.coords.z;\n    return acosh(cosh(z) + 0.5 * exp(z) * y * y) - a.radius;\n}\n\n   \n                                     \n   \nRelVector gradient(LocalXAxisShape a, RelVector v){\n    Point aux = applyIsometry(a.absoluteIsomInv, v.local.pos);\n    float y = aux.coords.y;\n    float z = aux.coords.z;\n\n    vec4 dir = vec4(0, y * exp(-z), y * y * exp(z) + 2. * sinh(z), 0);\n    dir = a.absoluteIsom.matrix * dir;\n    Isometry pull = makeInvTranslation(v.local.pos);\n    dir = pull.matrix * dir;\n    dir = normalize(dir);\n\n    return RelVector(Vector(v.local.pos, dir), v.cellBoost, v.invCellBoost);\n}\n\n   \n                                   \n   \nvec2 uvMap(LocalXAxisShape a, RelVector v){\n    Point aux = applyIsometry(a.absoluteIsomInv, v.local.pos);\n    float x = aux.coords.x;\n    float y = aux.coords.y;\n    float z = aux.coords.z;\n\n    float uCoords = atan(y, z);\n    float vCoords = x;\n    return vec2(uCoords, vCoords);\n}"},1273:e=>{e.exports="                                                                                                                        \n          \n                       \n                                                                                                                        \n\nstruct LocalXHalfSpaceShape {\n    vec4 testX;                                                                 \n    vec4 testZ;                                                                 \n    Point origin;\n    vec3 uDir;                                       \n    vec3 vDir;                                       \n};\n\n                                                                                                            \nfloat sdf(LocalXHalfSpaceShape halfspace, RelVector v){\n    float dotX = dot(v.local.pos.coords, halfspace.testX);\n    float dotZ = dot(v.local.pos.coords, halfspace.testZ);\n    return asinh(dotX * exp(-dotZ));\n}\n\nRelVector gradient(LocalXHalfSpaceShape halfspace, RelVector v){\n    float dotX = dot(v.local.pos.coords, halfspace.testX);\n    float dotZ = dot(v.local.pos.coords, halfspace.testZ);\n    float eDotZ = exp(-dotZ);\n    float coeff = 1. / sqrt(dotX * dotX * eDotZ * eDotZ + 1.);\n    vec4 dir = coeff * eDotZ * (halfspace.testX - dotX * halfspace.testZ);\n                                              \n                        \n    dir.w = 0.;\n    Isometry isom = makeInvTranslation(v.local.pos);\n    dir = isom.matrix * dir;\n    Vector n = Vector(v.local.pos, dir);\n    n = geomNormalize(n);\n    return RelVector(n, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalXHalfSpaceShape halfspace, RelVector v){\n                                                                      \n                                                 \n                                                        \n                                                        \n    float uCoord = dot(v.local.pos.coords - halfspace.origin.coords, vec4(halfspace.uDir, 0));\n    float vCoord = dot(v.local.pos.coords - halfspace.origin.coords, vec4(halfspace.vDir, 0));\n    return vec2(uCoord, vCoord);\n}\n\n"},6316:e=>{e.exports="                                                                                                                        \n          \n                   \n                                                                                                                        \n\nstruct LocalZAxisShape {\n    int id;\n    Isometry absoluteIsom;\n    Isometry absoluteIsomInv;\n    float smoothness;\n    vec2 sides;\n};\n\n   \n                                              \n   \nfloat sdf(LocalZAxisShape a, RelVector v) {\n    Point aux = applyIsometry(a.absoluteIsomInv, v.local.pos);\n    float x = aux.coords.x;\n    float y = aux.coords.y;\n    float z = aux.coords.z;\n\n    float distX = asinh((abs(x) - 0.5 * a.sides.x) * exp(-z));\n    float distY = asinh((abs(y) - 0.5 * a.sides.y) * exp(z));\n    return smoothMaxPoly(distX, distY, a.smoothness);\n}\n\n   \n                                           \n   \nRelVector gradient(LocalZAxisShape a, RelVector v){\n    Point aux = applyIsometry(a.absoluteIsomInv, v.local.pos);\n    float x = aux.coords.x;\n    float y = aux.coords.y;\n    float z = aux.coords.z;\n\n    float auxX = abs(x) - 0.5 * a.sides.x;\n    float auxY = abs(y) - 0.5 * a.sides.y;\n    float eZN = exp(-z);\n    float ezP = exp(z);\n    float distX = asinh(auxX * eZN);\n    float distY = asinh(auxY * ezP);\n\n    Isometry pull = makeInvTranslation(v.local.pos);\n\n    vec4 dirX = sign(x) * vec4(ezP * ezP, 0, -x, 0);\n    dirX = a.absoluteIsom.matrix * dirX;\n    dirX = pull.matrix * dirX;\n    dirX = normalize(dirX);\n    RelVector gradX = RelVector(Vector(v.local.pos, dirX), v.cellBoost, v.invCellBoost);\n\n    vec4 dirY = sign(y) * vec4(0, eZN * eZN, -y, 0);\n    dirY = a.absoluteIsom.matrix * dirY;\n    dirY = pull.matrix * dirY;\n    dirY = normalize(dirY);\n    RelVector gradY = RelVector(Vector(v.local.pos, dirY), v.cellBoost, v.invCellBoost);\n\n    return gradientMaxPoly(distX, distY, gradX, gradY, a.smoothness);\n}\n\n  \n                         \n                                             \n   \nvec2 uvMap(LocalZAxisShape a, RelVector v){\n    Point aux = applyIsometry(a.absoluteIsomInv, v.local.pos);\n    float x = aux.coords.x;\n    float y = aux.coords.y;\n    float z = aux.coords.z;\n\n    float uCoords = atan(y, x);\n    float vCoords = z;\n    return vec2(uCoords, vCoords);\n}"},9583:e=>{e.exports="                                                                                                                        \n          \n                       \n                                                                                                                        \n\nstruct LocalZHalfSpaceShape {\n    vec4 test;                                                      \n    Point origin;                                                 \n    vec3 uDir;                                       \n    vec3 vDir;                                       \n};\n\n                                                                                                            \nfloat sdf(LocalZHalfSpaceShape halfspace, RelVector v){\n    return dot(v.local.pos.coords, halfspace.test);\n}\n\nRelVector gradient(LocalZHalfSpaceShape halfspace, RelVector v){\n                                                                     \n    vec4 dir = halfspace.test * vec4(0, 0, 1, 0);\n    Vector local = Vector(v.local.pos, dir);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalZHalfSpaceShape halfspace, RelVector v){\n                                                                      \n                                                 \n                                                        \n                                                        \n    float uCoord = dot(v.local.pos.coords - halfspace.origin.coords, vec4(halfspace.uDir, 0));\n    float vCoord = dot(v.local.pos.coords - halfspace.origin.coords, vec4(halfspace.vDir, 0));\n    return vec2(uCoord, vCoord);\n}\n\n"},5201:e=>{e.exports="                                                                                                                        \n          \n                                                        \n                                                                                                                        \n\nstruct LocalZSlabShape {\n    vec4 test;                                                      \n    Point origin;                                                 \n    vec3 uDir;                                       \n    vec3 vDir;                                       \n    float thickness;\n};\n\n                                                                                                            \nfloat sdf(LocalZSlabShape slab, RelVector v){\n    return abs(dot(v.local.pos.coords, slab.test)) - slab.thickness;\n                                                                                           \n}\n\nRelVector gradient(LocalZSlabShape slab, RelVector v){\n                                                                     \n    vec4 dir = sign(dot(v.local.pos.coords, slab.test)) * slab.test * vec4(0, 0, 1, 0);\n                                                                                                             \n    Vector local = Vector(v.local.pos, dir);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalZSlabShape slab, RelVector v){\n                                                                      \n                                                 \n                                                        \n                                                        \n    float uCoord = dot(v.local.pos.coords - slab.origin.coords, vec4(slab.uDir, 0));\n    float vCoord = dot(v.local.pos.coords - slab.origin.coords, vec4(slab.vDir, 0));\n    return vec2(uCoord, vCoord);\n}\n\n"},3980:e=>{e.exports="                                                                                                                        \n          \n                       \n                                                                                                                        \n\nstruct XHalfSpaceShape {\n    vec4 testX;                                                                 \n    vec4 testZ;                                                                 \n    Point origin;\n    vec3 uDir;                                       \n    vec3 vDir;                                       \n};\n\n                                                                                                            \nfloat sdf(XHalfSpaceShape halfspace, RelVector v){\n    Isometry aux = toIsometry(v.cellBoost);\n    vec4 testX = transpose(aux.matrix) * halfspace.testX;\n    vec4 testZ = transpose(aux.matrix) * halfspace.testZ;\n    float dotX = dot(v.local.pos.coords, testX);\n    float dotZ = dot(v.local.pos.coords, testZ);\n    return asinh(dotX * exp(-dotZ));\n}\n\nRelVector gradient(XHalfSpaceShape halfspace, RelVector v){\n    Isometry aux = toIsometry(v.cellBoost);\n    vec4 testX = transpose(aux.matrix) * halfspace.testX;\n    vec4 testZ = transpose(aux.matrix) * halfspace.testZ;\n    float dotX = dot(v.local.pos.coords, testX);\n    float dotZ = dot(v.local.pos.coords, testZ);\n    float eDotZ = exp(-dotZ);\n    float coeff = 1. / sqrt(dotX * dotX * eDotZ * eDotZ + 1.);\n    vec4 dir = coeff * eDotZ * (testX - dotX * testZ);\n                                              \n                        \n    dir.w = 0.;\n    Isometry isom = makeInvTranslation(v.local.pos);\n    dir = isom.matrix * dir;\n    Vector n = Vector(v.local.pos, dir);\n    n = geomNormalize(n);\n    return RelVector(n, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(XHalfSpaceShape halfspace, RelVector v){\n    Point pos = applyGroupElement(v.invCellBoost, halfspace.origin);\n    Isometry isom = toIsometry(v.invCellBoost);\n    vec4 uDir = isom.matrix * vec4(halfspace.uDir, 0);\n    vec4 vDir = isom.matrix * vec4(halfspace.vDir, 0);\n    float uCoord = dot(v.local.pos.coords - pos.coords, uDir);\n    float vCoord = dot(v.local.pos.coords - pos.coords, vDir);\n    return vec2(uCoord, vCoord);\n}\n\n"},5239:e=>{e.exports="                                                                                                                        \n          \n                       \n                                                                                                                        \n\nstruct ZHalfSpaceShape {\n    vec4 test;                                                      \n    Point origin;                                                 \n    vec3 uDir;                                       \n    vec3 vDir;                                       \n};\n\n                                                                                                            \nfloat sdf(ZHalfSpaceShape halfspace, RelVector v){\n    Isometry aux = toIsometry(v.cellBoost);\n    vec4 test = transpose(aux.matrix) * halfspace.test;\n    return dot(v.local.pos.coords, test);\n}\n\nRelVector gradient(ZHalfSpaceShape halfspace, RelVector v){\n                                                                     \n    vec4 dir = halfspace.test * vec4(0, 0, 1, 0);\n    Vector local = Vector(v.local.pos, dir);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(ZHalfSpaceShape halfspace, RelVector v){\n    Point pos = applyGroupElement(v.invCellBoost, halfspace.origin);\n    Isometry isom = toIsometry(v.invCellBoost);\n    vec4 uDir = isom.matrix * vec4(halfspace.uDir, 0);\n    vec4 vDir = isom.matrix * vec4(halfspace.vDir, 0);\n    float uCoord = dot(v.local.pos.coords - pos.coords, uDir);\n    float vCoord = dot(v.local.pos.coords - pos.coords, vDir);\n    return vec2(uCoord, vCoord);\n}\n\n"},5688:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                            \n  \n                                                                                                                        \n                                                                                                                        \n\n\n"}},n={};function r(e){var a=n[e];if(void 0!==a)return a.exports;var o=n[e]={exports:{}};return t[e](o,o.exports,r),o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})();var a={};(()=>{r.d(a,{T0:()=>Yo,FJ:()=>Wo,GU:()=>Mt,XH:()=>we,ZH:()=>Gt,K9:()=>O,FT:()=>Vt,cK:()=>bt,_x:()=>pt,kj:()=>mt,V1:()=>Ce,Vz:()=>sn,ck:()=>Q,Iy:()=>Oa,Vf:()=>Ni,TB:()=>bn,Al:()=>jo,ix:()=>ur,jZ:()=>lr,c$:()=>Ot,OZ:()=>Gl,Ao:()=>ol,Qj:()=>qe,mD:()=>Lo,yb:()=>Tt,iJ:()=>dn,ZA:()=>Qe,Jz:()=>Se,fR:()=>$r,kK:()=>Ar,ZX:()=>or,_f:()=>mr,Ht:()=>fr,HZ:()=>No,TN:()=>io,JV:()=>n,Sc:()=>Go,Nh:()=>Fo,RL:()=>Me,_k:()=>_t,uR:()=>Oo,gU:()=>$o,EB:()=>Ol,Zs:()=>Sl,oR:()=>Fl,lt:()=>dl,_r:()=>Ai,vh:()=>Wl,NM:()=>El,EA:()=>Hl,Bm:()=>Ml,b_:()=>ql,YE:()=>Dl,Qc:()=>jl,Q9:()=>xl,oE:()=>Zl,_V:()=>Ul,F5:()=>wt,Uc:()=>as,Fh:()=>Ho,O5:()=>$i,Pe:()=>Yi,Wp:()=>Wi,oB:()=>Kt,pJ:()=>St,GW:()=>Ke,DZ:()=>fe,_K:()=>La,JF:()=>tn,Lv:()=>Dr,E9:()=>o,Ly:()=>i,jo:()=>rs,mH:()=>Jo,xd:()=>ns,pX:()=>_e,Dz:()=>Te,Th:()=>p,Uj:()=>qo,bY:()=>Vn,cV:()=>so,lR:()=>wo,xs:()=>Ft,bn:()=>yt,oC:()=>Ao,Z1:()=>gn,h8:()=>Et,Qf:()=>Nl,jE:()=>Ue,k1:()=>Jn,ew:()=>nr,$p:()=>zo,xG:()=>vt,l_:()=>Ma,pk:()=>da,yI:()=>So,E6:()=>Be,zO:()=>Ge,cB:()=>Hi,OW:()=>s,n3:()=>Zn,Se:()=>Kn,PQ:()=>On,$9:()=>Po,D_:()=>zl,qT:()=>vl,JX:()=>Al,fr:()=>pl,t2:()=>Ui,ak:()=>xe,uZ:()=>Ve,Cy:()=>qa,qM:()=>Dn,mV:()=>Jr,Gi:()=>zr,M3:()=>ui,jV:()=>lo,jS:()=>Us,ur:()=>Qs,j9:()=>Rn,oc:()=>In,wS:()=>Na,IJ:()=>Ir,p2:()=>ye,w0:()=>En,VL:()=>_a,UR:()=>ua,dV:()=>qt,G0:()=>To,YL:()=>zn,re:()=>Uo,QG:()=>Ii,xS:()=>gi});const t=(e=>{var t={};return r.d(t,e),t})({BufferGeometry:()=>e.BufferGeometry,Clock:()=>e.Clock,Color:()=>e.Color,EventDispatcher:()=>e.EventDispatcher,Float32BufferAttribute:()=>e.Float32BufferAttribute,HalfFloatType:()=>e.HalfFloatType,ImageLoader:()=>e.ImageLoader,LinearFilter:()=>e.LinearFilter,MathUtils:()=>e.MathUtils,Matrix3:()=>e.Matrix3,Matrix4:()=>e.Matrix4,Mesh:()=>e.Mesh,NearestFilter:()=>e.NearestFilter,NoBlending:()=>e.NoBlending,OrthographicCamera:()=>e.OrthographicCamera,PerspectiveCamera:()=>e.PerspectiveCamera,PlaneGeometry:()=>e.PlaneGeometry,Quaternion:()=>e.Quaternion,RGBAFormat:()=>e.RGBAFormat,RepeatWrapping:()=>e.RepeatWrapping,Scene:()=>e.Scene,ShaderMaterial:()=>e.ShaderMaterial,SphereGeometry:()=>e.SphereGeometry,Texture:()=>e.Texture,TextureLoader:()=>e.TextureLoader,Uniform:()=>e.Uniform,UniformsUtils:()=>e.UniformsUtils,Vector2:()=>e.Vector2,Vector3:()=>e.Vector3,Vector4:()=>e.Vector4,VideoTexture:()=>e.VideoTexture,WebGLRenderTarget:()=>e.WebGLRenderTarget,WebGLRenderer:()=>e.WebGLRenderer});class n{constructor(){this.build(...arguments)}build(){throw new Error("This method need be overloaded.")}get isIsometry(){return!0}identity(){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}multiply(e){throw new Error("This method need be overloaded.")}premultiply(e){throw new Error("This method need be overloaded.")}invert(){return this.matrix.invert(),this}makeTranslation(e){throw new Error("This method need be overloaded.")}makeInvTranslation(e){throw new Error("This method need be overloaded.")}makeTranslationFromDir(e){throw new Error("This method need be overloaded.")}diffExpMap(e){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new n;return e.copy(this),e}}class o{constructor(...e){this.build(...e)}build(){throw new Error("This method need be overloaded.")}get isPoint(){return!0}set(){throw new Error("This method need be overloaded.")}applyIsometry(e){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new o;return e.copy(this),e}}o.prototype.build=function(){this.coords=0===arguments.length?new t.Vector4(0,0,0,1):new t.Vector4(...arguments)},o.prototype.set=function(){return this.coords.set(arguments[0],arguments[1],arguments[2],1),this},o.prototype.applyIsometry=function(e){return this.coords.applyMatrix4(e.matrix),this},o.prototype.equals=function(e){return this.coords.equals(e.coords)},o.prototype.reduceError=function(){return this},o.prototype.copy=function(e){return this.coords.copy(e.coords),this};class s extends t.Vector3{get isVector(){return!0}applyMatrix4(e){const n=new t.Vector4(this.x,this.y,this.z,0);return n.applyMatrix4(e),this.set(n.x,n.y,n.z),this}applyFacing(e){return this.applyQuaternion(e.quaternion),this}}class i{constructor(){this.boost=new n,this.quaternion=new t.Quaternion}get isPosition(){return!0}get facing(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion)}setBoost(e){return this.boost.copy(e),this}setQuaternion(e){return this.quaternion.copy(e),this}reduceErrorBoost(){return this.boost.reduceError(),this}reduceErrorQuaternion(){return this.quaternion.normalize(),this}reduceError(){return this.reduceErrorBoost(),this.reduceErrorQuaternion(),this}get point(){return(new o).applyIsometry(this.boost)}reset(){return this.boost.identity(),this.quaternion.identity(),this}applyIsometry(e){return this.boost.premultiply(e),this}applyQuaternion(e){return this.quaternion.multiply(e),this}multiply(e){return this.boost.multiply(e.boost),this.quaternion.premultiply(e.quaternion),this}premultiply(e){return this.boost.premultiply(e.boost),this.quaternion.multiply(e.quaternion),this}flowFromOrigin(e){throw new Error("This method need be overloaded.")}flow(e){const t=e.clone().applyFacing(this),n=(new i).flowFromOrigin(t);return this.multiply(n),this}fakeDiffExpMap(e){const n=(new s).setFromMatrixPosition(e),r=(new t.Quaternion).setFromRotationMatrix(e);return this.flow(n),this.quaternion.multiply(r),this}equals(e){return this.boost.equals(e.boost)&&this.quaternion.equals(e.quaternion)}copy(e){return this.boost.copy(e.boost),this.quaternion.copy(e.quaternion),this}clone(){const e=new i;return e.copy(this),e}}const l=.001;i.prototype.flowFromOrigin=function(e){const n=e.length()/l,r=e.clone().normalize(),a=new t.Vector3,s=new o,i=new t.Vector4,c=new t.Quaternion;for(let e=0;e<n;e++)i.set(r.x,r.y,r.z,0).applyMatrix4(this.boost.matrix).multiplyScalar(l),s.coords.add(i),this.boost.makeTranslation(s),c.set(r.y,r.x,0,0).multiply(this.quaternion).multiplyScalar(5e-4),this.quaternion.add(c).normalize(),a.set(r.x*r.z,-r.y*r.z,-r.x*r.x+r.y*r.y),r.add(a.multiplyScalar(l)).normalize();return this},n.prototype.build=function(){this.matrix=new t.Matrix4},n.prototype.identity=function(){return this.matrix.identity(),this},n.prototype.reduceError=function(){return this},n.prototype.multiply=function(e){return this.matrix.multiply(e.matrix),this},n.prototype.premultiply=function(e){return this.matrix.premultiply(e.matrix),this},n.prototype.invert=function(){return this.matrix.invert(),this},n.prototype.makeTranslation=function(e){const[t,n,r]=e.coords.toArray();return this.matrix.set(Math.exp(r),0,0,t,0,Math.exp(-r),0,n,0,0,1,r,0,0,0,1),this},n.prototype.makeTranslationFromDir=function(e){const t=(new i).flowFromOrigin(e);return this.matrix.copy(t.boost.matrix),this},n.prototype.makeInvTranslation=function(e){const[t,n,r]=e.coords.toArray();return this.matrix.set(Math.exp(-r),0,0,-Math.exp(-r)*t,0,Math.exp(r),0,-Math.exp(r)*n,0,0,1,-r,0,0,0,1),this},n.prototype.makeFlip=function(){return this.matrix.set(0,1,0,0,1,0,0,0,0,0,-1,0,0,0,0,1),this},n.prototype.makeReflectionX=function(){return this.matrix.set(-1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},n.prototype.makeReflectionY=function(){return this.matrix.set(1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1),this},n.prototype.equals=function(e){return this.matrix.equals(e.matrix)},n.prototype.copy=function(e){return this.matrix.copy(e.matrix),this};var c=r(5595),d=r.n(c),u=r(9395),h=r.n(u);class p{static shader1=void 0;static shader2=void 0;constructor(e,n,r={},a={}){this.camera=e,this.scene=n,this.threeRenderer=a.isWebGLRenderer?a:new t.WebGLRenderer(a),this.globalUniforms=void 0!==r.globalUniforms?r.globalUniforms:{},void 0===this.globalUniforms.maxBounces&&(this.globalUniforms.maxBounces={type:"int",value:0}),this.globalUniforms.windowSize={type:"vec2",value:new t.Vector2(window.innerWidth,window.innerHeight)}}get set(){return this.camera.position.set}setPixelRatio(e){this.threeRenderer.setPixelRatio(e)}setSize(e,t,n=!0){this.threeRenderer.setSize(e,t,n)}setClearColor(e,t){this.threeRenderer.setClearColor(e,t)}setAnimationLoop(e){this.threeRenderer.setAnimationLoop(e)}get domElement(){return this.threeRenderer.domElement}build(){throw new Error("Renderer: this method is not implemented")}render(){throw new Error("Renderer: this method is not implemented")}}class m{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const b=new t.OrthographicCamera(-1,1,1,-1,0,1);class v extends t.BufferGeometry{constructor(){super(),this.setAttribute("position",new t.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new t.Float32BufferAttribute([0,2,0,0,2,0],2))}}const f=new v;class g{constructor(e){this._mesh=new t.Mesh(f,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,b)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class x extends m{constructor(e,n,r=null,a=null,o=null){super(),this.scene=e,this.camera=n,this.overrideMaterial=r,this.clearColor=a,this.clearAlpha=o,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new t.Color}render(e,t,n){const r=e.autoClear;let a,o;e.autoClear=!1,null!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor)),null!==this.clearAlpha&&(a=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(a),null!==this.overrideMaterial&&(this.scene.overrideMaterial=o),e.autoClear=r}}class y extends m{constructor(e,n){super(),this.textureID=void 0!==n?n:"tDiffuse",e instanceof t.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=t.UniformsUtils.clone(e.uniforms),this.material=new t.ShaderMaterial({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new g(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}const V={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class M extends m{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const r=e.getContext(),a=e.state;let o,s;a.buffers.color.setMask(!1),a.buffers.depth.setMask(!1),a.buffers.color.setLocked(!0),a.buffers.depth.setLocked(!0),this.inverse?(o=0,s=1):(o=1,s=0),a.buffers.stencil.setTest(!0),a.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),a.buffers.stencil.setFunc(r.ALWAYS,o,4294967295),a.buffers.stencil.setClear(s),a.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),a.buffers.color.setLocked(!1),a.buffers.depth.setLocked(!1),a.buffers.color.setMask(!0),a.buffers.depth.setMask(!0),a.buffers.stencil.setLocked(!1),a.buffers.stencil.setFunc(r.EQUAL,1,4294967295),a.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),a.buffers.stencil.setLocked(!0)}}class _ extends m{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class w{constructor(e,n){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===n){const r=e.getSize(new t.Vector2);this._width=r.width,this._height=r.height,(n=new t.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:t.HalfFloatType})).texture.name="EffectComposer.rt1"}else this._width=n.width,this._height=n.height;this.renderTarget1=n,this.renderTarget2=n.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new y(V),this.copyPass.material.blending=t.NoBlending,this.clock=new t.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,r=this.passes.length;t<r;t++){const r=this.passes[t];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==M&&(r instanceof M?n=!0:r instanceof _&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const n=this.renderer.getSize(new t.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=n.width,this._height=n.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class S{constructor(e=1){this.useCase=e,this.code="",this.includedImports=[],this.includedClasses=[],this.includedConstants=[],this.includedUniforms=[],this.includedInstances=[],this.uniforms={}}get fragmentShader(){return this.code}addChunk(e){return this.code=this.code+"\r\n\r\n"+e,this}addImport(e){return this.includedImports.includes(e)||(this.includedImports.push(e),this.code=this.code+"\r\n\r\n"+e),this}addClass(e,t){return this.includedClasses.includes(e)||(this.includedClasses.push(e),this.code=this.code+"\r\n\r\n"+t),this}addConstant(e,t,n){return this.includedConstants.includes(e)||(this.includedConstants.push(e),this.code=this.code+"\r\n\r\n"+`const ${t} ${e} = ${n};`),this}addUniform(e,t,n){return this.includedUniforms.includes(e)||(this.includedUniforms.push(e),this.code=this.code+"\r\n\r\n"+`uniform ${t} ${e};`,this.uniforms[e]={type:t,value:n}),this}updateUniform(e,t){return this.uniforms[e].value=t,this}addInstance(e,t){return this.includedInstances.includes(e)||(this.includedInstances.push(e),this.code=this.code+"\r\n\r\n"+t),this}}var T=r(1767),C=r.n(T),D=r(190),I=r.n(D),R=r(4168),E=r.n(R),k=r(2977),P=r.n(k),U=r(2044),B=r.n(U),L=r(9461),N=r.n(L),G=r(7781),F=r.n(G),A=r(6159),z=r.n(A),j=r(5315),H=r.n(j);class O extends p{constructor(e,t,n={},r={}){super(e,t,n,r),this._fragmentBuilder=new S,this.postProcess=void 0!==n.postProcess?n.postProcess:[],this.composer=new w(this.threeRenderer)}get isBasicRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.composer.setSize(e,t)}buildFragmentShader(){this._fragmentBuilder.addChunk(C()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)})),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(I()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(E()),this._fragmentBuilder.addChunk(N()),this.set.shader(this._fragmentBuilder),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(B()(this)),this._fragmentBuilder.addChunk(F()(this)),this._fragmentBuilder.addChunk(P()),this._fragmentBuilder.addChunk(z()),this._fragmentBuilder.addChunk(H())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder);const e=new x(this.camera.threeScene,this.camera.threeCamera);e.clear=!1,this.composer.addPass(e);for(let e=0;e<this.postProcess.length;e++){const t=new y(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}render(){this.composer.render()}}class q extends m{constructor(e,n){super();const r=V;this.map=e,this.opacity=void 0!==n?n:1,this.uniforms=t.UniformsUtils.clone(r.uniforms),this.material=new t.ShaderMaterial({uniforms:this.uniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,depthTest:!1,depthWrite:!1,premultipliedAlpha:!0}),this.needsSwap=!1,this.fsQuad=new g(null)}render(e,t,n){const r=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.uniforms.opacity.value=this.opacity,this.uniforms.tDiffuse.value=this.map,this.material.transparent=this.opacity<1,e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(),this.fsQuad.render(e),e.autoClear=r}dispose(){this.material.dispose(),this.fsQuad.dispose()}}var W=r(7962),Z=r.n(W);class X{constructor(){}uniforms(){return{tDiffuse:{value:null}}}vertexShader(){return Z()}fragmentShader(){throw new Error("Shape: this method should be implemented")}fullShader(){return{uniforms:this.uniforms(),vertexShader:this.vertexShader(),fragmentShader:this.fragmentShader()}}}var Y=r(2690),K=r.n(Y);class Q extends X{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return K()}}var $=r(6172),J=r.n($),ee=r(3499),te=r.n(ee),ne=r(9638),re=r.n(ne),ae=r(7920),oe=r.n(ae),se=r(3888),ie=r.n(se),le=r(6272),ce=r.n(le),de=r(8187),ue=r.n(de),he=r(4122),pe=r.n(he);const me=new t.ShaderMaterial({uniforms:{accTex:new t.Uniform(null),newTex:new t.Uniform(null),iFrame:new t.Uniform(0)},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D accTex;\n        uniform sampler2D newTex;\n        uniform float iFrame;\n        void main() {\n            float den = 1./ (1. + iFrame);\n            gl_FragColor = den * (iFrame *  texture2D(accTex, vUv) + texture2D(newTex, vUv));\n        }"}),be=new g(me),ve={minFilter:t.NearestFilter,magFilter:t.NearestFilter,format:t.RGBAFormat,type:t.HalfFloatType};class fe extends p{constructor(e,n,r={},a={}){super(e,n,r,a),this.globalUniforms.maxBounces.value=void 0!==r.maxBounces?r.maxBounces:50,this.postProcess=void 0!==r.postProcess?r.postProcess:[],0===this.postProcess.length&&this.postProcess.push(new Q),this._fragmentBuilder=new S(3),this.sceneTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,ve),this.accReadTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,ve),this.accWriteTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,ve),this.iFrame=0,this.composer=new w(this.threeRenderer)}get isPathTracerRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.sceneTarget.setSize(e,t),this.accReadTarget.setSize(e,t),this.accWriteTarget.setSize(e,t),this.composer.setSize(e,t)}updateFrameSeed(){const e=Math.floor(1e4*Math.random());this._fragmentBuilder.updateUniform("frameSeed",e)}buildFragmentShader(){this._fragmentBuilder.addChunk(C()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)}));const e=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.addUniform("resolution","vec2",e),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(I()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(E()),this._fragmentBuilder.addUniform("frameSeed","uint",Math.floor(1e4*Math.random())),this._fragmentBuilder.addChunk(re()),this._fragmentBuilder.addChunk(ie()),this.set.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(oe()),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(J()(this)),this._fragmentBuilder.addChunk(pe()(this)),this._fragmentBuilder.addChunk(ce()(this)),this._fragmentBuilder.addChunk(te()),this._fragmentBuilder.addChunk(ue())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder),this.composer.addPass(new q(this.accReadTarget.texture));for(let e=0;e<this.postProcess.length;e++){const t=new y(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}renderAccTarget(){this.threeRenderer.setRenderTarget(null),this.composer.render()}render(){let e;this.updateFrameSeed();const n=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.updateUniform("resolution",n),this.threeRenderer.setRenderTarget(this.sceneTarget),this.threeRenderer.render(this.threeScene,this.camera.threeCamera),this.threeRenderer.setRenderTarget(this.accWriteTarget),me.uniforms.accTex.value=this.accReadTarget.texture,me.uniforms.newTex.value=this.sceneTarget.texture,me.uniforms.iFrame.value=this.iFrame,be.render(this.threeRenderer),e=this.accReadTarget,this.accReadTarget=this.accWriteTarget,this.accWriteTarget=e,this.renderAccTarget(),this.iFrame=this.iFrame+1}}class ge{static createButton(e){const t=document.createElement("button");function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",r(t),navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){let n=null;async function r(r){r.addEventListener("end",a),await e.xr.setSession(r),t.textContent="EXIT VR",n=r}function a(){n.removeEventListener("end",a),t.textContent="ENTER VR",n=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){if(null===n){const e={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};navigator.xr.requestSession("immersive-vr",e).then(r)}else n.end()}}():(n(),t.textContent="VR NOT SUPPORTED"),r&&ge.xrSessionIsGranted&&t.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{ge.xrSessionIsGranted=!0}))}}}function xe(e,t){return function(){return t.apply(e,arguments)}}function ye(e){return e.replace(/\W/g,"_")}function Ve(e,t,n){return Math.max(t,Math.min(n,e))}ge.xrSessionIsGranted=!1,ge.registerSessionGrantedListener(),t.Vector3.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}]`},t.Vector4.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Matrix3.prototype.toLog=function(){let e="\r\n";for(let t=0;t<3;t++){for(let n=0;n<3;n++)0!==n&&(e+=",\t"),e+=this.elements[t+3*n];e+="\r\n"}return e},t.Matrix3.prototype.power=function(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}},t.Matrix3.prototype.makeRotation=function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this},t.Matrix4.prototype.toLog=function(){let e="\r\n";for(let t=0;t<4;t++){for(let n=0;n<4;n++)0!==n&&(e+=",\t"),e+=this.elements[t+4*n];e+="\r\n"}return e},t.Matrix4.prototype.add=function(e){return this.set.apply(this,[].map.call(this.elements,(function(t,n){return t+e.elements[n]}))),this},t.Quaternion.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Quaternion.prototype.multiplyScalar=function(e){return this.set(e*this.x,e*this.y,e*this.z,e*this.w),this},t.Quaternion.prototype.add=function(e){return this.set(this.x+e.x,this.y+e.y,this.z+e.z,this.w+e.w),this};const Me=0,_e=1,we=2;class Se{constructor(e){this.group=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.name=`groupElement_${this.uuid}`}identity(){throw new Error("GroupElement: This method need be overloaded.")}multiply(e){throw new Error("GroupElement: This method need be overloaded.")}premultiply(e){throw new Error("GroupElement: This method need be overloaded.")}invert(){throw new Error("GroupElement: This method need be overloaded.")}toIsometry(){throw new Error("GroupElement: This method need be overloaded.")}equals(e){throw new Error("GroupElement: This method need be overloaded.")}clone(){throw new Error("GroupElement: This method need be overloaded.")}copy(e){throw new Error("GroupElement: This method need be overloaded.")}}class Te{constructor(e){this.local=new i,this.set=e,this.cellBoost=this.set.group.element(),this.invCellBoost=this.set.group.element()}reduceErrorBoost(){return this.local.reduceErrorBoost(),this}reduceErrorFacing(){return this.local.reduceErrorFacing(),this}reduceErrorLocal(){return this.local.reduceError(),this}reduceError(){return this.reduceErrorLocal(),this}get facing(){return this.local.facing}get localPoint(){return this.local.point}get point(){return this.local.point.applyIsometry(this.cellBoost.toIsometry())}get globalBoost(){return this.cellBoost.toIsometry().multiply(this.local.boost)}get globalPosition(){const e=new i;return e.boost.copy(this.globalBoost),e.quaternion.copy(this.local.quaternion),e}reset(){this.local.reset(),this.cellBoost.identity(),this.invCellBoost.identity()}applyQuaternion(e){return this.local.applyQuaternion(e),this}teleport(){let e,t;for(;;){t=this.localPoint,e=!0;for(const n of this.set.teleportations)if(e=e&&!n.jsTest(t),!e){this.local.applyIsometry(n.elt.toIsometry()),this.cellBoost.multiply(n.inv),this.invCellBoost.premultiply(n.elt);break}if(e)break}return this}flow(e){return this.local.flow(e),this.teleport(),this}fakeDiffExpMap(e){return this.local.fakeDiffExpMap(e),this}equals(e){let t=!0;return t=t&&this.local.equals(e.local),t=t&&this.cellBoost.equals(e.cellBoost),t}copy(e){return this.cellBoost.copy(e.cellBoost),this.invCellBoost.copy(e.invCellBoost),this.local.copy(e.local),this}clone(){const e=new Te(this.set);return e.copy(this),e}}r(8415),r(4770);class Ce{constructor(e){this.threeCamera=void 0,this.threeScene=new t.Scene,this.minDist=void 0!==e.minDist?e.minDist:0,this.maxDist=void 0!==e.maxDist?e.maxDist:50,this.safetyDist=void 0!==e.safetyDist?e.safetyDist:0,this.maxSteps=void 0!==e.maxSteps?e.maxSteps:100,this.threshold=void 0!==e.threshold?e.threshold:1e-4,this.position=new Te(e.set),this.fakeCameras=[],this.setThreeCamera(e)}setThreeCamera(e){throw new Error("This method need be implemented.")}setThreeScene(){throw new Error("This method need be implemented.")}get matrix(){return this.threeCamera.matrixWorld}updateProjectionMatrix(){this.threeCamera.updateProjectionMatrix()}static glslClass(){throw new Error("Generic: this function should be implemented")}static glslMapping(){throw new Error("Generic: this function should be implemented")}shader(e,t=void 0){e.addClass("Camera",this.constructor.glslClass()),void 0===t?e.addUniform("camera","Camera",this):e.addUniform("camera","Camera",this.fakeCameras[t]),e.addChunk(this.constructor.glslMapping())}}var De=r(5682),Ie=r.n(De),Re=r(5970),Ee=r.n(Re),ke=r(9222),Pe=r.n(ke);class Ue extends Ce{constructor(e){super(e)}setThreeCamera(e){this.threeCamera=new t.PerspectiveCamera(void 0!==e.fov?e.fov:70,window.innerWidth/window.innerHeight,.01,2e3),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}set aspect(e){this.threeCamera.aspect=e}get fov(){return this.threeCamera.fov}set fov(e){this.threeCamera.fov=e}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.SphereGeometry(1e3,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:Ie(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return Ee()}static glslMapping(){return Pe()}}class Be extends Ue{constructor(e){super(e),this.isStereoOn=!1,this.ipDist=void 0!==e.ipDist?e.ipDist:.03200000151991844;for(const e in[Me,_e])this.fakeCameras[e]={fov:this.fov,minDist:this.minDist,maxDist:this.maxDist,maxSteps:this.maxSteps,safetyDist:this.safetyDist,threshold:this.threshold,position:this.position.clone(),matrix:this.matrix}}get isStereoOff(){return!this.isStereoOn}switchStereo(){this.isStereoOn=!this.isStereoOn}setThreeScene(e){const n=new t.SphereGeometry(50,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e[Me].uniforms,vertexShader:Ie(),fragmentShader:e[Me].fragmentShader}),a=new t.ShaderMaterial({uniforms:e[_e].uniforms,vertexShader:Ie(),fragmentShader:e[Me].fragmentShader}),o=new t.Mesh(n,r),s=new t.Mesh(n,a);o.layers.set(1),s.layers.set(2),this.threeScene.add(o,s)}updateFakeCamerasPosition(){if(this.fakeCameras[Me].position.copy(this.position),this.fakeCameras[_e].position.copy(this.position),this.isStereoOn){const e=new s(1,0,0).multiplyScalar(2*this.ipDist).applyMatrix4(this.matrix).negate();this.fakeCameras[Me].position.flow(e)}}get chaseThreeCamera(){if(void 0===this._chaseThreeCamera){const e=new s;this._chaseThreeCamera=function(){const t=(new s).setFromMatrixPosition(this.matrix),n=(new s).subVectors(t,e);this.position.flow(n),this.updateFakeCamerasPosition(),e.copy(t)}}return this._chaseThreeCamera}}var Le=r(8351),Ne=r.n(Le);class Ge extends p{constructor(e,t,n={},r={}){super(e,t,n,r),this.threeRenderer.xr.enabled=!0,this.threeRenderer.xr.setReferenceSpaceType("local"),this.camera.threeCamera.layers.enable(1);const a=ge.createButton(this.threeRenderer),o=xe(this.camera,this.camera.switchStereo);a.addEventListener("click",o,!1),document.body.appendChild(a),this._fragmentBuilders=[new S,new S],this.postProcess=void 0!==n.postProcess&&n.postProcess,this.exposure=void 0!==n.exposure?n.exposure:1}get isVRRenderer(){return!0}get xr(){return this.threeRenderer.xr}buildFragmentShader(){for(const e of[Me,_e])this._fragmentBuilders[e].addChunk(C()),Object.keys(this.globalUniforms).forEach((t=>{const n=this.globalUniforms[t].type,r=this.globalUniforms[t].value;this._fragmentBuilders[e].addUniform(t,n,r)})),this._fragmentBuilders[e].addChunk(this.constructor.shader1),this._fragmentBuilders[e].addChunk(I()),this._fragmentBuilders[e].addChunk(this.constructor.shader2),this._fragmentBuilders[e].addChunk(E()),this._fragmentBuilders[e].addChunk(N()),this.set.shader(this._fragmentBuilders[e]),this.camera.shader(this._fragmentBuilders[e],e),this.scene.shader(this._fragmentBuilders[e]),this._fragmentBuilders[e].addChunk(B()(this)),this._fragmentBuilders[e].addChunk(F()(this)),this._fragmentBuilders[e].addChunk(P()),this.postProcess?(this._fragmentBuilders[e].addUniform("exposure","float",this.exposure),this._fragmentBuilders[e].addChunk(Ne())):this._fragmentBuilders[e].addChunk(z()),this._fragmentBuilders[e].addChunk(H())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilders)}checkShader(e=Me){console.log(this._fragmentBuilders[e].code)}render(){this.camera.chaseThreeCamera(),this.threeRenderer.render(this.camera.threeScene,this.camera.threeCamera)}}var Fe=r(6224),Ae=r.n(Fe),ze=r(8710),je=r.n(ze),He=r(4750),Oe=r.n(He);class qe extends Ce{constructor(e){super(e),this.fov=void 0!==e.fov?e.fov:50}setThreeCamera(){this.threeCamera=new t.OrthographicCamera(-1,1,1,-1,0,1),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.PlaneGeometry(2,2),r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:Ae(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return je()}static glslMapping(){return Oe()}}var We=r(6354),Ze=r.n(We),Xe=r(6684),Ye=r.n(Xe);class Ke extends Ue{constructor(e){super(e),this.focalLength=void 0!==e.focalLength?e.focalLength:1,this.aperture=void 0!==e.aperture?e.aperture:0}static glslClass(){return Ze()}static glslMapping(){return Ye()}}class Qe{constructor(){}element(){throw new Error("Group: this method should be implemented")}shader(e){throw new Error("Group: this method should be implemented")}}class $e extends Se{constructor(e){super(e),this.fake=!0}identity(){return this}multiply(e){return this}premultiply(e){return this}invert(){return this}toIsometry(){return new n}equals(e){return!0}clone(){return new $e}copy(e){return this}}var Je=r(9188),et=r.n(Je);class tt extends Qe{constructor(){super()}element(){return new $e(this)}shader(e){e.addChunk(et())}}var nt=r(3148),rt=r.n(nt);const at=/bool\s*(\w+)\(Point.*\)/m,ot=/float\s*(\w+)\(ExtVector.*\)/m;class st{constructor(e,n,r,a,o=void 0,s=void 0){let i;if(this.set=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.jsTest=n,this.glslTest=r,this.glslTestName=void 0,i=r.match(at),!i)throw new Error("Teleportation: unable to find the name of the GLSL test");if(this.glslTestName=i[1],this.elt=a,this.inv=void 0!==o?o:a.clone().invert(),this.glslCreepCustom=void 0,this.glslCreep=void 0,this.glslCreepName=void 0,void 0!==s){if(this.glslCreepCustom=!0,this.glslCreep=s,i=s.match(ot),!i)throw new Error("Teleportation: unable to find the name of the GLSL creep");this.glslCreepName=i[1]}else this.glslCreepCustom=!1,this.glslCreepName=`creep${this.uuid}`,this.glslCreep=rt()(this)}get name(){return void 0===this._name&&(this._name=`teleportation_${this.uuid}`),this._name}get usesCreepingCustom(){return this.set.usesCreeping&&this.glslCreepCustom}get usesCreepingBinary(){return this.set.creepingType===bt&&!this.glslCreepCustom}shader(e){e.addChunk(this.glslTest),this.set.usesCreeping&&e.addChunk(this.glslCreep),e.addUniform(this.elt.name,"GroupElement",this.elt),e.addUniform(this.elt.name,"GroupElement",this.inv)}}var it=r(2311),lt=r.n(it),ct=r(7970),dt=r.n(ct),ut=r(5103),ht=r.n(ut);const pt=0,mt=1,bt=2;class vt{constructor(e=[],t=!1,n=pt){this.teleportations=[],this.neighbors=e,this.usesNearestNeighbors=t,this.creepingType=n}get usesCreeping(){return this.creepingType===mt||this.creepingType===bt}add(e,t,n,r=void 0,a=void 0){return this.teleportations.push(new st(this,e,t,n,r,a)),this}get group(){return 0!==this.teleportations.length?this.teleportations[0].elt.group:new tt}shader(e){this.group.shader(e),e.addChunk(lt()),e.addChunk(dt());for(const t of this.teleportations)t.shader(e);for(const t of this.neighbors)e.addUniform(t.elt.name,"GroupElement",t.elt),e.addUniform(t.inv.name,"GroupElement",t.inv);e.addChunk(ht()(this))}}class ft{constructor(){this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.id=void 0,this.imports=[]}get className(){return this.constructor.name}get name(){return void 0===this._name&&(this._name=`${ye(this.className)}_${this.uuid}`),this._name}get uniformType(){return""}setId(e){this.id=e.nextId,e.nextId=e.nextId+1}onAdd(e){}addImport(e){for(const e of arguments)this.imports.push(e)}static glslClass(){throw new Error("Generic: this function should be implemented")}glslInstance(){throw new Error("Generic: this function should be implemented")}shader(e){for(const t of this.imports)e.addImport(t);e.addClass(this.constructor.name,this.constructor.glslClass()),""!==this.uniformType&&e.addUniform(this.name,this.uniformType,this),e.addInstance(this.name,this.glslInstance())}}var gt=r(8266),xt=r.n(gt);class yt extends ft{constructor(e=void 0){super(),this.isom=void 0!==e?e:new n,this.isomInv=this.isom.clone().invert(),this.parent=void 0,this._absoluteIsom=void 0,this._absoluteIsomInv=void 0}updateAbsoluteIsom(){void 0===this._absoluteIsom&&(this._absoluteIsom=new n,this._absoluteIsomInv=new n),this.isomInv=this.isom.clone().invert(),this._absoluteIsom.copy(this.isom),this._absoluteIsomInv.copy(this.isomInv),void 0!==this.parent&&(this._absoluteIsom.premultiply(this.parent.absoluteIsom),this._absoluteIsomInv.multiply(this.parent.absoluteIsomInv))}updateData(){this.updateAbsoluteIsom()}get absoluteIsom(){return void 0===this._absoluteIsom&&this.updateAbsoluteIsom(),this._absoluteIsom}get absoluteIsomInv(){return void 0===this._absoluteIsomInv&&this.updateAbsoluteIsom(),this._absoluteIsomInv}get isShape(){return!0}get isBasicShape(){throw new Error("Shape: this method should be implemented")}get isAdvancedShape(){return!this.isBasicShape}get isGlobal(){throw new Error("Shape: this method should be implemented")}get isLocal(){return!this.isGlobal}get hasUVMap(){return!1}glslSDF(){throw new Error("Shape: this method should be implemented")}glslGradient(){return xt()(this)}glslUVMap(){throw new Error("Shape: this method should be implemented")}glslInstance(){let e=this.glslSDF()+"\r\n"+this.glslGradient();return this.hasUVMap&&(e=e+"\r\n"+this.glslUVMap()),e}}class Vt extends yt{constructor(e=void 0){super(e)}get isBasicShape(){return!0}}class Mt extends yt{constructor(e=void 0){super(e)}get isBasicShape(){return!1}}class _t extends ft{constructor(e){super(),this.maxDirs=e}get isLight(){return!0}get isGlobal(){throw new Error("Generic: this method should be implemented")}get isLocal(){return!this.isGlobal}glslDirections(){throw new Error("Light: this method should be implemented")}glslInstance(){return this.glslDirections()}}class wt extends ft{constructor(){super(),this.lights=void 0,this.reflectivity=void 0}get isMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}get isTransparent(){return!1}onAdd(e){this.usesLight&&(this.hasOwnProperty("lights")&&void 0!==this.lights||(this.lights=e.lights))}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class St extends ft{constructor(){super()}get isPTMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}onAdd(e){}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class Tt{constructor(){}shader(e){throw new Error("Fog: this method need be implemented")}}var Ct=r(2664),Dt=r.n(Ct),It=r(8778),Rt=r.n(It);class Et extends wt{constructor(e){super(),this.color=e}get uniformType(){return"SingleColorMaterial"}get usesNormal(){return!1}static glslClass(){return Dt()}glslRender(){return Rt()(this)}}var kt=r(2143),Pt=r.n(kt),Ut=r(9606),Bt=r.n(Ut),Lt=r(5363),Nt=r.n(Lt);class Gt extends St{constructor(e){super(),this.emission=void 0!==e.emission?e.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==e.volumeEmission?e.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==e.opticalDepth?e.opticalDepth:1e3,this.diffuse=void 0!==e.diffuse?e.diffuse:new t.Color(1,1,1),this.specular=void 0!==e.specular?e.specular:new t.Color(1,1,1),this.absorb=void 0!==e.absorb?e.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==e.ior?e.ior:1,this.roughness=void 0!==e.roughness?e.roughness:.2,this.reflectionChance=void 0!==e.reflectionChance?e.reflectionChance:.1,this.refractionChance=void 0!==e.refractionChance?e.refractionChance:0,this.diffuseChance=void 0!==e.diffuseChance?e.diffuseChance:.9;const n=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/n,this.refractionChance=this.refractionChance/n,this.diffuseChance=this.diffuseChance/n,this.addImport(Nt())}get uniformType(){return"BasicPTMaterial"}static glslClass(){return Pt()}glslRender(){return Bt()(this)}}class Ft{constructor(e={}){this.lights=[],this.solids=[],this.nextId=0,this.fog=e.fog,this.background=void 0!==e.background?e.background:new Et(new t.Color(0,0,0)),this.ptBackground=void 0!==e.ptBackground?e.ptBackground:new Gt({diffuse:new t.Color(0,0,0),specular:new t.Color(0,0,0),absorb:new t.Color(.25,.25,.25)})}_add(e){return e.setId(this),e.onAdd(this),e.isLight&&this.lights.push(e),e.isSolid&&this.solids.push(e),this}add(e){for(const e of arguments)this._add(e);return this}shader(e){3===e.useCase?this.ptBackground.shader(e):this.background.shader(e);for(const t of this.lights)3!==e.useCase&&t.shader(e);for(const t of this.solids)t.shader(e);void 0!==this.fog&&this.fog.shader(e)}}var At=r(7885),zt=r.n(At),jt=r(5348),Ht=r.n(jt);class Ot extends Tt{constructor(e,t){super(),this.color=e,this.scattering=t}shader(e){e.addClass("ExpFog",zt()),e.addUniform("fog","ExpFog",this),e.addChunk(Ht())}}const qt=new vt;var Wt=r(3496),Zt=r.n(Wt),Xt=r(6077),Yt=r.n(Xt);class Kt extends wt{constructor(){super()}get uniformType(){return""}static glslClass(){return Zt()}glslRender(){return Yt()(this)}}var Qt=r(6045),$t=r.n(Qt),Jt=r(8149),en=r.n(Jt);class tn extends wt{constructor(e={}){super(),this.color=void 0!==e.color?e.color:new t.Color(1,1,1),this.ambient=void 0!==e.ambient?e.ambient:.5,this.diffuse=void 0!==e.diffuse?e.diffuse:.4,this.specular=void 0!==e.specular?e.specular:.1;const n=this.ambient+this.diffuse+this.specular;this.ambient=this.ambient/n,this.diffuse=this.diffuse/n,this.specular=this.specular/n,this.shininess=void 0!==e.shininess?e.shininess:10,this._isReflecting=void 0!==e.isReflecting&&e.isReflecting,this.reflectivity=void 0!==e.reflectivity?e.reflectivity:new t.Color(0,0,0),this.lights=e.lights}get uniformType(){return"PhongMaterial"}get usesLight(){return!0}get isReflecting(){return this._isReflecting}static glslClass(){return $t()}glslRender(){return en()(this)}shader(e){for(const t of this.lights)t.shader(e);super.shader(e)}}var nn=r(2197),rn=r.n(nn),an=r(1215),on=r.n(an);class sn extends wt{constructor(e,t,n,r){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"CheckerboardMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return rn()}glslRender(){return on()(this)}}var ln=r(3801),cn=r.n(ln);class dn extends wt{constructor(e,t,n,r,a){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"GraphPaperMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return cn()}glslRender(){return on()(this)}}var un=r(7793),hn=r.n(un),pn=r(9909),mn=r.n(pn);class bn extends wt{constructor(){super()}get uniformType(){return""}get usesNormal(){return!1}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}static glslClass(){return hn()}glslRender(){return mn()(this)}shader(e){super.shader(e)}}var vn=r(9095),fn=r.n(vn);class gn extends wt{constructor(e,n={}){super(),this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==n.isTransparent&&n.isTransparent}get uniformType(){return"SimpleTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return fn()}glslRender(){return on()(this)}}var xn=r(1220),yn=r.n(xn);class Vn extends wt{constructor(e,n=void 0,r={}){super(),this.quaternion=void 0!==n?n:new t.Quaternion,this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get uniformType(){return"RotatedSphericalTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return yn()}glslRender(){return on()(this)}}const Mn=r.p+"img/426f7657671a2811d4aa.png",_n=r.p+"img/953837709706027f7dc2.jpg",wn=r.p+"img/eba62d0cff4836a949b8.png",Sn=r.p+"img/26419cb1ce4138a11aa9.jpg",Tn=r.p+"img/33960f5af615e67309e5.jpg",Cn=r.p+"img/4b569137334e61081651.jpg";function Dn(e){let n;switch(e){case 0:default:n=Mn;break;case 1:n=_n}return new gn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function In(e){let n;switch(e){case 0:default:n=wn;break;case 1:n=Sn}return new gn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function Rn(){return new gn(Tn,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function En(e){return new gn(Cn,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}const kn=r.p+"img/eb3dc827520201070f7e.jpg",Pn=r.p+"img/ce3e4a6e1affece0e902.jpg",Un=r.p+"img/370531b8ba6e5bd6a61e.jpg",Bn=r.p+"img/29989970ee70af555fd4.jpg",Ln=r.p+"img/1a661a5afc65c969818f.jpg",Nn=r.p+"img/bb733e02d9f86b8b7433.jpg",Gn=r.p+"img/f5196bbc22091948755e.jpg",Fn=r.p+"img/9e3233c13cddac942dc4.jpg",An=r.p+"img/2528cfc76a03ca71fb7f.jpg";function zn(e,n,r=void 0){let a;switch(e){case"eye":switch(n){case 0:a=kn;break;case 1:a=Pn;break;case 2:a=Un;break;case 3:a=Bn;break;case 4:a=Ln;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;case"hand":switch(n){case 0:a=Nn;break;case 1:a=Gn;break;case 2:a=Fn;break;case 3:a=An;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;default:throw new Error("WoodBallMaterial: this type of texture is not implemented.")}return new Vn(a,r,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}var jn=r(533),Hn=r.n(jn);class On extends wt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0!==n.transparent&&n.transparent}get uniformType(){return"VideoTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return Hn()}glslRender(){return on()(this)}}var qn=r(2229),Wn=r.n(qn);class Zn extends wt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0===n.transparent||n.transparent}get uniformType(){return"VideoAlphaTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return Wn()}glslRender(){return on()(this)}}var Xn=r(4680),Yn=r.n(Xn);class Kn extends wt{static REFRESH_READY=0;static REFRESH_IN_PROGRESS=1;static REFRESH_COMPLETE=2;constructor(e,n,r={}){super(),this.files=e,this.frameNumber=e.length,this.sampler=new t.Texture,this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent,this.loop=void 0!==r.loop&&r.loop,this.callback=void 0!==r.callback?r.callback:function(){},this.fps=void 0!==r.fps&&r.fps,this.imageStatus=Kn.REFRESH_READY,this.imageLoader=new t.ImageLoader,this.imageLoader.setPath(n),this.currentFrame=0}nextFrameIndex(e){return this.loop?(e+1)%this.frameNumber:Math.min(e+1,this.frameNumber-1)}nextFrame(){if(this.imageStatus===Kn.REFRESH_READY){this.imageStatus=Kn.REFRESH_IN_PROGRESS;const e=this.files[this.currentFrame];this.currentFrame=this.nextFrameIndex(this.currentFrame);const t=this;this.imageLoader.load(e,(function(e){t.sampler.image=e,t.sampler.needsUpdate=!0,t.imageStatus=Kn.REFRESH_COMPLETE}),void 0,(function(){console.log(`Cannot load the file ${e}`)}))}}get uniformType(){return"VideoFrameTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return Yn()}glslRender(){return on()(this)}}var Qn=r(3081),$n=r.n(Qn);class Jn extends wt{constructor(e,n,r,a=void 0){super(),this.dir1=e,this.dir2=n;const o=void 0!==a?a:[.5,1,1,.5];let s=0;const i=[];for(let e=0;e<4;e++)void 0!==o[e]&&(s+=o[e]),i[e]=s;for(let e=0;e<4;e++)i[e]=i[e]/s;this.lengths=new t.Vector4(...i);let l=new t.Color(1,1,1);this.color0=void 0!==r[0]?r[0]:l.clone(),l=this.color0,this.color1=void 0!==r[1]?r[1]:l.clone(),l=this.color1,this.color2=void 0!==r[2]?r[2]:l.clone(),l=this.color2,this.color3=void 0!==r[3]?r[3]:l.clone()}get uniformType(){return"SquaresMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return $n()}glslRender(){return on()(this)}}var er=r(9835),tr=r.n(er);class nr extends wt{constructor(e,n,r=void 0){super(),this.dir=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"StripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return tr()}glslRender(){return on()(this)}}var rr=r(7685),ar=r.n(rr);class or extends wt{constructor(e,n,r=void 0){super(),this.totalWidth=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"HypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return ar()}glslRender(){return on()(this)}}var sr=r(1917),ir=r.n(sr);class lr extends wt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"EquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return ir()}glslRender(){return on()(this)}}var cr=r(4743),dr=r.n(cr);class ur extends wt{constructor(e,t,n,r){super(),this.distance=e,this.width=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"EquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return dr()}glslRender(){return on()(this)}}var hr=r(4566),pr=r.n(hr);class mr extends wt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"ImprovedEquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return pr()}glslRender(){return on()(this)}}var br=r(1650),vr=r.n(br);class fr extends wt{constructor(e,n,r,a,o,s=void 0){super(),this.distance=e,this.halfWidth=n,this.fadingAmplitude=r,this.stripColor=a,this.bgColor=o,this.quaternion=void 0!==s?s:new t.Quaternion}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"ImprovedEquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return vr()}glslRender(){return on()(this)}}var gr=r(5836),xr=r.n(gr),yr=r(3838),Vr=r.n(yr),Mr=r(472),_r=r.n(Mr),wr=r(8204),Sr=r.n(wr),Tr=r(7660),Cr=r.n(Tr);class Dr extends wt{constructor(e,n={}){super(),this.material=e,this.ambient=void 0!==n.ambient?n.ambient:.5,this.diffuse=void 0!==n.diffuse?n.diffuse:.5,this.specular=void 0!==n.specular?n.specular:.5,this.shininess=void 0!==n.shininess?n.shininess:10,this._isReflecting=void 0!==n.isReflecting&&n.isReflecting,this.reflectivity=void 0!==n.reflectivity?n.reflectivity:new t.Vector3(0,0,0),this.lights=n.lights}get uniformType(){return"PhongWrapMaterial"}static glslClass(){return xr()}get usesNormal(){return!0}get usesUVMap(){return this.material.usesUVMap}get usesLight(){return!0}get isReflecting(){return this._isReflecting}glslRender(){return this.material.usesNormal?this.material.usesUVMap?Cr()(this):_r()(this):this.material.usesUVMap?Sr()(this):Vr()(this)}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e);for(const t of this.lights)t.shader(e);super.shader(e)}}function Ir(e,t={}){return new Dr(e,t)}var Rr=r(3048),Er=r.n(Rr),kr=r(8474),Pr=r.n(kr),Ur=r(5506),Br=r.n(Ur),Lr=r(3045),Nr=r.n(Lr),Gr=r(7397),Fr=r.n(Gr);class Ar extends wt{constructor(e,t){super(),this.defaultMat=e,this.highlightMat=t,this.isHighlightOn=!1}get uniformType(){return"HighlightWrapMaterial"}static glslClass(){return Er()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Fr()(this):Br()(this):this.usesUVMap?Nr()(this):Pr()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function zr(e,t){return new Ar(e,t)}var jr=r(2278),Hr=r.n(jr),Or=r(8906),qr=r.n(Or),Wr=r(1998),Zr=r.n(Wr),Xr=r(4261),Yr=r.n(Xr),Kr=r(699),Qr=r.n(Kr);class $r extends wt{constructor(e,t,n){super(),this.defaultMat=e,this.highlightMat=t,this.cellBoost=n}get uniformType(){return"HighlightLocalWrapMaterial"}static glslClass(){return Hr()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Qr()(this):Zr()(this):this.usesUVMap?Yr()(this):qr()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function Jr(e,t,n){return new $r(e,t,n)}var ea=r(5698),ta=r.n(ea),na=r(8402),ra=r.n(na),aa=r(6158),oa=r.n(aa),sa=r(2332),ia=r.n(sa),la=r(4146),ca=r.n(la);class da extends wt{constructor(e,n,r=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==r?r:5,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=Ve(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionWrapMaterial"}static glslClass(){return ta()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?ca()(this):oa()(this):this.usesUVMap?ia()(this):ra()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function ua(e,t,n){return new da(e,t,n)}var ha=r(1888),pa=r.n(ha),ma=r(5377),ba=r.n(ma),va=r(9441),fa=r.n(va),ga=r(6766),xa=r.n(ga),ya=r(9245),Va=r.n(ya);class Ma extends wt{constructor(e,n,r,a=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==a?a:5,this.cellBoost=r,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=Ve(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionLocalWrapMaterial"}static glslClass(){return pa()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Va()(this):fa()(this):this.usesUVMap?xa()(this):ba()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function _a(e,t,n,r){return new Ma(e,t,n,r)}var wa=r(7198),Sa=r.n(wa),Ta=r(1202),Ca=r.n(Ta),Da=r(2330),Ia=r.n(Da),Ra=r(588),Ea=r.n(Ra),ka=r(9040),Pa=r.n(ka),Ua=r(1365),Ba=r.n(Ua);class La extends St{constructor(e,n){super(),this.material=e,this.emission=void 0!==n.emission?n.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==n.volumeEmission?n.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==n.opticalDepth?n.opticalDepth:0,this.specular=void 0!==n.specular?n.specular:new t.Color(1,1,1),this.absorb=void 0!==n.absorb?n.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==n.ior?n.ior:1,this.roughness=void 0!==n.roughness?n.roughness:.2,this.reflectionChance=void 0!==n.reflectionChance?n.reflectionChance:.1,this.refractionChance=void 0!==n.refractionChance?n.refractionChance:0,this.diffuseChance=void 0!==n.diffuseChance?n.diffuseChance:.9;const r=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/r,this.refractionChance=this.refractionChance/r,this.diffuseChance=this.diffuseChance/r,this.addImport(Nt())}get uniformType(){return"PathTracerWrapMaterial"}static glslClass(){return Sa()}get usesUVMap(){return this.material.usesUVMap}glslRender(){let e="";return e+=Ca()(this),this.material.usesNormal?this.material.usesUVMap?e+=Ea()(this):e+=Pa()(this):this.material.usesUVMap?e+=Ba()(this):e+=Ia()(this),e}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e),super.shader(e)}}function Na(e,t={}){return new La(e,t)}var Ga=r(7939),Fa=r.n(Ga),Aa=r(6142),za=r.n(Aa),ja=r(7260),Ha=r.n(ja);class Oa extends Mt{constructor(e){super(),this.shape=e,this.shape.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData()}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Fa()(this)}glslGradient(){return za()(this)}glslUVMap(){return Ha()(this)}setId(e){this.shape.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),super.onAdd(e)}shader(e){this.shape.shader(e),super.shader(e)}}function qa(e){return new Oa(e)}var Wa=r(2093),Za=r.n(Wa),Xa=r(2076),Ya=r.n(Xa),Ka=r(3335),Qa=r.n(Ka),$a=r(6428),Ja=r.n($a),eo=r(6861),to=r.n(eo),no=r(2905),ro=r.n(no),ao=r(7333),oo=r.n(ao);const so=1;class io extends Mt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("IntersectionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.maxType=void 0!==n.maxType?n.maxType:0,this.maxCoeff=0,this.maxType===so)this.addImport(Za()),this.maxCoeff=void 0!==n.maxCoeff?n.maxCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"IntersectionShape"}static glslClass(){return oo()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.maxType===so?Ja()(this):Ya()(this)}glslGradient(){return this.maxType===so?to()(this):Qa()(this)}glslUVMap(){return ro()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function lo(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new io(e,arguments[r],t));return e}var co=r(5442),uo=r.n(co),ho=r(3908),po=r.n(ho),mo=r(7762),bo=r.n(mo),vo=r(7500),fo=r.n(vo),go=r(3238),xo=r.n(go),yo=r(519),Vo=r.n(yo),Mo=r(8655),_o=r.n(Mo);const wo=1;class So extends Mt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("UnionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.minType=void 0!==n.minType?n.minType:0,this.minCoeff=0,this.minType===wo)this.addImport(uo()),this.minCoeff=void 0!==n.minCoeff?n.minCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"UnionShape"}static glslClass(){return Vo()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.minType===wo?xo()(this):po()(this)}glslGradient(){return this.minType===wo?_o()(this):bo()(this)}glslUVMap(){return fo()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function To(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new So(e,arguments[r],t));return e}var Co=r(3105),Do=r.n(Co),Io=r(6242),Ro=r.n(Io),Eo=r(9338),ko=r.n(Eo);class Po extends Mt{constructor(e,t){if(e.isGlobal!==t.isGlobal)throw new Error("WrapShape: the two shapes should be both local or both global");super(),this.wrap=e,this.shape=t,this.shape.parent=this,this.wrap.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom(),this.wrap.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData(),this.wrap.updateData()}get isWrapShape(){return!0}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Do()(this)}glslGradient(){return Ro()(this)}glslUVMap(){return ko()(this)}setId(e){this.wrap.setId(e),this.shape.setId(e),super.setId(e)}onAdd(e){this.wrap.onAdd(e),this.shape.onAdd(e),super.onAdd(e)}shader(e){this.wrap.shader(e),this.shape.shader(e),super.shader(e)}}function Uo(e,t){return new Po(e,t)}const Bo={KeyA:"yawLeft",KeyD:"yawRight",KeyW:"pitchUp",KeyS:"pitchDown",KeyQ:"rollLeft",KeyE:"rollRight",ArrowUp:"forward",ArrowDown:"back",ArrowLeft:"left",ArrowRight:"right",Quote:"up",Slash:"down"};class Lo extends t.EventDispatcher{constructor(e){super(),this.camera=e,this.movementSpeed=.5,this.rollSpeed=.8,this._moveState={up:0,down:0,left:0,right:0,forward:0,back:0,pitchUp:0,pitchDown:0,yawLeft:0,yawRight:0,rollLeft:0,rollRight:0},this._moveVector=new s(0,0,0),this._rotationVector=new s(0,0,0),this._onKeyDown=xe(this,this.onKeyDown),this._onKeyUp=xe(this,this.onKeyUp),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}pause(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)}restore(){window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}onKeyDown(e){if(e.code in Bo){const t=Bo[e.code];this._moveState[t]=1,this.updateMovementVector(),this.updateRotationVector()}}onKeyUp(e){if(e.code in Bo){const t=Bo[e.code];this._moveState[t]=0,this.updateMovementVector(),this.updateRotationVector()}}updateMovementVector(){this._moveVector.x=-this._moveState.left+this._moveState.right,this._moveVector.y=-this._moveState.down+this._moveState.up,this._moveVector.z=-this._moveState.forward+this._moveState.back}updateRotationVector(){this._rotationVector.x=-this._moveState.pitchDown+this._moveState.pitchUp,this._rotationVector.y=-this._moveState.yawRight+this._moveState.yawLeft,this._rotationVector.z=-this._moveState.rollRight+this._moveState.rollLeft}update(e){const n=this._moveVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix);this.camera.position.flow(n);const r=this._rotationVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix),a=new t.Quaternion(r.x,r.y,r.z,1).normalize();this.camera.position.applyQuaternion(a)}}class No{constructor(e="i"){this.action=void 0,this.key=e;const t=xe(this,this.onKeyDown);window.addEventListener("keydown",t,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.action&&this.action()}}class Go{constructor(e,t,n){this.controller=e,this.camera=t,this.solid=n,this._isSelecting=!1,this._isSqueezing=!1;const r=xe(this,this.onSelectStart),a=xe(this,this.onSelectEnd),o=xe(this,this.onSqueezeStart),s=xe(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",r),this.controller.addEventListener("selectend",a),this.controller.addEventListener("squeezestart",o),this.controller.addEventListener("squeezeend",s)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}chase(e){this.solid.isRendered=this._isSelecting;const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[_e].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.solid.isom.copy(i.globalBoost),this.solid.isom.matrix.multiply(i.facing),this.solid.updateData()}}class Fo{constructor(e="p"){this.actionKeyDown=void 0,this.actionKeyUp=void 0,this.key=e;const t=xe(this,this.onKeyDown),n=xe(this,this.onKeyUp);window.addEventListener("keydown",t,!1),window.addEventListener("keyup",n,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.actionKeyDown&&this.actionKeyDown()}onKeyUp(e){e.key===this.key&&void 0!==this.actionKeyUp&&this.actionKeyUp()}}class Ao{constructor(e,n,r,a){this.controller=e,this.camera=n,this.solids=r,this.speed=a,this._status=0,this._nextBullet=0,this._clock=new t.Clock;const o=xe(this,this.onSelectStart),s=xe(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){0===this._status&&(this._status=1)}onSelectEnd(){}shoot(e){const t=this.solids[this._nextBullet];t.bulletData={time:this._clock.getElapsedTime(),position:e},t.isRendered=!0,this._nextBullet=(this._nextBullet+1)%this.solids.length}updateBullet(e){const t=this.solids[e];if(t.hasOwnProperty("bulletData")){const e=this._clock.getElapsedTime()-t.bulletData.time,n=t.bulletData.position.clone().flow(new s(0,0,-this.speed*e));t.isom.copy(n.boost),t.updateData()}}updateAllBullets(){for(let e=0;e<this.solids.length;e++)this.updateBullet(e)}update(e){if(1===this._status){const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[_e].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.shoot(i.globalPosition),this._status=0}this.updateAllBullets()}}class zo{constructor(e="p",t=2,n=0){this.key=e,this.stateNumber=t,this.state=n,this.justChanged=!1;const r=xe(this,this.onKeyDown);window.addEventListener("keydown",r,!1)}onKeyDown(e){e.key===this.key&&(this.state=(this.state+1)%this.stateNumber,this.justChanged=!0)}}class jo extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this._isSelecting=!1,this._isSqueezing=!1;const n=xe(this,this.onSelectStart),r=xe(this,this.onSelectEnd),a=xe(this,this.onSqueezeStart),o=xe(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}get update(){if(void 0===this._update){const e=10,n=new s,r=new s;let a=[],o=0,i=!1;this._update=function(l){const c=new s;if(this.controller.getWorldDirection(c),c.normalize().multiplyScalar(1/e),r.add(c),i&&r.sub(a[o]),a[o]=c,i&&this._isSelecting){const e=r.clone().normalize(),a=n.clone().normalize(),o=(new t.Quaternion).setFromUnitVectors(e,a).normalize();this.position.applyQuaternion(o)}n.copy(r),o=(o+1)%e,0===o&&(i=!0)}}return this._update}}class Ho extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this.movementSpeed=.5,this._isSelecting=!1,this._isSqueezing=!1;const n=xe(this,this.onSelectStart),r=xe(this,this.onSelectEnd),a=xe(this,this.onSqueezeStart),o=xe(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}update(e){if(this._isSelecting){const t=new s;this.controller.getWorldDirection(t),t.normalize().multiplyScalar(-this.movementSpeed*e),this.position.flow(t)}}}class Oo{constructor(e,t,n){this.controller=e,this.camera=t,this.light=n}chase(e){const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[_e].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),i=this.controller.matrixWorld.clone().setPosition(a),l=this.camera.position.clone().fakeDiffExpMap(i);this.light.position=(new o).applyIsometry(l.globalBoost)}}class qo{constructor(e,t,n=!1,r=!1,a=void 0){if(this.position=e,this.controller=t,this._reset=0,this._alignFacing=n,this._snap=r,this._camera=a,this._alignFacing&&void 0===a)throw new Error("VRControlsReset.constructor, the camera is needed when the alignFacing option is on");const o=xe(this,this.onSelectStart),s=xe(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){this._reset=1}onSelectEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0}}}class Wo{constructor(e,t,n,r=!1,a=!1,o=void 0){if(this.position=e,this.targetPosition=t,this.controller=n,this._reset=0,this._alignFacing=r,this._snap=a,this._camera=o,this._alignFacing&&void 0===o)throw new Error("AdvancedResetVRControls.constructor, the camera is needed when the alignFacing option is on");const s=xe(this,this.onSqueezeStart),i=xe(this,this.onSqueezeEnd);this.controller.addEventListener("squeezestart",s),this.controller.addEventListener("squeezeend",i)}onSqueezeStart(){this._reset=1}onSqueezeEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0,this.position.local.boost.copy(this.targetPosition.boost),this.position.local.quaternion.premultiply(this.targetPosition.quaternion)}}}var Zo=r(6947),Xo=r.n(Zo);class Yo extends X{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return Xo()}}var Ko=r(4024),Qo=r.n(Ko);class $o extends X{constructor(){super()}fragmentShader(){return Qo()}}class Jo{constructor(e,t=0,n=0){this.ring=e,this.a=t,this.b=n,this.reduce()}reduce(){return this.a=Math.round(this.a),this.b=Math.round(this.b),this}negate(){return this.a=-this.a,this.b=-this.b,this}multiply(e){const t=this.a,n=this.b;return this.a=t*e.a+this.ring.d*n*e.b,this.b=t*e.b+n*e.a,this.reduce()}add(e){return this.a=this.a+e.a,this.b=this.b+e.b,this.reduce()}sub(e){return this.a=this.a-e.a,this.b=this.b-e.b,this.reduce()}sum(){this.copy(this.ring.zero);for(const e of arguments)this.add(e);return this}product(){this.copy(this.ring.one);for(const e of arguments)this.multiply(e);return this}addProduct(){const e=new Jo(this.ring).product(...arguments);return this.add(e),this}subProduct(){const e=new Jo(this.ring).product(...arguments);return this.sub(e),this}toNumber(){return this.a+this.b*Math.sqrt(this.ring.d)}equals(e){return this.a===e.a&&this.b===e.b}isZero(){return 0===this.a&&0===this.b}clone(){const e=new Jo(this.ring);return e.a=this.a,e.b=this.b,e}copy(e){return this.a=e.a,this.b=e.b,this}toLog(){return`${this.a} + ${this.b} _rD`}}var es=r(5688),ts=r.n(es);class ns{constructor(e){this.ring=e,this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()]}get isQuadRingMatrix4(){return!0}get a(){const e=this.toArray().map((e=>e.a));return(new t.Matrix4).fromArray(e)}get b(){const e=this.toArray().map((e=>e.b));return(new t.Matrix4).fromArray(e)}getEntry(e,t){return this.elements[4*t+e]}setEntry(e,t,n){return this.elements[4*t+e].copy(n),this}set(e,t,n,r,a,o,s,i,l,c,d,u,h,p,m,b){for(let e=0;e<4;e++)for(let t=0;t<4;t++)this.setEntry(e,t,arguments[4*e+t]);return this}identity(){return this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()],this}multiplyMatrices(e,t){for(let n=0;n<4;n++)for(let r=0;r<4;r++){this.setEntry(n,r,this.ring.zero);for(let a=0;a<4;a++)this.getEntry(n,r).addProduct(e.getEntry(n,a),t.getEntry(a,r))}return this}multiply(e){return this.multiplyMatrices(this.clone(),e)}premultiply(e){return this.multiplyMatrices(e,this.clone())}multiplyScalar(e){for(let t=0;t<16;t++)this.elements[t].multiply(e);return this}transpose(){const e=this.elements;let t=this.ring.element();return t.copy(e[1]),e[1].copy(e[4]),e[4].copy(t),t.copy(e[2]),e[2].copy(e[8]),e[8].copy(t),t.copy(e[6]),e[6].copy(e[9]),e[9].copy(t),t.copy(e[3]),e[3].copy(e[12]),e[12].copy(t),t.copy(e[7]),e[7].copy(e[13]),e[13].copy(t),t.copy(e[11]),e[11].copy(e[14]),e[14].copy(t),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],a=e[3],o=e[4],s=e[5],i=e[6],l=e[7],c=e[8],d=e[9],u=e[10],h=e[11],p=e[12],m=e[13],b=e[14],v=e[15];return e[0]=this.ring.element().addProduct(d,b,l).subProduct(m,u,l).addProduct(m,i,h).subProduct(s,b,h).subProduct(d,i,v).addProduct(s,u,v),e[1]=this.ring.element().addProduct(m,u,a).subProduct(d,b,a).subProduct(m,r,h).addProduct(n,b,h).addProduct(d,r,v).subProduct(n,u,v),e[2]=this.ring.element().addProduct(s,b,a).subProduct(m,i,a).addProduct(m,r,l).subProduct(n,b,l).subProduct(s,r,v).addProduct(n,i,v),e[3]=this.ring.element().addProduct(d,i,a).subProduct(s,u,a).subProduct(d,r,l).addProduct(n,u,l).addProduct(s,r,h).subProduct(n,i,h),e[4]=this.ring.element().addProduct(p,u,l).subProduct(c,b,l).subProduct(p,i,h).addProduct(o,b,h).addProduct(c,i,v).subProduct(o,u,v),e[5]=this.ring.element().addProduct(c,b,a).subProduct(p,u,a).addProduct(p,r,h).subProduct(t,b,h).subProduct(c,r,v).addProduct(t,u,v),e[6]=this.ring.element().addProduct(p,i,a).subProduct(o,b,a).subProduct(p,r,l).addProduct(t,b,l).addProduct(o,r,v).subProduct(t,i,v),e[7]=this.ring.element().addProduct(o,u,a).subProduct(c,i,a).addProduct(c,r,l).subProduct(t,u,l).subProduct(o,r,h).addProduct(t,i,h),e[8]=this.ring.element().addProduct(c,m,l).subProduct(p,d,l).addProduct(p,s,h).subProduct(o,m,h).subProduct(c,s,v).addProduct(o,d,v),e[9]=this.ring.element().addProduct(p,d,a).subProduct(c,m,a).subProduct(p,n,h).addProduct(t,m,h).addProduct(c,n,v).subProduct(t,d,v),e[10]=this.ring.element().addProduct(o,m,a).subProduct(p,s,a).addProduct(p,n,l).subProduct(t,m,l).subProduct(o,n,v).addProduct(t,s,v),e[11]=this.ring.element().addProduct(c,s,a).subProduct(o,d,a).subProduct(c,n,l).addProduct(t,d,l).addProduct(o,n,h).subProduct(t,s,h),e[12]=this.ring.element().addProduct(p,d,i).subProduct(c,m,i).subProduct(p,s,u).addProduct(o,m,u).addProduct(c,s,b).subProduct(o,d,b),e[13]=this.ring.element().addProduct(c,m,r).subProduct(p,d,r).addProduct(p,n,u).subProduct(t,m,u).subProduct(c,n,b).addProduct(t,d,b),e[14]=this.ring.element().addProduct(p,s,r).subProduct(o,m,r).subProduct(p,n,i).addProduct(t,m,i).addProduct(o,n,b).subProduct(t,s,b),e[15]=this.ring.element().addProduct(o,d,r).subProduct(c,s,r).addProduct(c,n,i).subProduct(t,d,i).subProduct(o,n,u).addProduct(t,s,u),this}equals(e){for(let t=0;t<16;t++)if(!this.elements[t].equals(e.elements[t]))return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n].copy(e[n+t]);return this}toArray(e=[],t=0){const n=this.elements;for(let r=0;r<16;r++)e[t+r]=n[r].clone();return e}toMatrix4(){const e=this.toArray().map((e=>e.toNumber()));return(new t.Matrix4).fromArray(e)}clone(){return new ns(this.ring).fromArray(this.elements)}copy(e){return this.fromArray(e.elements)}toLog(){return this.toMatrix4().toLog()}}class rs{constructor(e){this.d=e}element(e=0,t=0){return new Jo(this,e,t)}matrix4(){return new ns(this)}get one(){return new Jo(this,1)}get zero(){return new Jo(this,0)}shader(e){e.addChunk(ts()),e.addConstant("QUAD_RING_D","int",this.d)}}class as{constructor(){this.elements=[1,0,0,1]}set(e,t,n,r){return this.elements=[e,n,t,r],this}identity(){return this.set(1,0,0,1),this}multplyMatrices(e,t){const[n,r,a,o]=e.elements,[s,i,l,c]=t.elements;return this.elements=[n*s+a*i,r*s+o*i,n*l+a*c,r*l+o*c],this}multiply(e){return this.multplyMatrices(this,e)}premultiply(e){return this.multplyMatrices(e,this)}power(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}}determinant(){const[e,t,n,r]=this.elements;return e*r-n*t}invert(){const[e,t,n,r]=this.elements,a=this.determinant();return this.elements=[r/a,-t/a,-n/a,e/a],this}clone(){const e=new as;for(let t=0;t<4;t++)e.elements[t]=this.elements[t];return e}copy(e){for(let t=0;t<4;t++)this.elements[t]=e.elements[t];return this}equals(e){for(let t=0;t<4;t++)if(this.elements[t]!==e.elements[t])return!1;return!0}}class os extends Se{constructor(e){super(e),this.isom=new n}identity(){return this.isom.identity(),this}multiply(e){return this.isom.multiply(e.isom),this}premultiply(e){return this.isom.premultiply(e.isom),this}invert(){return this.isom.invert(),this}toIsometry(){return this.isom.clone()}equals(e){return this.isom.equals(e.isom)}clone(){const e=new os;return e.isom.copy(this.isom),e}copy(e){return this.isom.copy(e.isom),this}}var ss=r(6097),is=r.n(ss);class ls extends Qe{constructor(){super()}element(){return new os(this)}shader(e){e.addChunk(is())}}class cs extends Se{constructor(e,n=0,r=0,a=0){super(e),this.coords=new t.Vector3(n,r,a),this.matrix=ms.clone().power(a)}identity(){return this.coords.set(0,0,0),this.matrix.identity(),this}multiply(e){return this.coords.add(e.coords.clone().applyMatrix3(this.matrix)),this.matrix.multiply(e.matrix),this}premultiply(e){return this.coords.applyMatrix3(e.matrix).add(e.coords),this.matrix.premultiply(e.matrix),this}invert(){return this.matrix.invert(),this.coords.applyMatrix3(this.matrix).negate(),this}toIsometry(){const[e,t,r]=this.coords.toArray(),a=new o((e*bs+t)*this.group.length*vs,(t*bs-e)*this.group.length*vs,r*fs,1);return(new n).makeTranslation(a)}equals(e){return this.coords.equals(e.coords)}clone(){const e=new cs(this.group);return e.coords.copy(this.coords),e.matrix.copy(this.matrix),e}copy(e){return this.coords.copy(e.coords),this.matrix.copy(e.matrix),this}}var ds=r(607),us=r.n(ds),hs=r(7802),ps=r.n(hs);const ms=(new t.Matrix3).set(2,1,0,1,1,0,0,0,1),bs=.5*(1+Math.sqrt(5)),vs=1/(bs+2),fs=2*Math.log(bs);const gs=new ls,xs=new t.Vector4(bs,-1,0,0),ys=new t.Vector4(1,bs,0,0),Vs=new t.Vector4(0,0,1/fs,0);const Ms=`//\nbool testXp(Point p){\n    vec4 normal = vec4(${bs}, -1, 0, 0);\n    return dot(p.coords, normal) > 0.5;\n}\n`;const _s=`//\nbool testXn(Point p){\n    vec4 normal = vec4(${bs}, -1, 0, 0);\n    return dot(p.coords, normal) < -0.5;\n}\n`;const ws=`//\nbool testYp(Point p){\n    vec4 normal = vec4(1, ${bs}, 0, 0);\n    return dot(p.coords, normal) > 0.5;\n}\n`;const Ss=`//\nbool testYn(Point p){\n    vec4 normal = vec4(1, ${bs}, 0, 0);\n    return dot(p.coords, normal) < -0.5;\n}\n`;const Ts=`//\nbool testZp(Point p){\n    vec4 normal = vec4(0, 0, ${1/fs}, 0);\n    return dot(p.coords, normal) > 0.5;\n}\n`;const Cs=`//\nbool testZn(Point p){\n    vec4 normal = vec4(0, 0, ${1/fs}, 0);\n    return dot(p.coords, normal) < -0.5;\n}\n`,Ds=gs.element(),Is=gs.element(),Rs=gs.element(),Es=gs.element(),ks=gs.element(),Ps=gs.element();Ds.isom.makeTranslation(new o(-bs*vs,vs,0,1)),Is.isom.makeTranslation(new o(bs*vs,-vs,0,1)),Rs.isom.makeTranslation(new o(-vs,-bs*vs,0,1)),Es.isom.makeTranslation(new o(vs,bs*vs,0,1)),ks.isom.makeTranslation(new o(0,0,-fs,1)),Ps.isom.makeTranslation(new o(0,0,fs,1));const Us=(new vt).add((function(e){return e.coords.dot(Vs)>.5}),Ts,ks,Ps,"//\nfloat creepZp(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    return 0.5 - coords.z + offset;\n}\n").add((function(e){return e.coords.dot(Vs)<-.5}),Cs,Ps,ks,"//\nfloat creepZn(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    return 0.5 + coords.z + offset;\n}\n").add((function(e){return e.coords.dot(xs)>.5}),Ms,Ds,Is).add((function(e){return e.coords.dot(xs)<-.5}),_s,Is,Ds).add((function(e){return e.coords.dot(ys)>.5}),ws,Rs,Es).add((function(e){return e.coords.dot(ys)<-.5}),Ss,Es,Rs),Bs=new class extends Qe{constructor(e=1){super(),this.length=e}element(){return new cs(this,arguments.length>0?arguments[0]:0,arguments.length>1?arguments[1]:0,arguments.length>2?arguments[2]:0)}shader(e){e.addChunk(us()),e.addUniform("group","Group",this),e.addChunk(ps())}},Ls=new t.Vector4(bs,-1,0,0),Ns=new t.Vector4(1,bs,0,0),Gs=new t.Vector4(0,0,1/fs,0);const Fs=`//\nbool testXp(Point p){\n    vec4 normal = vec4(${bs}, -1, 0, 0);\n    return dot(p.coords, normal) > 0.5 * group.length;\n}\n`;const As=`//\nbool testXn(Point p){\n    vec4 normal = vec4(${bs}, -1, 0, 0);\n    return dot(p.coords, normal) < -0.5 * group.length;\n}\n`;const zs=`//\nbool testYp(Point p){\n    vec4 normal = vec4(1, ${bs}, 0, 0);\n    return dot(p.coords, normal) > 0.5 * group.length;\n}\n`;const js=`//\nbool testYn(Point p){\n    vec4 normal = vec4(1, ${bs}, 0, 0);\n    return dot(p.coords, normal) < -0.5 * group.length;\n}\n`;const Hs=`//\nbool testZp(Point p){\n    vec4 normal = vec4(0, 0, ${1/fs}, 0);\n    return dot(p.coords, normal) > 0.5;\n}\n`;const Os=`//\nbool testZn(Point p){\n    vec4 normal = vec4(0, 0, ${1/fs}, 0);\n    return dot(p.coords, normal) < -0.5;\n}\n`,qs=Bs.element(-1,0,0),Ws=Bs.element(1,0,0),Zs=Bs.element(0,-1,0),Xs=Bs.element(0,1,0),Ys=Bs.element(0,0,-1),Ks=Bs.element(0,0,1),Qs=(new vt).add((function(e){return e.coords.dot(Ls)>.5*Bs.length}),Fs,qs,Ws).add((function(e){return e.coords.dot(Ls)<-.5*Bs.length}),As,Ws,qs).add((function(e){return e.coords.dot(Ns)>.5*Bs.length}),zs,Zs,Xs).add((function(e){return e.coords.dot(Ns)<-.5*Bs.length}),js,Xs,Zs).add((function(e){return e.coords.dot(Gs)>.5}),Hs,Ys,Ks).add((function(e){return e.coords.dot(Gs)<-.5}),Os,Ks,Ys);r(1360);const $s=.5*(1+Math.sqrt(5)),Js=1/($s+2);const ei=new ls,ti=new t.Vector4($s,-1,0,0),ni=new t.Vector4(1,$s,0,0);const ri=`//\nbool testXp(Point p){\n    vec4 normal = vec4(${$s}, -1, 0, 0);\n    return dot(p.coords, normal) > 0.5;\n}\n`;const ai=`//\nbool testXn(Point p){\n    vec4 normal = vec4(${$s}, -1, 0, 0);\n    return dot(p.coords, normal) < -0.5;\n}\n`;const oi=`//\nbool testYp(Point p){\n    vec4 normal = vec4(1, ${$s}, 0, 0);\n    return dot(p.coords, normal) > 0.5;\n}\n`;const si=`//\nbool testYn(Point p){\n    vec4 normal = vec4(1, ${$s}, 0, 0);\n    return dot(p.coords, normal) < -0.5;\n}\n`,ii=ei.element(),li=ei.element(),ci=ei.element(),di=ei.element();ii.isom.makeTranslation(new o(-$s*Js,Js,0,1)),li.isom.makeTranslation(new o($s*Js,-Js,0,1)),ci.isom.makeTranslation(new o(-Js,-$s*Js,0,1)),di.isom.makeTranslation(new o(Js,$s*Js,0,1));const ui=(new vt).add((function(e){return e.coords.dot(ti)>.5}),ri,ii,li).add((function(e){return e.coords.dot(ti)<-.5}),ai,li,ii).add((function(e){return e.coords.dot(ni)>.5}),oi,ci,di).add((function(e){return e.coords.dot(ni)<-.5}),si,di,ci),hi=new ls,pi=1.01;const mi=hi.element(),bi=hi.element(),vi=Math.exp(pi),fi=Math.exp(-1.01);mi.isom.matrix.set(fi,0,0,0,0,vi,0,0,0,0,1,-1.01,0,0,0,1),bi.isom.matrix.set(vi,0,0,0,0,fi,0,0,0,0,1,pi,0,0,0,1);const gi=(new vt).add((function(e){return e.coords.z>.505}),"//\nbool testZp(Point p){\n    return p.coords.z > 0.505;\n}\n",mi,bi,"//\nfloat creepZp(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    return 0.505 - coords.z + offset;\n}\n").add((function(e){return e.coords.z<-.505}),"//\nbool testZn(Point p){\n    return p.coords.z < -0.505;\n}\n",bi,mi,"//\nfloat creepZn(ExtVector v, float offset){\n    vec4 coords = v.vector.local.pos.coords;\n    return 0.505 + coords.z + offset;\n}\n");class xi extends Se{constructor(e,n=0,r=0){super(e),this.coords=new t.Vector2(n,r)}identity(){return this.coords.set(0,0),this}multiply(e){return this.coords.add(e.coords),this}premultiply(e){return this.coords.add(e.coords),this}invert(){return this.coords.negate(),this}toIsometry(){const[e,t]=this.coords.toArray(),r=new o(e*this.group.dirA.x+t*this.group.dirB.x,e*this.group.dirA.y+t*this.group.dirB.y,0,1);return(new n).makeTranslation(r)}equals(e){return this.coords.equals(e.coords)}clone(){const e=new xi(this.group);return e.coords.copy(this.coords),e}copy(e){return this.coords.copy(e.coords),this}}var yi=r(9136),Vi=r.n(yi),Mi=r(5846),_i=r.n(Mi);const wi=new class extends Qe{constructor(e,t){super(),this._dirA=e,this._dirB=t,this.updateDotMatrix()}get dirA(){return this._dirA}set dirA(e){this._dirA=void 0!==e?e:new t.Vector4(1,0,0,0),this.updateDotMatrix()}get dirB(){return this._dirB}set dirB(e){this._dirB=void 0!==e?e:new t.Vector4(0,1,0,0),this.updateDotMatrix()}updateDotMatrix(){void 0===this._dotMatrix&&(this._dotMatrix=new t.Matrix4);const e=(new t.Matrix4).set(this.dirA.x,this.dirB.x,0,0,this.dirA.y,this.dirB.y,0,0,0,0,1,0,0,0,0,1).invert();this._dotMatrix.copy(e).transpose().multiply(e)}get dotMatrix(){return this._dotMatrix}element(){return new xi(this,arguments.length>0?arguments[0]:0,arguments.length>1?arguments[1]:0)}shader(e){e.addChunk(_i()),e.addUniform("group","Group",this),e.addChunk(Vi())}}(new t.Vector4(1,0,0,0),new t.Vector4(0,1,0,0));const Si=wi.element(-1,0),Ti=wi.element(1,0),Ci=wi.element(0,-1),Di=wi.element(0,1),Ii=(new vt).add((function(e){const t=wi.dirA.clone().applyMatrix4(wi.dotMatrix);return e.coords.dot(t)>1}),"//\nbool testAp(Point p){\n    return dot(p.coords, group.dotMatrix * group.dirA) > 0.5;\n}\n",Si,Ti).add((function(e){const t=wi.dirA.clone().applyMatrix4(wi.dotMatrix);return e.coords.dot(t)<-1}),"//\nbool testAn(Point p){\n    return dot(p.coords, group.dotMatrix * group.dirA) < -0.5;\n}\n",Ti,Si).add((function(e){const t=wi.dirB.clone().applyMatrix4(wi.dotMatrix);return e.coords.dot(t)>1}),"//\nbool testBp(Point p){\n    return dot(p.coords, group.dotMatrix * group.dirB) > 0.5;\n}\n",Ci,Di).add((function(e){const t=wi.dirB.clone().applyMatrix4(wi.dotMatrix);return e.coords.dot(t)<-1}),"//\nbool testBn(Point p){\n    return dot(p.coords, group.dotMatrix * group.dirB) < -0.5;\n}\n",Di,Ci);var Ri=r(6010),Ei=r.n(Ri),ki=r(7577),Pi=r.n(ki);class Ui extends _t{constructor(e,t=1,n=1){super(1),this.color=e,this.intensity=t,this.direction=n}get isGlobal(){return!0}get uniformType(){return"ZSun"}static glslClass(){return Ei()}glslDirections(){return Pi()(this)}}var Bi=r(3573),Li=r.n(Bi);class Ni extends _t{constructor(e,t=1,n){super(1),this.color=e,this.intensity=t,this.direction=n}get isGlobal(){return!0}get uniformType(){return"ConstDirLight"}static glslClass(){return Li()}glslDirections(){return Pi()(this)}}var Gi=r(3019),Fi=r.n(Gi);class Ai extends _t{constructor(e,t=1,n){super(1),this.color=e,this.intensity=t,this.position=n}get isGlobal(){return!0}get uniformType(){return"LocalFakePointLight"}static glslClass(){return Fi()}glslDirections(){return Pi()(this)}}var zi=r(3275),ji=r.n(zi);class Hi extends wt{constructor(e,t){super(),this.mainColor=e,this.weight=t}get uniformType(){return"VaryingColorMaterial"}get usesNormal(){return!1}static glslClass(){return ji()}glslRender(){return Rt()(this)}}var Oi=r(1228),qi=r.n(Oi);class Wi extends wt{constructor(e,n,r,a=void 0){super(),this.t=e,this.n=n;const o=void 0!==a?a:[.5,1,1,.5];let s=0;const i=[];for(let e=0;e<4;e++)void 0!==o[e]&&(s+=o[e]),i[e]=s;for(let e=0;e<4;e++)i[e]=i[e]/s;this.lengths=new t.Vector4(...i);let l=new t.Color(1,1,1);this.color0=void 0!==r[0]?r[0]:l.clone(),l=this.color0,this.color1=void 0!==r[1]?r[1]:l.clone(),l=this.color1,this.color2=void 0!==r[2]?r[2]:l.clone(),l=this.color2,this.color3=void 0!==r[3]?r[3]:l.clone()}get uniformType(){return"NaryMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return qi()}glslRender(){return on()(this)}}var Zi=r(8803),Xi=r.n(Zi);class Yi extends wt{constructor(e,n,r,a=void 0,o=void 0){super(),this.t=e,this.n=n;let s=void 0!==a?a:[.5,1,1,.5],i=0,l=[];for(let e=0;e<4;e++)void 0!==s[e]&&(i+=s[e]),l[e]=i;for(let e=0;e<4;e++)l[e]=l[e]/i;this.heights=new t.Vector4(...l),l=void 0!==o?o:[1,2,3],this.widths=new t.Vector3(...l);let c=new t.Color(1,1,1);this.color0=void 0!==r[0]?r[0]:c.clone(),c=this.color0,this.color1=void 0!==r[1]?r[1]:c.clone(),c=this.color1,this.color2=void 0!==r[2]?r[2]:c.clone(),c=this.color2,this.color3=void 0!==r[3]?r[3]:c.clone()}get uniformType(){return"NaryMaterialEquidistant"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return Xi()}glslRender(){return on()(this)}}var Ki=r(5238),Qi=r.n(Ki);class $i extends wt{constructor(e,t,n,r,a){super(),this.mainColor=e,this.accent1=t,this.accent2=n,this.accent3=r,this.grid=null!=a&&a}get uniformType(){return"MultiColorMaterial"}get usesNormal(){return!1}static glslClass(){return Qi()}glslRender(){return Rt()(this)}}var Ji=r(2361),el=r.n(Ji),tl=r(3707),nl=r.n(tl),rl=r(5030),al=r.n(rl);class ol extends Vt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");r.makeTranslation(e)}super(r),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!0}get isFakeBallShape(){return!0}get uniformType(){return"FakeBallShape"}static glslClass(){return el()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}}var sl=r(6290),il=r.n(sl),ll=r(4355),cl=r.n(ll);class dl extends Vt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");r.makeTranslation(e)}super(r),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get hasUVMap(){return!0}get isFakeBallShape(){return!0}get uniformType(){return"LocalFakeBallShape"}static glslClass(){return il()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var ul=r(5239),hl=r.n(ul);class pl extends Vt{constructor(e){super(e),this._origin=void 0,this._test=void 0,this._uDir=void 0,this._vDir=void 0}updateData(){super.updateData(),this._origin=(new o).applyIsometry(this.absoluteIsom);const e=(new t.Matrix4).copy(this.absoluteIsomInv.matrix).transpose();this._test=new t.Vector4(0,0,1,0).applyMatrix4(e),this._uDir=new s(1,0,0).applyMatrix4(this.absoluteIsom.matrix),this._vDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix)}get origin(){return void 0===this._origin&&this.updateData(),this._origin}get test(){return void 0===this._test&&this.updateData(),this._test}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return void 0===this._vDir&&this.updateData(),this._vDir}get isGlobal(){return!0}get isZHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"ZHalfSpaceShape"}static glslClass(){return hl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var ml=r(3980),bl=r.n(ml);class vl extends Vt{constructor(e){super(e),this._origin=void 0,this._testX=void 0,this._testZ=void 0,this._uDir=void 0,this._vDir=void 0}updateData(){super.updateData(),this._origin=(new o).applyIsometry(this.absoluteIsom);const e=(new t.Matrix4).copy(this.absoluteIsomInv.matrix).transpose();this._testX=new t.Vector4(1,0,0,0).applyMatrix4(e),this._testZ=new t.Vector4(0,0,1,0).applyMatrix4(e),this._uDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix),this._vDir=new s(0,0,1).applyMatrix4(this.absoluteIsom.matrix)}get origin(){return void 0===this._origin&&this.updateData(),this._origin}get testX(){return void 0===this._testX&&this.updateData(),this._testX}get testZ(){return void 0===this._testZ&&this.updateData(),this._testZ}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return void 0===this._vDir&&this.updateData(),this._vDir}get isGlobal(){return!0}get isXYHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"XHalfSpaceShape"}static glslClass(){return bl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var fl=r(9583),gl=r.n(fl);class xl extends Vt{constructor(e){super(e),this._origin=void 0,this._test=void 0,this._uDir=void 0,this._vDir=void 0}updateData(){super.updateData(),this._origin=(new o).applyIsometry(this.absoluteIsom);const e=(new t.Matrix4).copy(this.absoluteIsomInv.matrix).transpose();this._test=new t.Vector4(0,0,1,0).applyMatrix4(e),this._uDir=new s(1,0,0).applyMatrix4(this.absoluteIsom.matrix),this._vDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix)}get origin(){return void 0===this._origin&&this.updateData(),this._origin}get test(){return void 0===this._test&&this.updateData(),this._test}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return void 0===this._vDir&&this.updateData(),this._vDir}get isGlobal(){return!1}get isLocalZHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"LocalZHalfSpaceShape"}static glslClass(){return gl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var yl=r(1273),Vl=r.n(yl);class Ml extends Vt{constructor(e){super(e),this._origin=void 0,this._testX=void 0,this._testZ=void 0,this._uDir=void 0,this._vDir=void 0}updateData(){super.updateData(),this._origin=(new o).applyIsometry(this.absoluteIsom);const e=(new t.Matrix4).copy(this.absoluteIsomInv.matrix).transpose();this._testX=new t.Vector4(1,0,0,0).applyMatrix4(e),this._testZ=new t.Vector4(0,0,1,0).applyMatrix4(e),this._uDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix),this._vDir=new s(0,0,1).applyMatrix4(this.absoluteIsom.matrix)}get origin(){return void 0===this._origin&&this.updateData(),this._origin}get testX(){return void 0===this._testX&&this.updateData(),this._testX}get testZ(){return void 0===this._testZ&&this.updateData(),this._testZ}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return void 0===this._vDir&&this.updateData(),this._vDir}get isGlobal(){return!1}get isLocalXHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"LocalXHalfSpaceShape"}static glslClass(){return Vl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var _l=r(9277),wl=r.n(_l);class Sl extends Vt{constructor(e,r,a=.01){const o=new n;if(e.isIsometry)o.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");o.makeTranslation(e)}super(o),r.isVector3?this.sides=r.clone():this.sides=new t.Vector3(r,r,r),this.addImport(Za()),this.smoothness=a,this._origin=void 0,this._testX=void 0,this._testY=void 0,this._testZ=void 0}updateData(){super.updateData(),this._origin=(new o).applyIsometry(this.absoluteIsom);const e=(new t.Matrix4).copy(this.absoluteIsomInv.matrix).transpose();this._testX=new t.Vector4(1,0,0,0).applyMatrix4(e),this._testY=new t.Vector4(0,1,0,0).applyMatrix4(e),this._testZ=new t.Vector4(0,0,1,0).applyMatrix4(e)}get testX(){return void 0===this._testX&&this.updateData(),this._testX}get testY(){return void 0===this._testY&&this.updateData(),this._testY}get testZ(){return void 0===this._testZ&&this.updateData(),this._testZ}get isGlobal(){return!1}get isLocalCube(){return!0}get uniformType(){return"LocalCube"}static glslClass(){return wl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}}var Tl=r(6316),Cl=r.n(Tl);class Dl extends Vt{constructor(e,r,a=.01){const o=new n;if(e.isIsometry)o.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");o.makeTranslation(e)}super(o),r.isVector2?this.sides=r.clone():this.sides=new t.Vector2(r,r),this.addImport(Za()),this.smoothness=a}get isGlobal(){return!1}get isLocalZAxisShape(){return!0}get uniformType(){return"LocalZAxisShape"}get hasUVMap(){return!0}static glslClass(){return Cl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var Il=r(4090),Rl=r.n(Il);class El extends Vt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("FakeBallShape: the type of location is not implemented");r.makeTranslation(e)}super(r),this.radius=t}get isGlobal(){return!1}get isLocalXAxisShape(){return!0}get uniformType(){return"LocalXAxisShape"}get hasUVMap(){return!0}static glslClass(){return Rl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var kl=r(5201),Pl=r.n(kl);class Ul extends Vt{constructor(e,t){super(e),this._origin=void 0,this._test=void 0,this._uDir=void 0,this._vDir=void 0,this.thickness=t}updateData(){super.updateData(),this._origin=(new o).applyIsometry(this.absoluteIsom);const e=(new t.Matrix4).copy(this.absoluteIsomInv.matrix).transpose();this._test=new t.Vector4(0,0,1,0).applyMatrix4(e),this._uDir=new s(1,0,0).applyMatrix4(this.absoluteIsom.matrix),this._vDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix)}get origin(){return void 0===this._origin&&this.updateData(),this._origin}get test(){return void 0===this._test&&this.updateData(),this._test}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return void 0===this._vDir&&this.updateData(),this._vDir}get isGlobal(){return!1}get isLocalZHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"LocalZSlabShape"}static glslClass(){return Pl()}glslSDF(){return nl()(this)}glslGradient(){return al()(this)}glslUVMap(){return cl()(this)}}var Bl=r(7499),Ll=r.n(Bl);class Nl extends ft{constructor(e,t,n=void 0){if(!e.hasUVMap){if(t.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map");if(void 0!==n&&n.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map")}super(),this.shape=e,this.material=t,this.ptMaterial=n,this.isRendered=!0,this.addImport(Ll())}get isSolid(){return!0}get isom(){return this.shape.isom}get absoluteIsom(){return this.shape.absoluteIsom}get isGlobal(){return this.shape.isGlobal}get isLocal(){return this.shape.isLocal}get uniformType(){return"Solid"}updateData(){this.shape.updateData()}setId(e){this.shape.setId(e),this.material.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),this.material.onAdd(e),super.onAdd(e)}static glslClass(){return""}glslInstance(){return`\n            bool ${this.name}_isRenderedHack = true;\n        `}shader(e){this.shape.shader(e),3===e.useCase&&void 0!==this.ptMaterial?this.ptMaterial.shader(e):this.material.shader(e),super.shader(e)}}class Gl extends Nl{constructor(e,t,n,r=void 0){super(new ol(e,t),n,r)}}class Fl extends Nl{constructor(e,t,n,r=void 0){super(new dl(e,t),n,r)}}class Al extends Nl{constructor(e,t,n=void 0){super(new pl(e),t,n)}}class zl extends Nl{constructor(e,t,n=void 0){super(new vl(e),t,n)}}class jl extends Nl{constructor(e,t,n=void 0){super(new xl(e),t,n)}}class Hl extends Nl{constructor(e,t,n=void 0){super(new xl(e),t,n)}}class Ol extends Nl{constructor(e,t,n,r,a=void 0){super(new Sl(e,t,n),r,a)}}class ql extends Nl{constructor(e,t,n,r,a=void 0){super(new Dl(e,t,n),r,a)}}class Wl extends Nl{constructor(e,t,n,r=void 0){super(new El(e,t),n,r)}}class Zl extends Nl{constructor(e,t,n,r=void 0){super(new Zl(e,t),n,r)}}p.prototype.constructor.shader1=d(),p.prototype.constructor.shader2=h()})();var o=a.T0,s=a.FJ,i=a.GU,l=a.XH,c=a.ZH,d=a.K9,u=a.FT,h=a.cK,p=a._x,m=a.kj,b=a.V1,v=a.Vz,f=a.ck,g=a.Iy,x=a.Vf,y=a.TB,V=a.Al,M=a.ix,_=a.jZ,w=a.c$,S=a.OZ,T=a.Ao,C=a.Qj,D=a.mD,I=a.yb,R=a.iJ,E=a.ZA,k=a.Jz,P=a.fR,U=a.kK,B=a.ZX,L=a._f,N=a.Ht,G=a.HZ,F=a.TN,A=a.JV,z=a.Sc,j=a.Nh,H=a.RL,O=a._k,q=a.uR,W=a.gU,Z=a.EB,X=a.Zs,Y=a.oR,K=a.lt,Q=a._r,$=a.vh,J=a.NM,ee=a.EA,te=a.Bm,ne=a.b_,re=a.YE,ae=a.Qc,oe=a.Q9,se=a.oE,ie=a._V,le=a.F5,ce=a.Uc,de=a.Fh,ue=a.O5,he=a.Pe,pe=a.Wp,me=a.oB,be=a.pJ,ve=a.GW,fe=a.DZ,ge=a._K,xe=a.JF,ye=a.Lv,Ve=a.E9,Me=a.Ly,_e=a.jo,we=a.mH,Se=a.xd,Te=a.pX,Ce=a.Dz,De=a.Th,Ie=a.Uj,Re=a.bY,Ee=a.cV,ke=a.lR,Pe=a.xs,Ue=a.bn,Be=a.oC,Le=a.Z1,Ne=a.h8,Ge=a.Qf,Fe=a.jE,Ae=a.k1,ze=a.ew,je=a.$p,He=a.xG,Oe=a.l_,qe=a.pk,We=a.yI,Ze=a.E6,Xe=a.zO,Ye=a.cB,Ke=a.OW,Qe=a.n3,$e=a.Se,Je=a.PQ,et=a.$9,tt=a.D_,nt=a.qT,rt=a.JX,at=a.fr,ot=a.t2,st=a.ak,it=a.uZ,lt=a.Cy,ct=a.qM,dt=a.mV,ut=a.Gi,ht=a.M3,pt=a.jV,mt=a.jS,bt=a.ur,vt=a.j9,ft=a.oc,gt=a.wS,xt=a.IJ,yt=a.p2,Vt=a.w0,Mt=a.VL,_t=a.UR,wt=a.dV,St=a.G0,Tt=a.YL,Ct=a.re,Dt=a.QG,It=a.xS;export{o as AcesFilmPostProcess,s as AdvancedResetVRControls,i as AdvancedShape,l as BOTH,c as BasicPTMaterial,d as BasicRenderer,u as BasicShape,h as CREEPING_FULL,p as CREEPING_OFF,m as CREEPING_STRICT,b as Camera,v as CheckerboardMaterial,f as CombinedPostProcess,g as ComplementShape,x as ConstDirLight,y as DebugMaterial,V as DragVRControls,M as EquidistantHypStripsMaterial,_ as EquidistantSphStripsMaterial,w as ExpFog,S as FakeBall,T as FakeBallShape,C as FlatCamera,D as FlyControls,I as Fog,R as GraphPaperMaterial,E as Group,k as GroupElement,P as HighlightLocalWrapMaterial,U as HighlightWrapMaterial,B as HypStripsMaterial,L as ImprovedEquidistantHypStripsMaterial,N as ImprovedEquidistantSphStripsMaterial,G as InfoControls,F as IntersectionShape,A as Isometry,z as IsotropicChaseVRControls,j as KeyGenericControls,H as LEFT,O as Light,q as LightVRControls,W as LinearToSRGBPostProcess,Z as LocalCube,X as LocalCubeShape,Y as LocalFakeBall,K as LocalFakeBallShape,Q as LocalFakePointLight,$ as LocalXAxis,J as LocalXAxisShape,ee as LocalXHalfSpace,te as LocalXHalfSpaceShape,ne as LocalZAxis,re as LocalZAxisShape,ae as LocalZHalfSpace,oe as LocalZHalfSpaceShape,se as LocalZSlab,ie as LocalZSlabShape,le as Material,ce as Matrix2,de as MoveVRControls,ue as MultiColorMaterial,he as NaryEquidistantMaterial,pe as NaryMaterial,me as NormalMaterial,be as PTMaterial,ve as PathTracerCamera,fe as PathTracerRenderer,ge as PathTracerWrapMaterial,xe as PhongMaterial,ye as PhongWrapMaterial,Ve as Point,Me as Position,_e as QuadRing,we as QuadRingElement,Se as QuadRingMatrix4,Te as RIGHT,Ce as RelPosition,De as Renderer,Ie as ResetVRControls,Re as RotatedSphericalTextureMaterial,Ee as SMOOTH_MAX_POLY,ke as SMOOTH_MIN_POLY,Pe as Scene,Ue as Shape,Be as ShootVRControls,Le as SimpleTextureMaterial,Ne as SingleColorMaterial,Ge as Solid,Fe as SphereCamera,Ae as SquaresMaterial,ze as StripsMaterial,je as SwitchControls,He as TeleportationSet,Oe as TransitionLocalWrapMaterial,qe as TransitionWrapMaterial,We as UnionShape,Ze as VRCamera,Xe as VRRenderer,Ye as VaryingColorMaterial,Ke as Vector,Qe as VideoAlphaTextureMaterial,$e as VideoFrameTextureMaterial,Je as VideoTextureMaterial,et as WrapShape,tt as XHalfSpace,nt as XHalfSpaceShape,rt as ZHalfSpace,at as ZHalfSpaceShape,ot as ZSun,st as bind,it as clamp,lt as complement,ct as earthTexture,dt as highlightLocalWrap,ut as highlightWrap,ht as horizontalSet,pt as intersection,mt as mappingTorusSet,bt as mappingTorusSymbSet,vt as marsTexture,ft as moonTexture,gt as pathTracerWrap,xt as phongWrap,yt as safeString,Vt as sunTexture,Mt as transitionLocalWrap,_t as transitionWrap,wt as trivialSet,St as union,Tt as woodBallMaterial,Ct as wrap,Dt as xyLoopSet,It as zLoopSet};