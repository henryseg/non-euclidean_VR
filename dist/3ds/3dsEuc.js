import*as e from"three";var t={9397:(e,t)=>{!function(e){var t=/\S/,n=/\"/g,r=/\n/g,a=/\r/g,o=/\\/g,s=/\u2028/,i=/\u2029/;function l(e){"}"===e.n.substr(e.n.length-1)&&(e.n=e.n.substring(0,e.n.length-1))}function c(e){return e.trim?e.trim():e.replace(/^\s*|\s*$/g,"")}function d(e,t,n){if(t.charAt(n)!=e.charAt(0))return!1;for(var r=1,a=e.length;r<a;r++)if(t.charAt(n+r)!=e.charAt(r))return!1;return!0}e.tags={"#":1,"^":2,"<":3,$:4,"/":5,"!":6,">":7,"=":8,_v:9,"{":10,"&":11,_t:12},e.scan=function(n,r){var a=n.length,o=0,s=null,i=null,u="",h=[],p=!1,m=0,b=0,v="{{",f="}}";function g(){u.length>0&&(h.push({tag:"_t",text:new String(u)}),u="")}function x(n,r){if(g(),n&&function(){for(var n=!0,r=b;r<h.length;r++)if(!(n=e.tags[h[r].tag]<e.tags._v||"_t"==h[r].tag&&null===h[r].text.match(t)))return!1;return n}())for(var a,o=b;o<h.length;o++)h[o].text&&((a=h[o+1])&&">"==a.tag&&(a.indent=h[o].text.toString()),h.splice(o,1));else r||h.push({tag:"\n"});p=!1,b=h.length}function y(e,t){var n="="+f,r=e.indexOf(n,t),a=c(e.substring(e.indexOf("=",t)+1,r)).split(" ");return v=a[0],f=a[a.length-1],r+n.length-1}for(r&&(r=r.split(" "),v=r[0],f=r[1]),m=0;m<a;m++)0==o?d(v,n,m)?(--m,g(),o=1):"\n"==n.charAt(m)?x(p):u+=n.charAt(m):1==o?(m+=v.length-1,"="==(s=(i=e.tags[n.charAt(m+1)])?n.charAt(m+1):"_v")?(m=y(n,m),o=0):(i&&m++,o=2),p=m):d(f,n,m)?(h.push({tag:s,n:c(u),otag:v,ctag:f,i:"/"==s?p-v.length:m+f.length}),u="",m+=f.length-1,o=0,"{"==s&&("}}"==f?m++:l(h[h.length-1]))):u+=n.charAt(m);return x(p,!0),h};var u={_t:!0,"\n":!0,$:!0,"/":!0};function h(t,n,r,a){var o,s=[],i=null,l=null;for(o=r[r.length-1];t.length>0;){if(l=t.shift(),o&&"<"==o.tag&&!(l.tag in u))throw new Error("Illegal content in < super tag.");if(e.tags[l.tag]<=e.tags.$||p(l,a))r.push(l),l.nodes=h(t,l.tag,r,a);else{if("/"==l.tag){if(0===r.length)throw new Error("Closing tag without opener: /"+l.n);if(i=r.pop(),l.n!=i.n&&!m(l.n,i.n,a))throw new Error("Nesting error: "+i.n+" vs. "+l.n);return i.end=l.i,s}"\n"==l.tag&&(l.last=0==t.length||"\n"==t[0].tag)}s.push(l)}if(r.length>0)throw new Error("missing closing tag: "+r.pop().n);return s}function p(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n].o==e.n)return e.tag="#",!0}function m(e,t,n){for(var r=0,a=n.length;r<a;r++)if(n[r].c==e&&n[r].o==t)return!0}function b(e){var t=[];for(var n in e.partials)t.push('"'+f(n)+'":{name:"'+f(e.partials[n].name)+'", '+b(e.partials[n])+"}");return"partials: {"+t.join(",")+"}, subs: "+function(e){var t=[];for(var n in e)t.push('"'+f(n)+'": function(c,p,t,i) {'+e[n]+"}");return"{ "+t.join(",")+" }"}(e.subs)}e.stringify=function(t,n,r){return"{code: function (c,p,i) { "+e.wrapMain(t.code)+" },"+b(t)+"}"};var v=0;function f(e){return e.replace(o,"\\\\").replace(n,'\\"').replace(r,"\\n").replace(a,"\\r").replace(s,"\\u2028").replace(i,"\\u2029")}function g(e){return~e.indexOf(".")?"d":"f"}function x(e,t){var n="<"+(t.prefix||"")+e.n+v++;return t.partials[n]={name:e.n,partials:{}},t.code+='t.b(t.rp("'+f(n)+'",c,p,"'+(e.indent||"")+'"));',n}function y(e,t){t.code+="t.b(t.t(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'}function V(e){return"t.b("+e+");"}e.generate=function(t,n,r){v=0;var a={code:"",subs:{},partials:{}};return e.walk(t,a),r.asString?this.stringify(a,n,r):this.makeTemplate(a,n,r)},e.wrapMain=function(e){return'var t=this;t.b(i=i||"");'+e+"return t.fl();"},e.template=e.Template,e.makeTemplate=function(e,t,n){var r=this.makePartials(e);return r.code=new Function("c","p","i",this.wrapMain(e.code)),new this.template(r,t,this,n)},e.makePartials=function(e){var t,n={subs:{},partials:e.partials,name:e.name};for(t in n.partials)n.partials[t]=this.makePartials(n.partials[t]);for(t in e.subs)n.subs[t]=new Function("c","p","t","i",e.subs[t]);return n},e.codegen={"#":function(t,n){n.code+="if(t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,0,'+t.i+","+t.end+',"'+t.otag+" "+t.ctag+'")){t.rs(c,p,function(c,p,t){',e.walk(t.nodes,n),n.code+="});c.pop();}"},"^":function(t,n){n.code+="if(!t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,1,0,0,"")){',e.walk(t.nodes,n),n.code+="};"},">":x,"<":function(t,n){var r={partials:{},code:"",subs:{},inPartial:!0};e.walk(t.nodes,r);var a=n.partials[x(t,n)];a.subs=r.subs,a.partials=r.partials},$:function(t,n){var r={subs:{},code:"",partials:n.partials,prefix:t.n};e.walk(t.nodes,r),n.subs[t.n]=r.code,n.inPartial||(n.code+='t.sub("'+f(t.n)+'",c,p,i);')},"\n":function(e,t){t.code+=V('"\\n"'+(e.last?"":" + i"))},_v:function(e,t){t.code+="t.b(t.v(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'},_t:function(e,t){t.code+=V('"'+f(e.text)+'"')},"{":y,"&":y},e.walk=function(t,n){for(var r,a=0,o=t.length;a<o;a++)(r=e.codegen[t[a].tag])&&r(t[a],n);return n},e.parse=function(e,t,n){return h(e,0,[],(n=n||{}).sectionTags||[])},e.cache={},e.cacheKey=function(e,t){return[e,!!t.asString,!!t.disableLambda,t.delimiters,!!t.modelGet].join("||")},e.compile=function(t,n){n=n||{};var r=e.cacheKey(t,n),a=this.cache[r];if(a){var o=a.partials;for(var s in o)delete o[s].instance;return a}return a=this.generate(this.parse(this.scan(t,n.delimiters),t,n),t,n),this.cache[r]=a}}(t)},5485:(e,t,n)=>{var r=n(9397);r.Template=n(2882).Template,r.template=r.Template,e.exports=r},2882:(e,t)=>{!function(e){function t(e,t,n){var r;return t&&"object"==typeof t&&(void 0!==t[e]?r=t[e]:n&&t.get&&"function"==typeof t.get&&(r=t.get(e))),r}e.Template=function(e,t,n,r){e=e||{},this.r=e.code||this.r,this.c=n,this.options=r||{},this.text=t||"",this.partials=e.partials||{},this.subs=e.subs||{},this.buf=""},e.Template.prototype={r:function(e,t,n){return""},v:function(e){return e=l(e),i.test(e)?e.replace(n,"&amp;").replace(r,"&lt;").replace(a,"&gt;").replace(o,"&#39;").replace(s,"&quot;"):e},t:l,render:function(e,t,n){return this.ri([e],t||{},n)},ri:function(e,t,n){return this.r(e,t,n)},ep:function(e,t){var n=this.partials[e],r=t[n.name];if(n.instance&&n.base==r)return n.instance;if("string"==typeof r){if(!this.c)throw new Error("No compiler available.");r=this.c.compile(r,this.options)}if(!r)return null;if(this.partials[e].base=r,n.subs){for(key in t.stackText||(t.stackText={}),n.subs)t.stackText[key]||(t.stackText[key]=void 0!==this.activeSub&&t.stackText[this.activeSub]?t.stackText[this.activeSub]:this.text);r=function(e,t,n,r,a,o){function s(){}function i(){}var l;s.prototype=e,i.prototype=e.subs;var c=new s;for(l in c.subs=new i,c.subsText={},c.buf="",r=r||{},c.stackSubs=r,c.subsText=o,t)r[l]||(r[l]=t[l]);for(l in r)c.subs[l]=r[l];for(l in a=a||{},c.stackPartials=a,n)a[l]||(a[l]=n[l]);for(l in a)c.partials[l]=a[l];return c}(r,n.subs,n.partials,this.stackSubs,this.stackPartials,t.stackText)}return this.partials[e].instance=r,r},rp:function(e,t,n,r){var a=this.ep(e,n);return a?a.ri(t,n,r):""},rs:function(e,t,n){var r=e[e.length-1];if(c(r))for(var a=0;a<r.length;a++)e.push(r[a]),n(e,t,this),e.pop();else n(e,t,this)},s:function(e,t,n,r,a,o,s){var i;return(!c(e)||0!==e.length)&&("function"==typeof e&&(e=this.ms(e,t,n,r,a,o,s)),i=!!e,!r&&i&&t&&t.push("object"==typeof e?e:t[t.length-1]),i)},d:function(e,n,r,a){var o,s=e.split("."),i=this.f(s[0],n,r,a),l=this.options.modelGet,d=null;if("."===e&&c(n[n.length-2]))i=n[n.length-1];else for(var u=1;u<s.length;u++)void 0!==(o=t(s[u],i,l))?(d=i,i=o):i="";return!(a&&!i)&&(a||"function"!=typeof i||(n.push(d),i=this.mv(i,n,r),n.pop()),i)},f:function(e,n,r,a){for(var o=!1,s=!1,i=this.options.modelGet,l=n.length-1;l>=0;l--)if(void 0!==(o=t(e,n[l],i))){s=!0;break}return s?(a||"function"!=typeof o||(o=this.mv(o,n,r)),o):!a&&""},ls:function(e,t,n,r,a){var o=this.options.delimiters;return this.options.delimiters=a,this.b(this.ct(l(e.call(t,r)),t,n)),this.options.delimiters=o,!1},ct:function(e,t,n){if(this.options.disableLambda)throw new Error("Lambda features disabled.");return this.c.compile(e,this.options).render(t,n)},b:function(e){this.buf+=e},fl:function(){var e=this.buf;return this.buf="",e},ms:function(e,t,n,r,a,o,s){var i,l=t[t.length-1],c=e.call(l);return"function"==typeof c?!!r||(i=this.activeSub&&this.subsText&&this.subsText[this.activeSub]?this.subsText[this.activeSub]:this.text,this.ls(c,l,n,i.substring(a,o),s)):c},mv:function(e,t,n){var r=t[t.length-1],a=e.call(r);return"function"==typeof a?this.ct(l(a.call(r)),r,n):a},sub:function(e,t,n,r){var a=this.subs[e];a&&(this.activeSub=e,a(t,n,this,r),this.activeSub=!1)}};var n=/&/g,r=/</g,a=/>/g,o=/\'/g,s=/\"/g,i=/[&<>\"\']/;function l(e){return String(null==e?"":e)}var c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}}(t)},9606:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n, r);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, rayType);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n, r);\n}\n\nvec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    return render({{name}}, v, rayType);\n}",r);return e.render.apply(e,arguments)}},9909:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);"),r.b("\n"+n),r.b("    //return vec4(debugColor,1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);\n    //return vec4(debugColor,1);\n}",r);return e.render.apply(e,arguments)}},8906:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},1998:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,220,289,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,481,540,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},699:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,405,478,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,580,881,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,764,845,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1119,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1289,1570,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1464,1535,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},4261:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,210,275,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,463,518,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},8474:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},5506:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,171,240,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,432,491,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},7397:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,356,429,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,531,832,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,715,796,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1070,1133,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1240,1521,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1415,1486,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},3045:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,161,226,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,414,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},6077:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    return normalMaterialRender(v, normal);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    return normalMaterialRender(v, normal);\n}",r);return e.render.apply(e,arguments)}},1202:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n,r);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n,r);\n}",r);return e.render.apply(e,arguments)}},2330:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v).rgb;\n}",r);return e.render.apply(e,arguments)}},9040:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, normal).rgb;\n}",r);return e.render.apply(e,arguments)}},588:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;   "),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;   \n    }\n    return {{material.name}}_render(v, normal, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},1365:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("      return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n      return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},8149:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,204,519,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongMaterial material = {{name}};\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},3838:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,261,587,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},472:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,269,595,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},7660:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,282,608,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},8204:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,275,601,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},5377:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.b("        color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    color0 = {{mat0.name}}_render(v);\n\n    if(v.vector.cellBoost == material.cellBoost){\n        color1 = {{mat1.name}}_render(v);\n    } else{\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},9441:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,156,212,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,405,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else {"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionLocalWrapMaterial material = {{name}};\n    vec4 color0, color1;\n    {{#mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v, normal);\n        {{/mat1.usesNormal}}\n        {{^mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v);\n        {{/mat1.usesNormal}}\n    } else {\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},9245:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,296,355,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,429,658,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,567,634,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,834,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,1017,1274,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1171,1246,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            {{^mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal);\n            {{/mat1.usesUVMap}}\n            {{#mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal, uv);\n            {{/mat1.usesUVMap}}\n        {{/mat1.usesNormal}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},6766:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,147,198,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,386,445,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},8402:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    TransitionWrapMaterial material = {{name}};\n\n    vec4 color0 = {{mat0.name}}_render(v);\n    vec4 color1 = {{mat1.name}}_render(v);\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},6158:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,127,188,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,332,393,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    {{#mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v, normal);\n    {{/mat1.usesNormal}}\n    {{^mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v);\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},4146:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,271,335,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,409,648,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,552,624,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,829,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,967,1206,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1110,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n    \n    {{#mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},2332:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,117,173,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,312,368,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    {{#mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v, uv);\n    {{/mat1.usesUVMap}}\n    {{^mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v);\n    {{/mat1.usesUVMap}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},6142:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return negate("),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v));"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the complement of a shape\n */\nRelVector {{name}}_gradient(RelVector v){\n    return negate({{shape.name}}_gradient(v));\n}",r);return e.render.apply(e,arguments)}},7939:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    return - "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the complement of a shape\n */\nfloat {{name}}_sdf(RelVector v){\n    return - {{shape.name}}_sdf(v);\n}",r);return e.render.apply(e,arguments)}},7260:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},6861:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMaxPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMaxPoly(dist1, dist2, grad1, grad2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},3335:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the intersection of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6428:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMaxPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMaxPoly(dist1, dist2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},2076:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return max(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the intersection of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return max(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},2905:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},8655:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMinPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMinPoly(dist1, dist2, grad1, grad2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},7762:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},3238:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMinPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMinPoly(dist1, dist2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},3908:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return min(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return min(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},7500:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6242:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for a wrapping\n */\nRelVector {{name}}_gradient(RelVector v){\n    return {{shape.name}}_gradient(v);\n}",r);return e.render.apply(e,arguments)}},3105:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float wrap = "),r.b(r.v(r.d("wrap.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(wrap > camera.threshold){"),r.b("\n"+n),r.b("        return wrap;"),r.b("\n"+n),r.b("    } else {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for a wrapping\n */\nfloat {{name}}_sdf(RelVector v){\n    float wrap = {{wrap.name}}_sdf(v);\n    if(wrap > camera.threshold){\n        return wrap;\n    } else {\n        return {{shape.name}}_sdf(v);\n    }\n}",r);return e.render.apply(e,arguments)}},9338:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},7577:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("bool "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(RelVector v, int i, out RelVector dir, out float intensity) {"),r.b("\n"+n),r.b("    return directions("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, i, dir, intensity);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"bool {{name}}_directions(RelVector v, int i, out RelVector dir, out float intensity) {\n    return directions({{name}}, v, i, dir, intensity);\n}",r);return e.render.apply(e,arguments)}},8778:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return render({{name}}, v);\n}\n",r);return e.render.apply(e,arguments)}},1215:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, uv);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    return render({{name}}, v, uv);\n}\n",r);return e.render.apply(e,arguments)}},2044:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1403,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1386,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representation of v can be updated"),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2169,2585,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2232,2533,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3143,3524,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3165,3506,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representation of v can be updated\n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},7781:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec4 color;"),r.b("\n"+n),r.b("    vec4 reflectivity;"),r.b("\n"+n),r.b("    float opacity;"),r.b("\n"+n),r.b("    float t;"),r.b("\n"),r.b("\n"+n),r.b("    switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,315,5918,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,0,373,2190,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,589,724,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,822,1314,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,1071,1278,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("            if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                opacity = 1.;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else {"),r.b("\n"+n),r.b("                opacity = color.a;"),r.b("\n"+n),r.b("            }"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,1525,1604,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                //color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("            if(opacity == 1.) {"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else{"),r.b("\n"+n),r.b("                v.data.stop = false;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;"),r.b("\n"+n),r.b("            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;"),r.b("\n"+n),r.b("            "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack = false;"),r.b("\n"+n),r.b("            v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("            v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("            //v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,1,0,0,"")||(r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,0,2294,4409,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("                if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                    reflectivity = vec4(0);"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else {"),r.b("\n"+n),r.b("                    reflectivity = vec4("),r.b(r.v(r.d("material.name",e,t,0))),r.b(".reflectivity,1);"),r.b("\n"+n),r.b("                }"),r.b("\n"),r.b("\n"+n),r.b("                normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                // in general the gradient is not necessarily a unit vector"),r.b("\n"+n),r.b("                normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,2944,3091,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,3197,3593,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,3398,3553,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,3649,3734,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                if(length(reflectivity) == 0.) {"),r.b("\n"+n),r.b("                    v.data.stop = true;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else{"),r.b("\n"+n),r.b("                    v.data.stop = false;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;"),r.b("\n"+n),r.b("                v.vector = geomReflect(v.vector,normal);"),r.b("\n"+n),r.b("                v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("                v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("                v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,4710,4857,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,4963,5495,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,5232,5455,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,5551,5636,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n)),r.b("\n"+n)),r.b("        break;"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec4 color = "),r.b(r.v(r.d("scene.background.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));\n}\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    vec2 uv;\n    vec4 color;\n    vec4 reflectivity;\n    float opacity;\n    float t;\n\n    switch(objId){\n    {{#scene.solids}}\n\n        case {{id}}:\n        {{#material.isTransparent}}\n\n            {{^material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color =  {{material.name}}_render(v);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            {{#material.usesNormal}}\n                {{^material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    color = {{material.name}}_render(v, normal);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, normal, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            if(v.data.iBounce == maxBounces){\n                opacity = 1.;\n            }\n            else {\n                opacity = color.a;\n            }\n\n            {{#scene.fog}}\n                //color = applyFog(color, v.data.lastBounceDist);\n            {{/scene.fog}}\n\n            if(opacity == 1.) {\n                v.data.stop = true;\n            }\n            else{\n                v.data.stop = false;\n            }\n            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;\n            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;\n            {{name}}_isRenderedHack = false;\n            v.data.lastBounceDist = 0.;\n            v.data.iBounce = v.data.iBounce + 1;\n            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n            //v = flow(v, t);\n\n        {{/material.isTransparent}}\n\n        {{^material.isTransparent}}\n\n            {{#material.isReflecting}}\n\n                if(v.data.iBounce == maxBounces){\n                    reflectivity = vec4(0);\n                }\n                else {\n                    reflectivity = vec4({{material.name}}.reflectivity,1);\n                }\n\n                normal = {{shape.name}}_gradient(v.vector);\n                // in general the gradient is not necessarily a unit vector\n                normal = geomNormalize(normal);\n\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                if(length(reflectivity) == 0.) {\n                    v.data.stop = true;\n                }\n                else{\n                    v.data.stop = false;\n                }\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;\n                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;\n                v.vector = geomReflect(v.vector,normal);\n                v.data.lastBounceDist = 0.;\n                v.data.iBounce = v.data.iBounce + 1;\n                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n                v = flow(v, t);\n\n            {{/material.isReflecting}}\n\n            {{^material.isReflecting}}\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n                v.data.leftToComputeColor = vec4(0);\n                v.data.stop = true;\n            {{/material.isReflecting}}\n\n        {{/material.isTransparent}}\n        break;\n\n    {{/scene.solids}}\n    }\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec4 color = {{scene.background.name}}_render(v);\n        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},4122:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * We assume that we are inside a solid"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("void nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    ior = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.ior; // index of the "air"'),r.b("\n"+n),r.b("    absorb = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.absorb; // absorb of the "air"'),r.b("\n"+n),r.b("    emission=vec3(0,0,0);//no emission from 'air'"),r.b("\n"+n),r.b("    opticalDepth="),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.opticalDepth; // opticalDepth of the "air"'),r.b("\n"+n),r.b("    isInside = false;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    RelVector v = flow(normal, 2. * camera.threshold);"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,579,1010,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("            dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("            if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                ior = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("                absorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("                emission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("                opticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("                isInside = true;"),r.b("\n"+n),r.b("                return;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("}"),r.fl()},partials:{},subs:{}},'/**\n * We assume that we are inside a solid\n */\nvoid nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){\n    float dist;\n    ior = {{scene.ptBackground.name}}.ior; // index of the "air"\n    absorb = {{scene.ptBackground.name}}.absorb; // absorb of the "air"\n    emission=vec3(0,0,0);//no emission from \'air\'\n    opticalDepth={{scene.ptBackground.name}}.opticalDepth; // opticalDepth of the "air"\n    isInside = false;\n    \n    RelVector v = flow(normal, 2. * camera.threshold);\n    {{#scene.solids}}\n        if({{name}}.isRendered){\n            dist = {{shape.name}}_sdf(v);\n            if(dist < camera.threshold) {\n                ior = {{ptMaterial.name}}.ior;\n                absorb = {{ptMaterial.name}}.absorb;\n                emission = {{ptMaterial.name}}.volumeEmission;\n                opticalDepth = {{ptMaterial.name}}.opticalDepth;\n                isInside = true;\n                return;\n            }\n        }\n    {{/scene.solids}}\n}',r);return e.render.apply(e,arguments)}},6172:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1381,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1364,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representatiion of v can be updated "),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2149,2565,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2212,2513,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3123,3482,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3145,3464,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representatiion of v can be updated \n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},6272:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".absorb, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".volumeEmission, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".opticalDepth, false);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void roulette(inout ExtVector v){"),r.b("\n"+n),r.b("    // as the light left gets smaller, the ray is more likely to get terminated early."),r.b("\n"+n),r.b("    // survivors have their value boosted to make up for fewer samples being in the average."),r.b("\n"+n),r.b("    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));"),r.b("\n"+n),r.b("    if (randomFloat() > p){"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    // add the energy we 'lose' by randomly terminating paths"),r.b("\n"+n),r.b("    v.data.light = v.data.light / p;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    RayType rayType;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec3 color;"),r.b("\n"+n),r.b("    vec3 reflectivity;"),r.b("\n"+n),r.b("    float hackCoeff = 1.;"),r.b("\n"+n),r.b("    float r; /** ratio of IOR */"),r.b("\n"+n),r.b("    float nextIOR; /** IOR of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextAbsorb; /** absorb of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextEmission;/** volumetric emission of the neighbor solid */"),r.b("\n"+n),r.b("    float nextOpticalDepth;/** optical depth of the neighbor solid */"),r.b("\n"+n),r.b("    bool nextIsInside = true;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector diffuseDir;"),r.b("\n"+n),r.b("    RelVector reflectDir;"),r.b("\n"+n),r.b("    RelVector refractDir;"),r.b("\n"),r.b("\n"+n),r.b("    // get a uniformly distributed vector on the sphere"),r.b("\n"+n),r.b("    RelVector random = randomVector(v.vector);"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("    //get volumetric coloring:"),r.b("\n"+n),r.b("    //portion of light is absorbed."),r.b("\n"+n),r.b("    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    //light is emitted along the journey (linear or expoenential pickup)"),r.b("\n"+n),r.b("    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;"),r.b("\n"+n),r.b("    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);"),r.b("\n"),r.b("\n"+n),r.b("    //use these quantities to update pixel and light:"),r.b("\n"+n),r.b("    v.data.light = v.data.light * volAbsorb;"),r.b("\n"+n),r.b("    v.data.pixel = v.data.pixel + v.data.light*volEmit;"),r.b("\n"+n),r.b("    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output"),r.b("\n"+n),r.b("    "),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,2036,5260,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("    "),r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.b("            normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("            normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.b("            "),r.b("\n"+n),r.b("            // get info and reset normal based on which side we are on."),r.b("\n"+n),r.b('            // starting assumption: in the "air"'),r.b("\n"+n),r.b("            r = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".ior / "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("            nextAbsorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("            nextEmission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("            nextOpticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(v.data.isInside){"),r.b("\n"+n),r.b("                //things to change if we are inside a material instead:"),r.b("\n"+n),r.b("                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);"),r.b("\n"+n),r.b("                r = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior / nextIOR;"),r.b("\n"+n),r.b("                normal = negate(normal);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            rayType = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_setRayType(v, normal,r);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color =  "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, rayType);"),r.b("\n"+n)),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,0,3160,3302,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                color = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, uv, rayType);"),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("        // hack to make sure that lights are not too bright"),r.b("\n"+n),r.b("            if(v.data.iBounce == 0){"),r.b("\n"+n),r.b("                hackCoeff = 0.2;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            //apply surface effects"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".emission;"),r.b("\n"+n),r.b("            if(!rayType.refract){"),r.b("\n"+n),r.b("                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);"),r.b("\n"+n),r.b("             }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            // update the ray direction"),r.b("\n"+n),r.b("            // diffuse uses a normal oriented cosine weighted hemisphere sample."),r.b("\n"+n),r.b("            diffuseDir = geomNormalize(add(normal, random));"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.diffuse){"),r.b("\n"+n),r.b("                v.vector = diffuseDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.reflect){"),r.b("\n"+n),r.b("                // perfectly smooth specular uses the reflection ray."),r.b("\n"+n),r.b("                reflectDir = geomReflect(v.vector, normal);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                v.vector = reflectDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.refract){"),r.b("\n"+n),r.b("                    refractDir = geomRefract(v.vector,normal, r);"),r.b("\n"+n),r.b("                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                    v.data.isInside = nextIsInside;"),r.b("\n"+n),r.b("                    v.data.currentAbsorb = nextAbsorb;"),r.b("\n"+n),r.b("                    v.data.currentEmission = nextEmission;"),r.b("\n"+n),r.b("                    v.data.currentOpticalDepth = nextOpticalDepth;"),r.b("\n"+n),r.b("                    v.vector = refractDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("    v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("    // be carefull, v is not normal to the surface"),r.b("\n"+n),r.b("    // if the time we flow is too small, we are still below the camera threshold"),r.b("\n"+n),r.b("    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("    v = flow(v, t);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor.rgb;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec3 bgColor = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".diffuse;"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.light * bgColor;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        roulette(v);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), {{scene.ptBackground.name}}.absorb, {{scene.ptBackground.name}}.volumeEmission, {{scene.ptBackground.name}}.opticalDepth, false);\n}\n\n\n\nvoid roulette(inout ExtVector v){\n    // as the light left gets smaller, the ray is more likely to get terminated early.\n    // survivors have their value boosted to make up for fewer samples being in the average.\n    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));\n    if (randomFloat() > p){\n        v.data.stop = true;\n    }\n    // add the energy we 'lose' by randomly terminating paths\n    v.data.light = v.data.light / p;\n}\n\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    RayType rayType;\n    vec2 uv;\n    vec3 color;\n    vec3 reflectivity;\n    float hackCoeff = 1.;\n    float r; /** ratio of IOR */\n    float nextIOR; /** IOR of the neighbor solid */\n    vec3 nextAbsorb; /** absorb of the neighbor solid */\n    vec3 nextEmission;/** volumetric emission of the neighbor solid */\n    float nextOpticalDepth;/** optical depth of the neighbor solid */\n    bool nextIsInside = true;\n\n    RelVector diffuseDir;\n    RelVector reflectDir;\n    RelVector refractDir;\n\n    // get a uniformly distributed vector on the sphere\n    RelVector random = randomVector(v.vector);\n\n\n\n\n\n    //get volumetric coloring:\n    //portion of light is absorbed.\n    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);\n    \n    //light is emitted along the journey (linear or expoenential pickup)\n    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;\n    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);\n\n    //use these quantities to update pixel and light:\n    v.data.light = v.data.light * volAbsorb;\n    v.data.pixel = v.data.pixel + v.data.light*volEmit;\n    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output\n    \n\n\n\n\n\n\nswitch(objId){\n    {{#scene.solids}}\n    \n        case {{id}}:\n            normal = {{shape.name}}_gradient(v.vector);\n            normal = geomNormalize(normal);\n\n            \n            // get info and reset normal based on which side we are on.\n            // starting assumption: in the \"air\"\n            r = {{scene.ptBackground.name}}.ior / {{ptMaterial.name}}.ior;\n            nextAbsorb = {{ptMaterial.name}}.absorb;\n            nextEmission = {{ptMaterial.name}}.volumeEmission;\n            nextOpticalDepth = {{ptMaterial.name}}.opticalDepth;\n        \n            if(v.data.isInside){\n                //things to change if we are inside a material instead:\n                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);\n                r = {{ptMaterial.name}}.ior / nextIOR;\n                normal = negate(normal);\n            }\n        \n            rayType = {{ptMaterial.name}}_setRayType(v, normal,r);\n        \n            {{^ptMaterial.usesUVMap}}\n                color =  {{ptMaterial.name}}_render(v, normal, rayType);\n            {{/ptMaterial.usesUVMap}}\n            {{#ptMaterial.usesUVMap}}\n                uv = {{shape.name}}_uvMap(v.vector);\n                color = {{ptMaterial.name}}_render(v, normal, uv, rayType);\n            {{/ptMaterial.usesUVMap}}\n        \n        \n        // hack to make sure that lights are not too bright\n            if(v.data.iBounce == 0){\n                hackCoeff = 0.2;\n            }\n        \n            //apply surface effects\n            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * {{ptMaterial.name}}.emission;\n            if(!rayType.refract){\n                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);\n             }\n        \n            // update the ray direction\n            // diffuse uses a normal oriented cosine weighted hemisphere sample.\n            diffuseDir = geomNormalize(add(normal, random));\n        \n            if(rayType.diffuse){\n                v.vector = diffuseDir;\n            }\n        \n            if(rayType.reflect){\n                // perfectly smooth specular uses the reflection ray.\n                reflectDir = geomReflect(v.vector, normal);\n        \n                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                v.vector = reflectDir;\n            }\n        \n            if(rayType.refract){\n                    refractDir = geomRefract(v.vector,normal, r);\n                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                    v.data.isInside = nextIsInside;\n                    v.data.currentAbsorb = nextAbsorb;\n                    v.data.currentEmission = nextEmission;\n                    v.data.currentOpticalDepth = nextOpticalDepth;\n                    v.vector = refractDir;\n            }\n            break;\n    \n    {{/scene.solids}}\n    }\n\n    v.data.lastBounceDist = 0.;\n    v.data.iBounce = v.data.iBounce + 1;\n    // be carefull, v is not normal to the surface\n    // if the time we flow is too small, we are still below the camera threshold\n    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n    v = flow(v, t);\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor.rgb;\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec3 bgColor = {{scene.ptBackground.name}}.diffuse;\n        v.data.pixel = v.data.pixel + v.data.light * bgColor;\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        roulette(v);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},5030:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return gradient("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    return gradient({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},8266:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float newEp = 0.001;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));"),r.b("\n"+n),r.b("    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));"),r.b("\n"),r.b("\n"+n),r.b("    float vgx = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPX) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMX);"),r.b("\n"+n),r.b("    float vgy = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPY) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMY);"),r.b("\n"+n),r.b("    float vgz = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPZ) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMZ);"),r.b("\n"+n),r.b("    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));"),r.b("\n"),r.b("\n"+n),r.b("    n = geomNormalize(n);"),r.b("\n"+n),r.b("    return n;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    float newEp = 0.001;\n\n    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));\n    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));\n    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));\n    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));\n    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));\n    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));\n\n    float vgx = {{name}}_sdf(shiftPX) - {{name}}_sdf(shiftMX);\n    float vgy = {{name}}_sdf(shiftPY) - {{name}}_sdf(shiftMY);\n    float vgz = {{name}}_sdf(shiftPZ) - {{name}}_sdf(shiftMZ);\n    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));\n\n    n = geomNormalize(n);\n    return n;\n}",r);return e.render.apply(e,arguments)}},3707:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v) {"),r.b("\n"+n),r.b("    return sdf("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"float {{name}}_sdf(RelVector v) {\n    return sdf({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},4355:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return uvMap("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return uvMap({{name}}, v);\n}",r);return e.render.apply(e,arguments)}},3148:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Default creeping function (binary search)"),r.b("\n"+n),r.b(" * @param start starting point of the creeping"),r.b("\n"+n),r.b(" * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)"),r.b("\n"+n),r.b(" * @param offset how long we flow after passing the boundary"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(ExtVector v, ExtVector outside,  float offset){"),r.b("\n"+n),r.b("    ExtVector try = outside;"),r.b("\n"+n),r.b("    float sIn = 0.;"),r.b("\n"+n),r.b("    float sOut = try.data.lastFlowDist;"),r.b("\n"+n),r.b("    float s;"),r.b("\n"+n),r.b("    for(int i=0; i < 100; i++){"),r.b("\n"+n),r.b("        if(sOut - sIn < offset){"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("        s = 0.5 * sIn + 0.5 * sOut;"),r.b("\n"+n),r.b("        try = flow(v,s);"),r.b("\n"+n),r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("            sOut = s;"),r.b("\n"+n),r.b("            outside = try;"),r.b("\n"+n),r.b("        } else {"),r.b("\n"+n),r.b("            sIn = s;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return sOut;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Default creeping function (binary search)\n * @param start starting point of the creeping\n * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)\n * @param offset how long we flow after passing the boundary\n */\nfloat {{glslCreepName}}(ExtVector v, ExtVector outside,  float offset){\n    ExtVector try = outside;\n    float sIn = 0.;\n    float sOut = try.data.lastFlowDist;\n    float s;\n    for(int i=0; i < 100; i++){\n        if(sOut - sIn < offset){\n            break;\n        }\n        s = 0.5 * sIn + 0.5 * sOut;\n        try = flow(v,s);\n        if({{glslTestName}}(try.vector.local.pos)){\n            sOut = s;\n            outside = try;\n        } else {\n            sIn = s;\n        }\n    }\n    return sOut;\n}",r);return e.render.apply(e,arguments)}},5103:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* Teleportation."),r.b("\n"+n),r.b("* Check if the local vector is still in the fundamental domain define by the teleportation tests."),r.b("\n"+n),r.b("* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true"),r.b("\n"+n),r.b("* Otherwise, do nothing and set teleported to false"),r.b("\n"+n),r.b("* @param[in] v the relative vector to teleport."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("ExtVector teleport(ExtVector v){"),r.b("\n"+n),r.b("    v.data.isTeleported = false;"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,424,621,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(v.vector.local.pos)){"),r.b("\n"+n),r.b("            v.vector = rewrite(v.vector, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("            v.data.isTeleported = true;"),r.b("\n"+n),r.b("            return v;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    return v;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Does one of the two following transformation:"),r.b("\n"+n),r.b("* flow the vector by the given time, if the vector escape the fundamental domain,"),r.b("\n"+n),r.b("* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain"),r.b("\n"+n),r.b("* (and even a bit further)"),r.b("\n"+n),r.b("*"),r.b("\n"+n),r.b("* @param[inout] v the relative vector to flow / teleport / creep."),r.b("\n"+n),r.b("* @param[in] t the (maximal) time to flow"),r.b("\n"+n),r.b("* @param[in] offset the amount we march passed the boundary"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float creepingDist(ExtVector v, float t, float offset){"),r.b("\n"+n),r.b("    float res = t;"),r.b("\n"+n),r.b("    ExtVector try = flow(v, t);"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,1233,1638,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.f("usesCreepingCustom",e,t,1),e,t,0,1266,1407,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.f("usesCreepingBinary",e,t,1),e,t,0,1463,1609,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, try, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n)})),e.pop()),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"/**\n* Teleportation.\n* Check if the local vector is still in the fundamental domain define by the teleportation tests.\n* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true\n* Otherwise, do nothing and set teleported to false\n* @param[in] v the relative vector to teleport.\n*/\nExtVector teleport(ExtVector v){\n    v.data.isTeleported = false;\n    {{#teleportations}}\n        if({{glslTestName}}(v.vector.local.pos)){\n            v.vector = rewrite(v.vector, {{elt.name}}, {{inv.name}});\n            v.data.isTeleported = true;\n            return v;\n        }\n    {{/teleportations}}\n    return v;\n}\n\n\n/**\n* Does one of the two following transformation:\n* flow the vector by the given time, if the vector escape the fundamental domain,\n* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain\n* (and even a bit further)\n*\n* @param[inout] v the relative vector to flow / teleport / creep.\n* @param[in] t the (maximal) time to flow\n* @param[in] offset the amount we march passed the boundary\n*/\nfloat creepingDist(ExtVector v, float t, float offset){\n    float res = t;\n    ExtVector try = flow(v, t);\n    {{#teleportations}}\n\n        {{#usesCreepingCustom}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, offset));\n            }\n        {{/usesCreepingCustom}}\n\n        {{#usesCreepingBinary}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, try, offset));\n            }\n        {{/usesCreepingBinary}}\n\n    {{/teleportations}}\n    return res;\n}\n\n\n",r);return e.render.apply(e,arguments)}},8976:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* Gradient for the complement of a shape"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    RelVector gradient = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"),r.b("\n"+n),r.b("    float x = v.local.pos.coords.x;"),r.b("\n"+n),r.b("    float y = v.local.pos.coords.y;"),r.b("\n"+n),r.b("    float z = v.local.pos.coords.z;"),r.b("\n"+n),r.b("    vec4 dir = 0.05 * 30. * vec4("),r.b("\n"+n),r.b("    cos(30. * x) * sin(30. * y) * sin(30. * z),"),r.b("\n"+n),r.b("    sin(30. * x) * cos(30. * y) * sin(30. * z),"),r.b("\n"+n),r.b("    sin(30. * x) * sin(30. * y) * cos(30. * z),"),r.b("\n"+n),r.b("    0"),r.b("\n"+n),r.b("    );"),r.b("\n"+n),r.b("    Vector local = Vector(v.local.pos, dir);"),r.b("\n"+n),r.b("    RelVector disp = RelVector(local, v.cellBoost, v.invCellBoost);"),r.b("\n"+n),r.b("    RelVector res = add(gradient, disp);"),r.b("\n"+n),r.b("    return geomNormalize(res);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n* Gradient for the complement of a shape\n*/\nRelVector {{name}}_gradient(RelVector v){\n    RelVector gradient = {{shape.name}}_gradient(v);\n\n    float x = v.local.pos.coords.x;\n    float y = v.local.pos.coords.y;\n    float z = v.local.pos.coords.z;\n    vec4 dir = 0.05 * 30. * vec4(\n    cos(30. * x) * sin(30. * y) * sin(30. * z),\n    sin(30. * x) * cos(30. * y) * sin(30. * z),\n    sin(30. * x) * sin(30. * y) * cos(30. * z),\n    0\n    );\n    Vector local = Vector(v.local.pos, dir);\n    RelVector disp = RelVector(local, v.cellBoost, v.invCellBoost);\n    RelVector res = add(gradient, disp);\n    return geomNormalize(res);\n}",r);return e.render.apply(e,arguments)}},7329:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* SDF for the displacement of a shape"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    float x = v.local.pos.coords.x;"),r.b("\n"+n),r.b("    float y = v.local.pos.coords.y;"),r.b("\n"+n),r.b("    float z = v.local.pos.coords.z;"),r.b("\n"+n),r.b("    float disp = 0.05 * sin(30. * x) * sin(30. * y) * sin(30. * z);"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v) + disp;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n* SDF for the displacement of a shape\n*/\nfloat {{name}}_sdf(RelVector v){\n    \n    float x = v.local.pos.coords.x;\n    float y = v.local.pos.coords.y;\n    float z = v.local.pos.coords.z;\n    float disp = 0.05 * sin(30. * x) * sin(30. * y) * sin(30. * z);\n    return {{shape.name}}_sdf(v) + disp;\n}",r);return e.render.apply(e,arguments)}},9188:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                               \n                                                                                                                        \n\nstruct GroupElement {\n    bool fake;                                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(true);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(true);\n}\n\n                                              \n                                \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return IDENTITY;\n}"},5363:e=>{e.exports="   \n                                                                \n   \nfloat fresnelReflectAmount(RelVector incident, RelVector normal, float r, float reflecAt0, float relfectAt90) {\n                           \n    float r0 = (r - 1.) / (r + 1.);\n    r0 = r0 * r0;\n    float cosX = -geomDot(normal, incident);\n    if (r > 1.)\n    {\n        float sinT2 = r * r * (1. - cosX * cosX);\n                                    \n        if (sinT2 > 1.){\n            return relfectAt90;\n        }\n        cosX = sqrt(1. - sinT2);\n    }\n    float x = 1.- cosX;\n    float ret = clamp(r0 + (1. - r0) * x * x * x * x * x, 0., 1.);\n\n                                                        \n                               \n    return reflecAt0 + (relfectAt90 - reflecAt0) * ret;\n}"},2093:e=>{e.exports="   \n                                  \n   \nfloat smoothMaxPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return max(a, b) + 0.25 * k * h * h;\n}\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMaxPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n    return add(multiplyScalar(1. - 0.5 * h, gradMax), multiplyScalar(0.5 * h, gradMin));\n}\n"},5442:e=>{e.exports="float smoothMinPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return min(a, b) - 0.25 * k * h * h;\n}\n\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMinPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n\n    return add(multiplyScalar(1. - 0.5 * h, gradMin), multiplyScalar(0.5 * h, gradMax));\n}\n"},2143:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct BasicPTMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(BasicPTMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n                                                         \n                                  \n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\nvec3 render(BasicPTMaterial material, ExtVector v, RayType rayType) {\n    if (rayType.reflect){\n        return material.specular;\n    }\n                               \n                                              \n                                         \n       \n    return material.diffuse;\n}\n\n"},2197:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct CheckerboardMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\nvec4 render(CheckerboardMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    if (x1 < 1. && x2 < 1.){\n        return vec4(material.color1, 1);\n    } else if (x1 >= 1. && x2 >= 1.) {\n        return vec4(material.color1, 1);\n    } else {\n        return vec4(material.color2, 1);\n    }\n}\n\n"},7793:e=>{e.exports="\n                                                                                                                        \n                       \n                                                                                                                        \n"},4743:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct EquidistantHypStripsMaterial {\n    float distance;\n    float width;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(EquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float distP = atanh(uv.x);\n    float k = round(distP / material.distance);\n    vec2 q = horizontalTranslate(uv, -k * material.distance);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1917:e=>{e.exports="                                                                                                                        \n                                                  \n                                                                                                                        \n\nstruct EquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n\nvec4 render(EquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n    float theta = uv.x;\n    float phi = uv.y;\n    theta = theta - round(theta / material.distance) * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n                                                                                            \n    if (cosDistSq > material.cosHalfWidthSq) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},3801:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct GraphPaperMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\n\nfloat gridLines(vec2 uv, float size){\n    float brightness = 1./(2.*sqrt(size));\n    float gridPattern = abs(sin(3.14*size*uv.x)*sin(1.*3.14*size*uv.y));\n                                   \n    gridPattern = 1.-clamp(pow(gridPattern,0.05),0.,1.);\n    return gridPattern*brightness;\n}\n\nfloat grid(vec2 uv){\n    float grid1 = gridLines(uv,1.);\n    float grid2 = gridLines(uv,5.);\n    float grid3 = gridLines(uv,10.);\n    float grid4 = gridLines(uv,50.);\n    float gridTotal = grid1+grid2+grid3+grid4;\n    gridTotal *=5.;\n   return gridTotal;\n}\n\nvec4 render(GraphPaperMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    float gridPattern = grid(vec2(x1,x2));\n\n    vec3 col1 = material.color1*(1.-gridPattern);\n    vec3 col2 = material.color2*gridPattern;\n    return vec4(col1+col2,1.);\n\n}\n\n"},2278:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightLocalWrapMaterial {\n    GroupElement cellBoost;\n    bool isHighlightOn;\n};\n"},3048:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightWrapMaterial {\n    bool isHighlightOn;\n};\n"},7685:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct HypStripsMaterial {\n    float totalWidth;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n};\n\nvec4 render(HypStripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float aux = clamp(uv.x, -1., 1.);\n    float dist = atanh(aux);\n    float x = mod(dist / material.totalWidth, 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}"},4566:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantHypStripsMaterial {\n    float distance;\n    float halfWidth;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(ImprovedEquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float t = atanh(uv.x) - material.distance;\n    vec2 m = horizontalTranslate(uv, -t);\n    float distM = abs(distToYAxis(m));\n    float n = floor(log(distM / material.distance) / log(2.));\n\n    float distP = atanh(uv.x);\n    float period = pow(2., -n) * material.distance;\n    float k = round(distP / period);\n    vec2 q = horizontalTranslate(uv, -k * period);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1650:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    float fadingAmplitude;\n    vec3 stripColor;\n    vec3 bgColor;\n    mat4 rotation;\n};\n\nvec4 render(ImprovedEquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n                         \n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n\n\n                                                                                              \n    float ln2 = 0.6931471;                               \n\n    float theta = rotatedUV.x;\n    float phi = rotatedUV.y;\n    float k = round(theta / material.distance);\n    theta = theta - k * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n\n                                                                                            \n    if (cosDistSq < material.cosHalfWidthSq) {\n                                                               \n        return vec4(material.bgColor, 1);\n    }\n    if (k == 0.) {\n        return vec4(material.stripColor, 1);\n    }\n\n                                                                        \n                                                                             \n    int kInt = int(k);\n    int nInt = kInt & (~kInt + 1);\n    float n = float(nInt);\n                                \n                                                                                        \n    float theta0 = material.distance;\n    float theta1 = n * theta0;\n\n                                                    \n                                   \n                                                  \n           \n\n    float c = 0.66;\n    float sinPh1 = sin(c * theta0) / sin(theta1);\n    float phi1 = asin(clamp(sinPh1, 0., 1.));\n\n    float coeff = ((0.5 * PI - phi1) - abs(0.5 * PI - phi)) / material.fadingAmplitude + 0.5;\n    coeff = clamp(coeff, 0., 1.);\n    vec3 base = coeff * material.stripColor + (1. - coeff) * material.bgColor;\n    return vec4(base, 1);\n\n                         \n                                                                                       \n                                                                           \n                                       \n                                                        \n      \n                                                        \n}"},3496:e=>{e.exports="                                                                                                                        \n                  \n                                            \n                                                     \n                                                                                                                        \n\nvec4 normalMaterialRender(ExtVector v, RelVector normal) {\n    Vector[3] f;\n    Point pos = applyGroupElement(v.vector.cellBoost, v.vector.local.pos);\n    frame(pos, f);\n\n    f[0] = applyGroupElement(v.vector.invCellBoost, f[0]);\n    f[1] = applyGroupElement(v.vector.invCellBoost, f[1]);\n    f[2] = applyGroupElement(v.vector.invCellBoost, f[2]);\n    \n                  \n                            \n    float r =  geomDot(normal.local, f[0]);\n    float g =  geomDot(normal.local, f[1]);\n    float b =  geomDot(normal.local, f[2]);\n    return abs(vec4(r, g, b, 1));\n}"},7198:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct PathTracerWrapMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(PathTracerWrapMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\n"},6045:e=>{e.exports="                                                                                                                        \n                 \n                                                                                                                        \n\nstruct PhongMaterial {\n    vec3 color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, PhongMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * material.color;\n    vec3 ambient = ambientCoeff * ambientLight * material.color;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},5836:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct PhongWrapMaterial {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, vec3 baseColor, PhongWrapMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * baseColor;\n    vec3 ambient = ambientCoeff * ambientLight * baseColor;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},1220:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct RotatedSphericalTextureMaterial {\n    sampler2D sampler;\n    mat4 rotation;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(RotatedSphericalTextureMaterial material, ExtVector v, vec2 uv) {\n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n    vec2 texCoords = (rotatedUV - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},9095:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SimpleTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(SimpleTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},2664:e=>{e.exports="                                                                                                                        \n                        \n                                                                                                                        \n\nstruct SingleColorMaterial {\n    vec3 color;\n};\n\nvec4 render(SingleColorMaterial material, ExtVector v) {\n    return vec4(material.color, 1);\n}"},3081:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SquaresMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(SquaresMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x1 = mod(dot(uv, material.dir1) / dot(material.dir1, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2) / dot(material.dir2, material.dir2), 2.);\n    float c1 = abs(x1 - 1.);\n    float c2 = abs(x2 - 1.);\n    if (c1 < material.lengths.x && c2 < material.lengths.x){\n        color = material.color0;\n    } else if (c1 < material.lengths.y && c2 < material.lengths.y){\n        color = material.color1;\n    } else if (c1 < material.lengths.z && c2 < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n    return vec4(color, 1);\n}\n\n"},9835:e=>{e.exports="                                                                                                                        \n          \n                  \n                                                                                                                        \nstruct StripsMaterial {\n    vec2 dir;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(StripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x = mod(dot(uv, material.dir) / dot(material.dir, material.dir), 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}\n\n"},1888:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionLocalWrapMaterial {\n    GroupElement cellBoost;\n    float ratio;\n};\n"},5698:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionWrapMaterial {\n    float ratio;\n};\n"},2229:e=>{e.exports="\n\n                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoAlphaTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoAlphaTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    vec2 texCoordsUV = vec2(texCoords.x, 0.5 + 0.5 * texCoords.y);\n    vec2 texCoordsAlpha = vec2(texCoords.x, 0.5 * texCoords.y);\n    vec4 color =  texture(material.sampler, texCoordsUV);\n    float alpha = texture(material.sampler, texCoordsAlpha).x;\n    return vec4(color.rgb, alpha);\n}"},4680:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoFrameTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoFrameTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},533:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},6947:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = exposure * color.rgb;\n    pixelColor = ACESFilm(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},2690:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 postProcess(vec3 pixelColor){\n\n                      \n    pixelColor *= exposure;\n\n                   \n    pixelColor = ACESFilm(pixelColor);\n    pixelColor = LinearToSRGB(pixelColor);\n\n    return pixelColor;\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 aux = postProcess(color.rgb);\n    gl_FragColor = vec4(min(vec3(1.0), aux), color.a);\n}"},4024:e=>{e.exports="uniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = color.rgb;\n    pixelColor = LinearToSRGB(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},5348:e=>{e.exports="vec3 applyFog(vec3 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * fog.color;\n}\n\nvec4 applyFog(vec4 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * vec4(fog.color, 1);\n}"},7885:e=>{e.exports="                                                                                                                        \n  \n          \n                                 \n  \n                                                                                                                        \n\nstruct ExpFog {\n    vec3 color;                             \n    float scattering;                                                    \n};\n"},7333:e=>{e.exports="struct IntersectionShape {\n    float maxCoeff;\n};"},519:e=>{e.exports="struct UnionShape {\n    float minCoeff;\n};\n"},4750:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec3 dir = vec3(coords.xy, -1. / tan(0.5 * camera.fovRadians));\n    Vector v = createVector(ORIGIN, dir);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},8710:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fovRadians;                                          \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},6224:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},1353:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},872:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},6684:e=>{e.exports="   \n                                                                                                 \n                                                                                        \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}\n\n   \n                                                                                             \n                                                               \n   \nRelVector mappingFromFlatScreen(vec2 coords) {\n                                                         \n    vec2 jitter = vec2(randomFloat(), randomFloat()) - 0.5;\n\n                                                                            \n    vec2 planeCoords = (coords - 0.5 * resolution + jitter) / (0.5 * resolution.y);\n\n                              \n    float z = - 1. / tan(radians(0.5 * camera.fov));\n\n                                                      \n    vec4 dir = vec4(planeCoords, z, 0);\n\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},6354:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n    float focalLength;                    \n    float aperture;                \n};"},9222:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}\n\n                     \n\n  \n                               \n                               \n                         \n                                             \n                                                      \n                              \n \n  "},5970:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},5682:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},4770:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}"},8415:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},190:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n\nVector geomMix(Vector v1, Vector v2, float a){\n    return add(multiplyScalar(1.-a, v1), multiplyScalar(a, v2));\n}\n\n   \n                                           \n                         \n             \n   \nVector negate(Vector v) {\n    return multiplyScalar(-1., v);\n}\n\n\n   \n                                         \n                       \n   \nfloat geomLength(Vector v){\n    return sqrt(geomDot(v, v));\n}\n\n   \n                                                          \n                            \n   \nVector geomNormalize(Vector v){\n    float a = geomLength(v);\n    return multiplyScalar(1./a, v);\n}\n\n   \n                                                     \n   \nfloat cosAngle(Vector v1, Vector v2){\n    float a1 = geomLength(v1);\n    float a2 = geomLength(v2);\n    return geomDot(v1, v2)/ (a1 * a2);\n}\n\n   \n                                                           \n                                   \n                                                                                                        \n                                     \n                                                                   \n                                                                       \n   \nVector geomReflect(Vector v, Vector n){\n    return sub(v, multiplyScalar(2. * geomDot(v, n), n));\n}\n\n\n   \n                                         \n                                                                        \n                                                                                   \n                                              \n   \nVector geomRefract(Vector v, Vector n, float r){\n    float cosTheta1 = -geomDot(n, v);\n    float sinTheta2Sq = r * r * (1. - cosTheta1 * cosTheta1);\n\n    if (sinTheta2Sq > 1.){\n               \n        return zeroVector(v.pos);\n    }\n                                                                 \n    float cosTheta2 = sqrt(1. - sinTheta2Sq);\n    float aux = r * cosTheta1 - cosTheta2;\n    return add(multiplyScalar(r, v), multiplyScalar(aux, n));\n}\n\n   \n                                                                          \n                                           \n   \nIsometry makeTranslation(Vector v) {\n    return makeTranslation(v.pos);\n}\n\n   \n                                                                          \n                                              \n   \nIsometry makeInvTranslation(Vector v) {\n    return makeInvTranslation(v.pos);\n}\n"},4168:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                                                                         \n               \n   \nVector createVector(Point p, vec3 coords, Vector[3] frame){\n    Vector c0 = multiplyScalar(coords[0], frame[0]);\n    Vector c1 = multiplyScalar(coords[1], frame[1]);\n    Vector c2 = multiplyScalar(coords[2], frame[2]);\n    return add(c0, add(c1, c2));\n}\n\n\n\n   \n                                                                                          \n               \n   \nVector createVector(Point p, vec3 coords){\n    Vector[3] f;\n    frame(p, f);\n    return createVector(p, coords, f);\n}\n\n   \n                                                                                          \n               \n   \nVector createVectorOrtho(Point p, vec3 coords){\n    Vector[3] f;\n    orthoFrame(p, f);\n    return createVector(p, coords, f);\n}\n\n\n                                                                                                                        \n  \n                   \n                                                             \n                                                                       \n  \n                                                                                                                        \n\nstruct Position {\n    Isometry boost;\n    mat4 facing;\n};\n\n\n   \n                                        \n                          \n                                           \n   \nVector applyPosition(Position p, Vector v){\n    Vector res = applyFacing(p.facing, v);\n    return applyIsometry(p.boost, res);\n}"},2311:e=>{e.exports="   \n              \n                                \n   \nPoint applyIsometry(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\nPoint applyGroupElement(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\n   \n              \n                                \n   \nVector applyIsometry(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\nVector applyGroupElement(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\n\n"},5315:e=>{e.exports="   \n                          \n   \nvarying vec3 screenPosition;\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    RelVector vector = mapping(screenPosition);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = postProcess(getColor(v));\n}"},6159:e=>{e.exports="vec4 postProcess(vec4 color) {\n    return color;\n}"},2977:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n        }\n    }\n\n                               \n                     \n       \n\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + dist;\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    v = flow(v, camera.safetyDist);\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = raymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return v.data.pixel;\n}"},9461:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec4 pixel;                                                                   \n    vec4 leftToComputeColor;                                                                      \n};"},1767:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                             \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n              \n   \nconst float PI = 3.1415926538;\n\n   \n                      \n   \nvec4 debugColor = vec4(0.5, 0, 0.8, 1);\n\n   \n                                    \n         \n   \nconst int HIT_NOTHING = 0;\n   \n                                    \n         \n   \nconst int HIT_SOLID = 1;\n   \n                                  \n         \n   \nconst int HIT_DEBUG = -1;\n"},7962:e=>{e.exports="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"},8187:e=>{e.exports="   \n                          \n   \nvarying vec3 spherePosition;\n\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    initSeed(gl_FragCoord.xy, frameSeed);\n    RelVector vector = mappingFromFlatScreen(gl_FragCoord.xy);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = getColor(v);\n}\n"},9638:e=>{e.exports="   \n                                                \n  \n   \nuint seed;\n\n   \n                                                \n                                                                  \n                                                \n                                                                                                         \n   \nvoid initSeed(vec2 coords, uint frameSeed){\n    uvec2 aux = uvec2(coords);\n    seed =  aux.x * uint(1973) + aux.y * uint(925277) + frameSeed * uint(26699) | uint(1);\n}\n\n   \n                           \n               \n                                                                                                     \n   \nuint wangHash() {\n    seed = (seed ^ uint(61)) ^ (seed >> uint(16));\n    seed = seed * uint(9);\n    seed = seed ^ (seed >> 4);\n    seed = seed * uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n   \n                                                  \n   \nfloat randomFloat() {\n    return float(wangHash()) / 4294967296.;\n}\n\n   \n                                                                           \n                                                                                                    \n                                                                                                       \n                                          \n   \nvec3 randomUnitVec3() {\n    float z = randomFloat() * 2. - 1.;\n    float theta = randomFloat() * 2. * PI;\n    float r = sqrt(1. - z * z);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x, y, z);\n}\n\n   \n                                                   \n                                                      \n   \nVector randomVector(Point p) {\n    vec3 dir = randomUnitVec3();\n    return createVectorOrtho(p, dir);\n}\n\n   \n                                                                     \n                                                                                               \n   \nvec2 randomNormal2D(){\n    float u = randomFloat();\n    float v = randomFloat();\n\n    float r = sqrt(abs(2. * log(u)));\n    float x = r * cos(2. * PI * v);\n    float y = r * sin(2. * PI * v);\n\n    return vec2(x, y);\n\n}\n\n   \n                                                      \n   \nfloat randomNormal(float mean, float stdev){\n\n                           \n    float x = randomNormal2D().x;\n\n                                   \n    return stdev * x + mean;\n}\n"},7920:e=>{e.exports="   \n                                                                                      \n  \n   \n\n\n   \n                                                                                   \n                                                                          \n                                                       \n   \nRelVector randomVector(RelVector v) {\n    v.local = randomVector(v.local.pos);\n    return v;\n}"},3499:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n                                                                  \n                                                                                         \n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + abs(dist);\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nbool doesItScatter(inout float dist, float opticalDepth){\n                          \n    if (opticalDepth>100.){\n        return false;\n    }\n    else {\n        float probScatter=1.-exp(-dist/opticalDepth);\n        float flip=randomFloat();\n        if (flip<probScatter){\n                                           \n                                                \n            dist=dist*randomFloat();\n            return true;\n        }\n                                              \n        return false;\n    }\n}\n\n\nvoid scatterRay(inout ExtVector v){\n                                         \n    RelVector w=randomVector(v.vector);\n\n                                                 \n                                                  \n    v.vector=w;\n                                             \n                                                      \n}\n\n\n\nint scatterRaymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n    float d;\n    bool doScatter;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n\n                                          \n            d=abs(dist);\n            doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                                \n            marchingStep = marchingStep + creepingDist(localV, d, camera.threshold);\n            localV = flow(localV0, marchingStep);\n\n\n                                               \n                                                                              \n\n                                                       \n            if (doScatter){\n                scatterRay(localV);\n            }\n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n\n                                      \n        d=abs(dist);\n        doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                            \n        marchingStep = marchingStep + d;\n        globalV = flow(globalV0, marchingStep);\n\n                                                   \n        if (doScatter){\n            scatterRay(globalV);\n        }\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = scatterRaymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return vec4(v.data.pixel,1);\n}"},3888:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n           \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct RayType{\n    bool diffuse;\n    bool reflect;\n    bool refract;\n    float chance;\n};\n\n                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec3 pixel;         \n    vec3 light;         \n    vec3 currentAbsorb;                                                    \n    vec3 currentEmission;                                                             \n    float currentOpticalDepth;                                                              \n    bool isInside;                                        \n};\n\n"},8351:e=>{e.exports="vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec4 postProcess(vec4 pixelColor) {\n\n                      \n    pixelColor.xyz *= exposure;\n\n                   \n    pixelColor.xyz = ACESFilm(pixelColor.xyz);\n    pixelColor.xyz = LinearToSRGB(pixelColor.xyz);\n\n    return pixelColor;\n}"},7499:e=>{e.exports="                                                                                                                        \n  \n           \n                               \n  \n                                                                                                                        \n \n struct Solid {\n    bool isRendered;\n };\n"},7970:e=>{e.exports="                                                                                                                        \n  \n                      \n                                                        \n                                                                     \n                        \n                                                                                 \n                                                                                 \n                                                                                   \n                                                                                    \n                                                                       \n                                                                                                                        \n\nstruct RelPosition {\n    Position local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n                                                                                                                        \n  \n                    \n                                  \n                                                                       \n                      \n                                                                                 \n                                                                                 \n                                                                            \n                                                                                    \n                                                                                                                        \n\nstruct RelVector {\n    Vector local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n   \n                                                            \n   \nRelVector reduceError(RelVector v){\n    v.local = reduceError(v.local);\n    return v;\n}\n\n   \n                         \n                            \n                                                      \n   \nRelVector add(RelVector v1, RelVector v2){\n    v1.local = add(v1.local, v2.local);\n    return v1;\n}\n\n   \n                              \n                            \n                                                      \n   \nRelVector sub(RelVector v1, RelVector v2){\n    v1.local = sub(v1.local, v2.local);\n    return v1;\n}\n\n   \n                                   \n                         \n                      \n   \nRelVector multiplyScalar(float s, RelVector v){\n    v.local = multiplyScalar(s, v.local);\n    return v;\n}\n\n   \n                                                                                 \n                     \n                                                        \n   \nfloat geomDot(RelVector v1, RelVector v2) {\n    return geomDot(v1.local, v2.local);\n}\n\n   \n                              \n   \nRelVector geomNormalize(RelVector v){\n    v.local = geomNormalize(v.local);\n    return v;\n}\n\n   \n                                   \n                                                        \n   \nRelVector geomMix(RelVector v1, RelVector v2, float a) {\n    v1.local = geomMix(v1.local, v2.local, a);\n    return v1;\n}\n\n   \n                                            \n   \nRelVector negate(RelVector v){\n    v.local = negate(v.local);\n    return v;\n}\n\n   \n                                                                     \n                                                       \n   \nRelVector geomReflect(RelVector v, RelVector normal){\n    v.local = geomReflect(v.local, normal.local);\n    return v;\n}\n\n\n   \n                                                                     \n                                                       \n   \nRelVector geomRefract(RelVector v, RelVector normal, float n){\n    v.local = geomRefract(v.local, normal.local, n);\n    return v;\n}\n\n   \n                         \n                                            \n                                                                         \n   \nRelVector flow(RelVector v, float t) {\n    v.local = flow(v.local, t);\n    return v;\n}\n\n   \n                                                                                          \n                                                                           \n                                                                          \n                               \n                                                                                              \n   \nRelVector smallShift(RelVector v, vec3 dp){\n    v.local = smallShift(v.local, dp);\n    return v;\n                                                 \n                                                               \n}\n\n\n   \n                                                                                                            \n                           \n                                                   \n                                                                                             \n                                            \n   \n                                                   \n                                                   \n               \n                                                             \n                                                                 \n   \n\n   \n                                                                                                            \n                                                   \n                                                                                             \n   \nRelVector createRelVector(RelVector v, vec3 coords){\n    v.local =  createVector(v.local.pos, coords);\n    return v;\n                                                           \n                                                               \n}\n\n   \n                                                                  \n                          \n                                           \n   \nRelVector applyPosition(RelPosition position, Vector v) {\n    Vector local = applyPosition(position.local, v);\n    return RelVector(local, position.cellBoost, position.invCellBoost);\n}\n\n   \n                                                                                                                    \n   \nRelVector rewrite(RelVector v, GroupElement elt, GroupElement inv){\n    v.local = applyGroupElement(elt, v.local);\n                                     \n                                       \n    v.cellBoost = multiply(v.cellBoost, inv);\n    v.invCellBoost = multiply(elt, v.invCellBoost);\n    return v;\n}\n\n\n                                                                                                                        \n  \n                    \n                                    \n                                                                              \n                  \n                                                      \n                                                                                         \n  \n                                                                                                                        \n\nstruct ExtVector {\n    RelVector vector;\n    VectorData data;\n};\n\n\nExtVector flow(ExtVector v, float t) {\n    v.vector = flow(v.vector, t);\n    v.data.lastFlowDist = t;\n    v.data.lastBounceDist = v.data.lastBounceDist + t;\n    v.data.totalDist  = v.data.totalDist + t;\n    return v;\n}\n\n\n\n"},3474:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n                                                                \n                                         \n                           \n    float aux = 1. - camera.center / camera.focus;\n    float h = camera.radius / (camera.ratio * aux);\n    float t = tan(0.5 * camera.fov);\n                          \n    vec2 xy = h * coords.xy / (coords.z * t);\n    vec4 m = vec4(xy, 0., 1.);\n                \n    float eps = sign(camera.focus);\n    vec4 u = eps * vec4(xy, -camera.focus, 0.);\n\n                                                                               \n    m = camera.matrix * m;\n    u = camera.matrix * u;\n                              \n    Vector v = createVector(Point(m), u.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},9642:e=>{e.exports="                                                                                                                        \n          \n               \n                                                                                               \n                                                                                                                        \nstruct DollyCamera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n    float focus;\n    float center;\n    float radius;\n    float ratio;\n};"},3219:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                    \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n  \n                   \n                                            \n  \n                                                                                                                        \nstruct Isometry{\n    mat4 matrix;\n};\n\n   \n                    \n   \nconst Isometry IDENTITY = Isometry(mat4(1.));                          \n\n   \n                                                              \n                      \n   \nIsometry reduceError(Isometry isom){\n    return isom;\n}\n\n   \n                                     \n   \nIsometry multiply(Isometry isom1, Isometry isom2) {\n    return Isometry(isom1.matrix * isom2.matrix);\n}\n\n   \n                                            \n   \nIsometry geomInverse(Isometry isom) {\n    mat4 inv = inverse(isom.matrix);\n    return Isometry(inv);\n}\n\n                                                                                                                        \n  \n                \n                                        \n  \n                                                                                                                        \nstruct Point{\n    vec4 coords;\n};\n\n\nconst Point ORIGIN = Point(vec4(0, 0, 0, 1));                              \n\n\n   \n                                                           \n   \nPoint reduceError(Point p){\n    return p;\n}\n\n   \n                                       \n   \nPoint applyIsometry(Isometry isom, Point p) {\n    vec4 coords = isom.matrix * p.coords;\n    return Point(coords);\n}\n\n   \n                                                                     \n                                  \n   \n\nIsometry makeTranslation(Point p) {\n    vec4 c = p.coords;\n    mat4 matrix =  mat4(\n    1, 0., 0., 0.,\n    0., 1, 0., 0.,\n    0., 0., 1., 0,\n    c.x, c.y, c.z, 1.\n    );\n    return Isometry(matrix);\n}\n\n   \n                                                                     \n                                     \n   \nIsometry makeInvTranslation(Point p) {\n    vec4 c = p.coords;\n    mat4 matrix =  mat4(\n    1, 0., 0., 0.,\n    0., 1, 0., 0.,\n    0., 0., 1., 0,\n    -c.x, -c.y, -c.z, 1.\n    );\n    return Isometry(matrix);\n}\n\n                                                                                                                        \n  \n                 \n                                                              \n                                                                                                  \n  \n                                                                                                                        \nstruct Vector{\n    Point pos;                     \n    vec4 dir;                            \n};\n\n   \n                                \n   \nVector zeroVector(Point pos){ \n    return Vector(pos, vec4(0)); \n}\n\n   \n                                                            \n   \nVector reduceError(Vector v){\n    return v;\n}\n\n   \n                         \n                            \n   \nVector add(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir + v2.dir);\n}\n\n   \n                              \n                            \n   \nVector sub(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir - v2.dir);\n}\n\n   \n                                   \n                         \n                      \n   \nVector multiplyScalar(float s, Vector v){\n    return Vector(v.pos, s * v.dir);\n}\n\n\n   \n                                                                                 \n                     \n   \nfloat geomDot(Vector v1, Vector v2) {\n    return dot(v1.dir, v2.dir);\n}\n\n\n   \n                                        \n   \nVector applyIsometry(Isometry isom, Vector v) {\n    Point p = applyIsometry(isom, v.pos);\n    return Vector(p, isom.matrix * v.dir);\n}\n\n\n   \n                                                                         \n                                                                                                           \n                                           \n   \nVector applyFacing(mat4 m, Vector v) {\n    return Vector(v.pos, m * v.dir);\n}\n\nvoid initFlow(Vector v){\n}\n"},1999:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                    \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                               \n                                                                       \n                                     \n                                                      \n   \nvoid frame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec4(1, 0, 0, 0));\n    f[1] = Vector(p, vec4(0, 1, 0, 0));\n    f[2] = Vector(p, vec4(0, 0, 1, 0));\n}\n\n   \n                                           \n                                                                       \n                                     \n                                                      \n   \nvoid orthoFrame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec4(1, 0, 0, 0));\n    f[1] = Vector(p, vec4(0, 1, 0, 0));\n    f[2] = Vector(p, vec4(0, 0, 1, 0));\n}\n\n   \n                                                                                         \n                              \n                                                                                              \n   \nPoint smallShift(Point p, vec3 dp){\n    vec4 aux = vec4(dp, 0);\n    return Point(p.coords + aux);\n}\n\nVector smallShift(Vector v, vec3 dp){\n    Point pos = smallShift(v.pos, dp);\n    return Vector(pos, v.dir);\n}\n\n\n   \n                                  \n                                                 \n   \nVector flow(Vector v, float t){\n    vec4 coords = v.pos.coords + t * v.dir;\n    Point p = Point(coords);\n    return Vector(p, v.dir);\n}\n"},6599:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct GroupElement {\n    ivec3 icoords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(ivec3(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(elt1.icoords + elt2.icoords);\n}\n\n                                              \n                                        \n   \n\nIsometry toIsometry(GroupElement elt) {\n    vec3 c = vec3(elt.icoords);\n    vec4 t = 2. * (c.x * group.halfTranslationA + c.y * group.halfTranslationB + c.z * group.halfTranslationC);\n    mat4 matrix =  mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    t.x, t.y, t.z, 1\n    );\n    return Isometry(matrix);\n}"},9106:e=>{e.exports="                                                                                                                        \n          \n                                      \n                                                                                                                        \n\nstruct Group {\n    vec4 halfTranslationA;\n    vec4 halfTranslationB;\n    vec4 halfTranslationC;\n    mat4 dotMatrix;\n};"},6678:e=>{e.exports="struct GroupElement {\n    ivec3 irotation;\n    ivec3 itranslation;\n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(ivec3(1), ivec3(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    ivec3 rotation = elt1.irotation * elt2.irotation;\n    ivec3 transaltion = elt1.itranslation + elt1.irotation * elt2.itranslation;\n    return GroupElement(rotation, transaltion);\n}\n\nIsometry toIsometry(GroupElement elt) {\n    ivec3 a = elt.irotation;\n    vec3 t = group.length * vec3(elt.itranslation);\n    mat4 matrix =  mat4(\n    a.x, 0, 0, 0,\n    0, a.y, 0, 0,\n    0, 0, a.z, 0,\n    t.x, t.y, t.z, 1\n    );\n    return Isometry(matrix);\n}"},3794:e=>{e.exports="struct Group {\n    float length;\n};"},4693:e=>{e.exports="                                                                                                                        \n          \n                                              \n                                                                                                                        \n\nstruct GroupElement {\n    ivec3 icoords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(ivec3(0));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    int flip = 1 - 2 * int(mod(float(elt1.icoords.x), 2.));\n    elt2.icoords.y = flip * elt2.icoords.y;\n    return GroupElement(elt1.icoords + elt2.icoords);\n}\n\nIsometry toIsometry(GroupElement elt) {\n    vec3 t = 2. * group.halfWidth * vec3(elt.icoords);\n    float flip = 1. - 2. * mod(float(elt.icoords.x), 2.);\n    mat4 matrix =  mat4(\n    1, 0, 0, 0,\n    0, flip, 0, 0,\n    0, 0, flip, 0,\n    t.x, t.y, t.z, 1\n    );\n    return Isometry(matrix);\n}"},733:e=>{e.exports="                                                                                                                        \n          \n                                                                 \n                                                                                                                        \n\nstruct Group {\n    float halfWidth;\n};"},8011:e=>{e.exports="   \n                              \n   \nfloat dist(Point p1, Point p2){\n    return length(p1.coords - p2.coords);\n}\n"},2898:e=>{e.exports="   \n                                                                                   \n                                                  \n                                        \n                                \n  \nfloat lightIntensity(float len){\n                            \n    return 1./ len;\n}\n"},7091:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct ConstDirLight {\n    int id;\n    vec3 color;\n    float intensity;\n    vec3 direction;\n    int maxDirs;\n};\n\nbool directions(ConstDirLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    intensity = light.intensity;\n                                                             \n                                                                        \n    vec4 coords = vec4(light.direction, 0.);\n    Vector local = Vector(v.local.pos, coords);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},2297:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct LocalPointLight {\n    int id;\n    Point position;\n    vec3 color;\n    float intensity;\n    int maxDirs;\n};\n\nbool directions(LocalPointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n                                                                         \n    vec4 aux = light.position.coords - v.local.pos.coords;\n    intensity = lightIntensity(length(aux)) * light.intensity;\n    aux = normalize(aux);\n    Vector local = Vector(v.local.pos, aux);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}\n"},6313:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct PointLight {\n    int id;\n    Point position;\n    vec3 color;\n    float intensity;\n    int maxDirs;\n};\n\nbool directions(PointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    Point position = applyGroupElement(v.invCellBoost, light.position);\n    vec4 aux = position.coords - v.local.pos.coords;\n    intensity = lightIntensity(length(aux)) * light.intensity;\n    aux = normalize(aux);\n    Vector local = Vector(v.local.pos, aux);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}\n"},9030:e=>{e.exports="                                                                                                                        \n                       \n                                                                                                                        \n\nstruct MultiColorMaterial {\n    vec3 mainColor;\n    vec3 accent1;\n    vec3 accent2;\n    vec3 accent3;\n    bool grid;\n};\n\nvec4 render(MultiColorMaterial material, ExtVector v) {\n\n    vec3 dir = normalize(v.vector.local.pos.coords.xyz);\n    vec3 color = material.mainColor;\n    color += material.accent1 * dir.x;\n    color += material.accent2 * dir.y;\n    color += material.accent3 * dir.z;\n\n    float x = v.vector.local.pos.coords.x;\n    float y = v.vector.local.pos.coords.y;\n    float z = v.vector.local.pos.coords.z;\n\n    if(material.grid){\n        float test = sin(70.*x)*sin(70.*y)*sin(70.*z);\n        float sgn = sign(test);\n        if (sgn<0.){\n            color *=0.9;\n        }\n    }\n\n    return vec4(color, 1);\n}"},1754:e=>{e.exports="                                                                                                                        \n                         \n                                                                                                                        \n\nstruct VaryingColorMaterial {\n    vec3 mainColor;\n    vec3 weight;\n};\n\nvec4 render(VaryingColorMaterial material, ExtVector v) {\n    vec3 color = material.mainColor + material.weight * v.vector.local.pos.coords.xyz;\n    return vec4(color, 1);\n}"},1241:e=>{e.exports="                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct BallShape {\n    int id;\n    Point center;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                                \n   \nfloat sdf(BallShape ball, RelVector v) {\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    vec4 w = center.coords - v.local.pos.coords;\n    return length(w) - ball.radius;\n}\n\n   \n                                             \n   \nRelVector gradient(BallShape ball, RelVector v){\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    Vector local = Vector(v.local.pos, v.local.pos.coords - center.coords);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(BallShape ball, RelVector v){\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    vec4 dir = point.coords - ball.center.coords;\n    dir.w = 0.;\n    dir = ball.absoluteIsomInv.matrix * dir;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}"},7479:e=>{e.exports="                                                                                                                        \n          \n                           \n                                                                                                                        \n\nstruct BoxShape {\n    int id;\n    Point center;\n    vec3 sides;\n    float rounded;\n};\n\n   \n                                                \n   \nfloat sdf(BoxShape box, RelVector v) {\n    Point center = applyGroupElement(v.invCellBoost, box.center);\n    vec4 w = center.coords - v.local.pos.coords;\n                                                \n    vec3 q = abs(w.xyz) - box.sides;\n             \n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - box.rounded;\n}\n\n   \n                                            \n   \n                                                  \n                                                                    \n                                                                             \n                                   \n                                                           \n   \n\n"},3510:e=>{e.exports="                                                                                                                        \n          \n                                         \n                                                                                                                        \n\nstruct CylinderShape {\n    int id;\n    Vector vector;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                          \n   \nfloat sdf(CylinderShape cylinder, RelVector v) {\n    Point point = applyIsometry(v.invCellBoost, cylinder.vector.pos);\n    vec4 dir = toIsometry(v.invCellBoost).matrix * cylinder.vector.dir;\n    vec4 pm = v.local.pos.coords - point.coords;\n    vec4 qm = pm - dot(pm, dir) * dir;\n    return length(qm) - cylinder.radius;\n}\n\n   \n                                       \n   \nRelVector gradient(CylinderShape cylinder, RelVector v){\n    Point point = applyIsometry(v.invCellBoost, cylinder.vector.pos);\n    vec4 dir = toIsometry(v.invCellBoost).matrix * cylinder.vector.dir;\n    vec4 pm = v.local.pos.coords - point.coords;\n    vec4 qm = pm - dot(pm, dir) * dir;\n    Vector local = Vector(v.local.pos, qm);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\n   \n                               \n   \nvec2 uvMap(CylinderShape cylinder, RelVector v){\n    Point m = applyIsometry(v.cellBoost, v.local.pos);\n    vec4 pm = m.coords - cylinder.vector.pos.coords;\n    pm.w = 0.;\n    vec4 pm_pullback = cylinder.absoluteIsomInv.matrix * pm;\n    float uCoord = atan(pm_pullback.y, pm_pullback.x);\n    float vCoord = pm_pullback.z;\n    return vec2(uCoord, vCoord);\n}"},5064:e=>{e.exports="                                                                                                                        \n          \n                       \n                                                                                                                        \n\nstruct HalfSpaceShape {\n    Vector normal;                                 \n    vec3 uDir;                                       \n    vec3 vDir;                                       \n};\n\n                                                                                                            \nfloat sdf(HalfSpaceShape halfspace, RelVector v){\n    Vector normal = applyGroupElement(v.invCellBoost, halfspace.normal);\n    float dotp = dot(v.local.pos.coords - normal.pos.coords, normal.dir);\n    if (abs(dotp) < camera.threshold){\n        return dotp;\n    }\n    float dotv = dot(v.local.dir, normal.dir);\n    if (dotv * dotp >= 0.){\n        return sign(dotp) * camera.maxDist;\n    }\n    return - abs(dotp) / dotv;\n}\n\nRelVector gradient(HalfSpaceShape halfspace, RelVector v){\n    Vector normal = applyGroupElement(v.invCellBoost, halfspace.normal);\n    Vector local = Vector(v.local.pos, normal.dir);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(HalfSpaceShape halfspace, RelVector v){\n    Point pos = applyGroupElement(v.invCellBoost, halfspace.normal.pos);\n    Isometry isom = toIsometry(v.invCellBoost);\n    vec4 uDir = isom.matrix * vec4(halfspace.uDir, 0);\n    vec4 vDir = isom.matrix * vec4(halfspace.vDir, 0);\n    float uCoord = dot(v.local.pos.coords - pos.coords, uDir);\n    float vCoord = dot(v.local.pos.coords - pos.coords, vDir);\n    return vec2(uCoord, vCoord);\n}\n\n"},7111:e=>{e.exports="                                                                                                                        \n          \n                                  \n                                                                                                                        \n\nstruct LocalBallShape {\n    int id;\n    Point center;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                                \n   \nfloat sdf(LocalBallShape ball, RelVector v) {\n    vec4 w =  ball.center.coords  - v.local.pos.coords;\n    return length(w) - ball.radius;\n}\n\n   \n                                             \n   \nRelVector gradient(LocalBallShape ball, RelVector v){\n    Vector local = Vector(v.local.pos, v.local.pos.coords - ball.center.coords);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalBallShape ball, RelVector v){\n    vec4 dir = v.local.pos.coords - ball.center.coords;\n    dir.w = 0.;\n    dir = ball.absoluteIsomInv.matrix * dir;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n\n"},793:e=>{e.exports="                                                                                                                        \n          \n                                               \n                                                                                                                        \n\nstruct LocalCylinderShape {\n    int id;\n    Vector vector;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                          \n   \nfloat sdf(LocalCylinderShape cylinder, RelVector v) {\n    Point p = cylinder.vector.pos;\n    vec4 dir = cylinder.vector.dir;\n    vec4 pm = v.local.pos.coords - p.coords;\n    vec4 qm = pm - dot(pm, dir) * dir;\n    return length(qm) - cylinder.radius;\n}\n\n   \n                                       \n   \nRelVector gradient(LocalCylinderShape cylinder, RelVector v){\n    Point p = cylinder.vector.pos;\n    vec4 dir = cylinder.vector.dir;\n    vec4 pm = v.local.pos.coords - p.coords;\n    vec4 qm = pm - dot(pm, dir) * dir;\n    Vector local = Vector(v.local.pos, qm);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\n   \n                               \n   \nvec2 uvMap(LocalCylinderShape cylinder, RelVector v){\n    Point m = v.local.pos;\n    vec4 pm = m.coords - cylinder.vector.pos.coords;\n    pm.w = 0.;\n    vec4 pm_pullback = cylinder.absoluteIsomInv.matrix * pm;\n    float uCoord = atan(pm_pullback.y, pm_pullback.x);\n    float vCoord = pm_pullback.z;\n    return vec2(uCoord, vCoord);\n}"},2130:e=>{e.exports="                                                                                                                        \n          \n                                  \n                                                                                                                        \n\nstruct LocalDirectedBallShape {\n    int id;\n    Point center;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                                \n   \nfloat sdf(LocalDirectedBallShape ball, RelVector v) {\n    vec4 w =  ball.center.coords  - v.local.pos.coords;\n    float d = length(w);\n    float diff = d - ball.radius;\n                                              \n    if (diff <= 0.){\n        return diff;\n    }\n    float dotProduct = dot(v.local.dir, w);\n                                                       \n    if (dotProduct < 0.){\n        return camera.maxDist;\n    }\n                                              \n    float d2 = d * d;\n    float cos0Sq = (d2 - ball.radius * ball.radius) / d2;\n    float cos1Sq = dotProduct * dotProduct / d2;\n    if (cos1Sq < cos0Sq){\n        return camera.maxDist;\n    }\n\n    return diff;\n\n}\n\n   \n                                             \n   \nRelVector gradient(LocalDirectedBallShape ball, RelVector v){\n    Vector local = Vector(v.local.pos, v.local.pos.coords - ball.center.coords);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalDirectedBallShape ball, RelVector v){\n    vec4 dir = v.local.pos.coords - ball.center.coords;\n    dir.w = 0.;\n    dir = ball.absoluteIsomInv.matrix * dir;\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n\n"},5688:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                            \n  \n                                                                                                                        \n                                                                                                                        \n\n\n"}},n={};function r(e){var a=n[e];if(void 0!==a)return a.exports;var o=n[e]={exports:{}};return t[e](o,o.exports,r),o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})();var a={};(()=>{r.d(a,{T0:()=>Ko,FJ:()=>Wo,GU:()=>Vt,XH:()=>we,ec:()=>vl,Yb:()=>Zi,ZH:()=>Lt,K9:()=>j,FT:()=>yt,xu:()=>yl,cK:()=>mt,_x:()=>ht,kj:()=>pt,V1:()=>Te,Vz:()=>on,ck:()=>Y,Iy:()=>ja,Vf:()=>Ti,Ab:()=>_l,g6:()=>cl,TB:()=>mn,n$:()=>Ai,ak:()=>ps,Al:()=>zo,ix:()=>dr,jZ:()=>ir,c$:()=>jt,Qj:()=>Oe,mD:()=>Bo,yb:()=>Ct,iJ:()=>cn,ZA:()=>Ye,Jz:()=>_e,eK:()=>vi,Fr:()=>wl,RM:()=>sl,fR:()=>Zr,kK:()=>Gr,ZX:()=>ar,_f:()=>pr,Ht:()=>vr,HZ:()=>No,TN:()=>so,JV:()=>n,Sc:()=>Lo,Nh:()=>Fo,RL:()=>Ve,_k:()=>Mt,uR:()=>jo,gU:()=>Zo,jo:()=>Vl,Q:()=>el,gq:()=>Cl,Gj:()=>hl,s8:()=>Ml,EH:()=>rl,L8:()=>Ii,F5:()=>wt,Uc:()=>rs,Fh:()=>Ho,O5:()=>Bi,oB:()=>$t,pJ:()=>_t,GW:()=>$e,DZ:()=>ve,_K:()=>Ba,JF:()=>en,Lv:()=>Sr,E9:()=>o,ce:()=>wi,Ly:()=>i,iv:()=>ns,mH:()=>Xo,xd:()=>ts,pX:()=>Me,Dz:()=>Ce,Th:()=>h,Uj:()=>Oo,bY:()=>yn,cV:()=>oo,lR:()=>wo,xs:()=>Ft,bn:()=>xt,oC:()=>Go,Z1:()=>fn,h8:()=>Dt,Qf:()=>bl,jE:()=>Ue,k1:()=>Xn,ew:()=>tr,$p:()=>Ao,xG:()=>bt,l_:()=>Va,pk:()=>ca,yI:()=>_o,E6:()=>ke,zO:()=>Le,cB:()=>Pi,OW:()=>s,n3:()=>qn,Se:()=>$n,PQ:()=>jn,$9:()=>Po,t1:()=>ge,uZ:()=>ye,Cy:()=>Oa,qM:()=>Sn,BO:()=>Qs,mV:()=>Xr,Gi:()=>Ar,jV:()=>io,PB:()=>si,j9:()=>In,oc:()=>Rn,wS:()=>Na,IJ:()=>Rr,p2:()=>xe,w0:()=>Dn,VL:()=>Ma,UR:()=>da,dV:()=>Ot,G0:()=>Co,YL:()=>An,re:()=>Uo});const t=(e=>{var t={};return r.d(t,e),t})({BufferGeometry:()=>e.BufferGeometry,Clock:()=>e.Clock,Color:()=>e.Color,EventDispatcher:()=>e.EventDispatcher,Float32BufferAttribute:()=>e.Float32BufferAttribute,HalfFloatType:()=>e.HalfFloatType,ImageLoader:()=>e.ImageLoader,LinearFilter:()=>e.LinearFilter,MathUtils:()=>e.MathUtils,Matrix3:()=>e.Matrix3,Matrix4:()=>e.Matrix4,Mesh:()=>e.Mesh,NearestFilter:()=>e.NearestFilter,NoBlending:()=>e.NoBlending,OrthographicCamera:()=>e.OrthographicCamera,PerspectiveCamera:()=>e.PerspectiveCamera,PlaneGeometry:()=>e.PlaneGeometry,Quaternion:()=>e.Quaternion,RGBAFormat:()=>e.RGBAFormat,RepeatWrapping:()=>e.RepeatWrapping,Scene:()=>e.Scene,ShaderMaterial:()=>e.ShaderMaterial,SphereGeometry:()=>e.SphereGeometry,Texture:()=>e.Texture,TextureLoader:()=>e.TextureLoader,Uniform:()=>e.Uniform,UniformsUtils:()=>e.UniformsUtils,Vector2:()=>e.Vector2,Vector3:()=>e.Vector3,Vector4:()=>e.Vector4,VideoTexture:()=>e.VideoTexture,WebGLRenderTarget:()=>e.WebGLRenderTarget,WebGLRenderer:()=>e.WebGLRenderer});class n{constructor(){this.build(...arguments)}build(){throw new Error("This method need be overloaded.")}get isIsometry(){return!0}identity(){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}multiply(e){throw new Error("This method need be overloaded.")}premultiply(e){throw new Error("This method need be overloaded.")}invert(){return this.matrix.invert(),this}makeTranslation(e){throw new Error("This method need be overloaded.")}makeInvTranslation(e){throw new Error("This method need be overloaded.")}makeTranslationFromDir(e){throw new Error("This method need be overloaded.")}diffExpMap(e){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new n;return e.copy(this),e}}n.prototype.build=function(){this.matrix=new t.Matrix4},n.prototype.identity=function(){return this.matrix.identity(),this},n.prototype.reduceError=function(){return this},n.prototype.multiply=function(e){return this.matrix.multiply(e.matrix),this},n.prototype.premultiply=function(e){return this.matrix.premultiply(e.matrix),this},n.prototype.invert=function(){return this.matrix.invert(),this},n.prototype.makeTranslation=function(e){const[t,n,r]=e.coords.toArray();return this.matrix.set(1,0,0,t,0,1,0,n,0,0,1,r,0,0,0,1),this},n.prototype.makeInvTranslation=function(e){const[t,n,r]=e.coords.toArray();return this.matrix.set(1,0,0,-t,0,1,0,-n,0,0,1,-r,0,0,0,1),this},n.prototype.makeTranslationFromDir=function(e){const[t,n,r]=e.toArray();return this.matrix.set(1,0,0,t,0,1,0,n,0,0,1,r,0,0,0,1),this},n.prototype.makeRotationX=function(e){return this.matrix.makeRotationX(e),this},n.prototype.makeRotationY=function(e){return this.matrix.makeRotationY(e),this},n.prototype.makeRotationZ=function(e){return this.matrix.makeRotationZ(e),this},n.prototype.equals=function(e){return this.matrix.equals(e.matrix)},n.prototype.copy=function(e){return this.matrix.copy(e.matrix),this};class o{constructor(...e){this.build(...e)}build(){throw new Error("This method need be overloaded.")}get isPoint(){return!0}set(){throw new Error("This method need be overloaded.")}applyIsometry(e){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new o;return e.copy(this),e}}o.prototype.build=function(){this.coords=0===arguments.length?new t.Vector4(0,0,0,1):new t.Vector4(...arguments)},o.prototype.set=function(){return this.coords.set(arguments[0],arguments[1],arguments[2],1),this},o.prototype.applyIsometry=function(e){return this.coords.applyMatrix4(e.matrix),this},o.prototype.equals=function(e){return this.coords.equals(e.coords)},o.prototype.reduceError=function(){return this},o.prototype.copy=function(e){return this.coords.copy(e.coords),this};class s extends t.Vector3{get isVector(){return!0}applyMatrix4(e){const n=new t.Vector4(this.x,this.y,this.z,0);return n.applyMatrix4(e),this.set(n.x,n.y,n.z),this}applyFacing(e){return this.applyQuaternion(e.quaternion),this}}class i{constructor(){this.boost=new n,this.quaternion=new t.Quaternion}get isPosition(){return!0}get facing(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion)}setBoost(e){return this.boost.copy(e),this}setQuaternion(e){return this.quaternion.copy(e),this}reduceErrorBoost(){return this.boost.reduceError(),this}reduceErrorQuaternion(){return this.quaternion.normalize(),this}reduceError(){return this.reduceErrorBoost(),this.reduceErrorQuaternion(),this}get point(){return(new o).applyIsometry(this.boost)}reset(){return this.boost.identity(),this.quaternion.identity(),this}applyIsometry(e){return this.boost.premultiply(e),this}applyQuaternion(e){return this.quaternion.multiply(e),this}multiply(e){return this.boost.multiply(e.boost),this.quaternion.premultiply(e.quaternion),this}premultiply(e){return this.boost.premultiply(e.boost),this.quaternion.multiply(e.quaternion),this}flowFromOrigin(e){throw new Error("This method need be overloaded.")}flow(e){const t=e.clone().applyFacing(this),n=(new i).flowFromOrigin(t);return this.multiply(n),this}fakeDiffExpMap(e){const n=(new s).setFromMatrixPosition(e),r=(new t.Quaternion).setFromRotationMatrix(e);return this.flow(n),this.quaternion.multiply(r),this}equals(e){return this.boost.equals(e.boost)&&this.quaternion.equals(e.quaternion)}copy(e){return this.boost.copy(e.boost),this.quaternion.copy(e.quaternion),this}clone(){const e=new i;return e.copy(this),e}}i.prototype.flowFromOrigin=function(e){const t=new o(e.x,e.y,e.z);return this.boost.multiply((new n).makeTranslation(t)),this.quaternion.identity(),this};var l=r(3219),c=r.n(l),d=r(1999),u=r.n(d);class h{static shader1=void 0;static shader2=void 0;constructor(e,n,r={},a={}){this.camera=e,this.scene=n,this.threeRenderer=a.isWebGLRenderer?a:new t.WebGLRenderer(a),this.globalUniforms=void 0!==r.globalUniforms?r.globalUniforms:{},void 0===this.globalUniforms.maxBounces&&(this.globalUniforms.maxBounces={type:"int",value:0}),this.globalUniforms.windowSize={type:"vec2",value:new t.Vector2(window.innerWidth,window.innerHeight)}}get set(){return this.camera.position.set}setPixelRatio(e){this.threeRenderer.setPixelRatio(e)}setSize(e,t,n=!0){this.threeRenderer.setSize(e,t,n)}setClearColor(e,t){this.threeRenderer.setClearColor(e,t)}setAnimationLoop(e){this.threeRenderer.setAnimationLoop(e)}get domElement(){return this.threeRenderer.domElement}build(){throw new Error("Renderer: this method is not implemented")}render(){throw new Error("Renderer: this method is not implemented")}}class p{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const m=new t.OrthographicCamera(-1,1,1,-1,0,1);class b extends t.BufferGeometry{constructor(){super(),this.setAttribute("position",new t.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new t.Float32BufferAttribute([0,2,0,0,2,0],2))}}const v=new b;class f{constructor(e){this._mesh=new t.Mesh(v,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,m)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class g extends p{constructor(e,n,r=null,a=null,o=null){super(),this.scene=e,this.camera=n,this.overrideMaterial=r,this.clearColor=a,this.clearAlpha=o,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new t.Color}render(e,t,n){const r=e.autoClear;let a,o;e.autoClear=!1,null!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor)),null!==this.clearAlpha&&(a=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(a),null!==this.overrideMaterial&&(this.scene.overrideMaterial=o),e.autoClear=r}}class x extends p{constructor(e,n){super(),this.textureID=void 0!==n?n:"tDiffuse",e instanceof t.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=t.UniformsUtils.clone(e.uniforms),this.material=new t.ShaderMaterial({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new f(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}const y={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class V extends p{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const r=e.getContext(),a=e.state;let o,s;a.buffers.color.setMask(!1),a.buffers.depth.setMask(!1),a.buffers.color.setLocked(!0),a.buffers.depth.setLocked(!0),this.inverse?(o=0,s=1):(o=1,s=0),a.buffers.stencil.setTest(!0),a.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),a.buffers.stencil.setFunc(r.ALWAYS,o,4294967295),a.buffers.stencil.setClear(s),a.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),a.buffers.color.setLocked(!1),a.buffers.depth.setLocked(!1),a.buffers.color.setMask(!0),a.buffers.depth.setMask(!0),a.buffers.stencil.setLocked(!1),a.buffers.stencil.setFunc(r.EQUAL,1,4294967295),a.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),a.buffers.stencil.setLocked(!0)}}class M extends p{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class w{constructor(e,n){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===n){const r=e.getSize(new t.Vector2);this._width=r.width,this._height=r.height,(n=new t.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:t.HalfFloatType})).texture.name="EffectComposer.rt1"}else this._width=n.width,this._height=n.height;this.renderTarget1=n,this.renderTarget2=n.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new x(y),this.copyPass.material.blending=t.NoBlending,this.clock=new t.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,r=this.passes.length;t<r;t++){const r=this.passes[t];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==V&&(r instanceof V?n=!0:r instanceof M&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const n=this.renderer.getSize(new t.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=n.width,this._height=n.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class _{constructor(e=1){this.useCase=e,this.code="",this.includedImports=[],this.includedClasses=[],this.includedConstants=[],this.includedUniforms=[],this.includedInstances=[],this.uniforms={}}get fragmentShader(){return this.code}addChunk(e){return this.code=this.code+"\r\n\r\n"+e,this}addImport(e){return this.includedImports.includes(e)||(this.includedImports.push(e),this.code=this.code+"\r\n\r\n"+e),this}addClass(e,t){return this.includedClasses.includes(e)||(this.includedClasses.push(e),this.code=this.code+"\r\n\r\n"+t),this}addConstant(e,t,n){return this.includedConstants.includes(e)||(this.includedConstants.push(e),this.code=this.code+"\r\n\r\n"+`const ${t} ${e} = ${n};`),this}addUniform(e,t,n){return this.includedUniforms.includes(e)||(this.includedUniforms.push(e),this.code=this.code+"\r\n\r\n"+`uniform ${t} ${e};`,this.uniforms[e]={type:t,value:n}),this}updateUniform(e,t){return this.uniforms[e].value=t,this}addInstance(e,t){return this.includedInstances.includes(e)||(this.includedInstances.push(e),this.code=this.code+"\r\n\r\n"+t),this}}var C=r(1767),T=r.n(C),S=r(190),R=r.n(S),I=r(4168),D=r.n(I),E=r(2977),P=r.n(E),U=r(2044),k=r.n(U),B=r(9461),N=r.n(B),L=r(7781),F=r.n(L),G=r(6159),A=r.n(G),z=r(5315),H=r.n(z);class j extends h{constructor(e,t,n={},r={}){super(e,t,n,r),this._fragmentBuilder=new _,this.postProcess=void 0!==n.postProcess?n.postProcess:[],this.composer=new w(this.threeRenderer)}get isBasicRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.composer.setSize(e,t)}buildFragmentShader(){this._fragmentBuilder.addChunk(T()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)})),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(R()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(D()),this._fragmentBuilder.addChunk(N()),this.set.shader(this._fragmentBuilder),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(k()(this)),this._fragmentBuilder.addChunk(F()(this)),this._fragmentBuilder.addChunk(P()),this._fragmentBuilder.addChunk(A()),this._fragmentBuilder.addChunk(H())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder);const e=new g(this.camera.threeScene,this.camera.threeCamera);e.clear=!1,this.composer.addPass(e);for(let e=0;e<this.postProcess.length;e++){const t=new x(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}render(){this.composer.render()}}class O extends p{constructor(e,n){super();const r=y;this.map=e,this.opacity=void 0!==n?n:1,this.uniforms=t.UniformsUtils.clone(r.uniforms),this.material=new t.ShaderMaterial({uniforms:this.uniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,depthTest:!1,depthWrite:!1,premultipliedAlpha:!0}),this.needsSwap=!1,this.fsQuad=new f(null)}render(e,t,n){const r=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.uniforms.opacity.value=this.opacity,this.uniforms.tDiffuse.value=this.map,this.material.transparent=this.opacity<1,e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(),this.fsQuad.render(e),e.autoClear=r}dispose(){this.material.dispose(),this.fsQuad.dispose()}}var W=r(7962),q=r.n(W);class Q{constructor(){}uniforms(){return{tDiffuse:{value:null}}}vertexShader(){return q()}fragmentShader(){throw new Error("Shape: this method should be implemented")}fullShader(){return{uniforms:this.uniforms(),vertexShader:this.vertexShader(),fragmentShader:this.fragmentShader()}}}var K=r(2690),$=r.n(K);class Y extends Q{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return $()}}var Z=r(6172),X=r.n(Z),J=r(3499),ee=r.n(J),te=r(9638),ne=r.n(te),re=r(7920),ae=r.n(re),oe=r(3888),se=r.n(oe),ie=r(6272),le=r.n(ie),ce=r(8187),de=r.n(ce),ue=r(4122),he=r.n(ue);const pe=new t.ShaderMaterial({uniforms:{accTex:new t.Uniform(null),newTex:new t.Uniform(null),iFrame:new t.Uniform(0)},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D accTex;\n        uniform sampler2D newTex;\n        uniform float iFrame;\n        void main() {\n            float den = 1./ (1. + iFrame);\n            gl_FragColor = den * (iFrame *  texture2D(accTex, vUv) + texture2D(newTex, vUv));\n        }"}),me=new f(pe),be={minFilter:t.NearestFilter,magFilter:t.NearestFilter,format:t.RGBAFormat,type:t.HalfFloatType};class ve extends h{constructor(e,n,r={},a={}){super(e,n,r,a),this.globalUniforms.maxBounces.value=void 0!==r.maxBounces?r.maxBounces:50,this.postProcess=void 0!==r.postProcess?r.postProcess:[],0===this.postProcess.length&&this.postProcess.push(new Y),this._fragmentBuilder=new _(3),this.sceneTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,be),this.accReadTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,be),this.accWriteTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,be),this.iFrame=0,this.composer=new w(this.threeRenderer)}get isPathTracerRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.sceneTarget.setSize(e,t),this.accReadTarget.setSize(e,t),this.accWriteTarget.setSize(e,t),this.composer.setSize(e,t)}updateFrameSeed(){const e=Math.floor(1e4*Math.random());this._fragmentBuilder.updateUniform("frameSeed",e)}buildFragmentShader(){this._fragmentBuilder.addChunk(T()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)}));const e=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.addUniform("resolution","vec2",e),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(R()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(D()),this._fragmentBuilder.addUniform("frameSeed","uint",Math.floor(1e4*Math.random())),this._fragmentBuilder.addChunk(ne()),this._fragmentBuilder.addChunk(se()),this.set.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(ae()),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(X()(this)),this._fragmentBuilder.addChunk(he()(this)),this._fragmentBuilder.addChunk(le()(this)),this._fragmentBuilder.addChunk(ee()),this._fragmentBuilder.addChunk(de())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder),this.composer.addPass(new O(this.accReadTarget.texture));for(let e=0;e<this.postProcess.length;e++){const t=new x(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}renderAccTarget(){this.threeRenderer.setRenderTarget(null),this.composer.render()}render(){let e;this.updateFrameSeed();const n=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.updateUniform("resolution",n),this.threeRenderer.setRenderTarget(this.sceneTarget),this.threeRenderer.render(this.threeScene,this.camera.threeCamera),this.threeRenderer.setRenderTarget(this.accWriteTarget),pe.uniforms.accTex.value=this.accReadTarget.texture,pe.uniforms.newTex.value=this.sceneTarget.texture,pe.uniforms.iFrame.value=this.iFrame,me.render(this.threeRenderer),e=this.accReadTarget,this.accReadTarget=this.accWriteTarget,this.accWriteTarget=e,this.renderAccTarget(),this.iFrame=this.iFrame+1}}class fe{static createButton(e){const t=document.createElement("button");function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",r(t),navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){let n=null;async function r(r){r.addEventListener("end",a),await e.xr.setSession(r),t.textContent="EXIT VR",n=r}function a(){n.removeEventListener("end",a),t.textContent="ENTER VR",n=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){if(null===n){const e={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};navigator.xr.requestSession("immersive-vr",e).then(r)}else n.end()}}():(n(),t.textContent="VR NOT SUPPORTED"),r&&fe.xrSessionIsGranted&&t.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{fe.xrSessionIsGranted=!0}))}}}function ge(e,t){return function(){return t.apply(e,arguments)}}function xe(e){return e.replace(/\W/g,"_")}function ye(e,t,n){return Math.max(t,Math.min(n,e))}fe.xrSessionIsGranted=!1,fe.registerSessionGrantedListener(),t.Vector3.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}]`},t.Vector4.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Matrix3.prototype.toLog=function(){let e="\r\n";for(let t=0;t<3;t++){for(let n=0;n<3;n++)0!==n&&(e+=",\t"),e+=this.elements[t+3*n];e+="\r\n"}return e},t.Matrix3.prototype.power=function(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}},t.Matrix3.prototype.makeRotation=function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this},t.Matrix4.prototype.toLog=function(){let e="\r\n";for(let t=0;t<4;t++){for(let n=0;n<4;n++)0!==n&&(e+=",\t"),e+=this.elements[t+4*n];e+="\r\n"}return e},t.Matrix4.prototype.add=function(e){return this.set.apply(this,[].map.call(this.elements,(function(t,n){return t+e.elements[n]}))),this},t.Quaternion.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Quaternion.prototype.multiplyScalar=function(e){return this.set(e*this.x,e*this.y,e*this.z,e*this.w),this},t.Quaternion.prototype.add=function(e){return this.set(this.x+e.x,this.y+e.y,this.z+e.z,this.w+e.w),this};const Ve=0,Me=1,we=2;class _e{constructor(e){this.group=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.name=`groupElement_${this.uuid}`}identity(){throw new Error("GroupElement: This method need be overloaded.")}multiply(e){throw new Error("GroupElement: This method need be overloaded.")}premultiply(e){throw new Error("GroupElement: This method need be overloaded.")}invert(){throw new Error("GroupElement: This method need be overloaded.")}toIsometry(){throw new Error("GroupElement: This method need be overloaded.")}equals(e){throw new Error("GroupElement: This method need be overloaded.")}clone(){throw new Error("GroupElement: This method need be overloaded.")}copy(e){throw new Error("GroupElement: This method need be overloaded.")}}class Ce{constructor(e){this.local=new i,this.set=e,this.cellBoost=this.set.group.element(),this.invCellBoost=this.set.group.element()}reduceErrorBoost(){return this.local.reduceErrorBoost(),this}reduceErrorFacing(){return this.local.reduceErrorFacing(),this}reduceErrorLocal(){return this.local.reduceError(),this}reduceError(){return this.reduceErrorLocal(),this}get facing(){return this.local.facing}get localPoint(){return this.local.point}get point(){return this.local.point.applyIsometry(this.cellBoost.toIsometry())}get globalBoost(){return this.cellBoost.toIsometry().multiply(this.local.boost)}get globalPosition(){const e=new i;return e.boost.copy(this.globalBoost),e.quaternion.copy(this.local.quaternion),e}reset(){this.local.reset(),this.cellBoost.identity(),this.invCellBoost.identity()}applyQuaternion(e){return this.local.applyQuaternion(e),this}teleport(){let e,t;for(;;){t=this.localPoint,e=!0;for(const n of this.set.teleportations)if(e=e&&!n.jsTest(t),!e){this.local.applyIsometry(n.elt.toIsometry()),this.cellBoost.multiply(n.inv),this.invCellBoost.premultiply(n.elt);break}if(e)break}return this}flow(e){return this.local.flow(e),this.teleport(),this}fakeDiffExpMap(e){return this.local.fakeDiffExpMap(e),this}equals(e){let t=!0;return t=t&&this.local.equals(e.local),t=t&&this.cellBoost.equals(e.cellBoost),t}copy(e){return this.cellBoost.copy(e.cellBoost),this.invCellBoost.copy(e.invCellBoost),this.local.copy(e.local),this}clone(){const e=new Ce(this.set);return e.copy(this),e}}r(8415),r(4770);class Te{constructor(e){this.threeCamera=void 0,this.threeScene=new t.Scene,this.minDist=void 0!==e.minDist?e.minDist:0,this.maxDist=void 0!==e.maxDist?e.maxDist:50,this.safetyDist=void 0!==e.safetyDist?e.safetyDist:0,this.maxSteps=void 0!==e.maxSteps?e.maxSteps:100,this.threshold=void 0!==e.threshold?e.threshold:1e-4,this.position=new Ce(e.set),this.fakeCameras=[],this.setThreeCamera(e)}setThreeCamera(e){throw new Error("This method need be implemented.")}setThreeScene(){throw new Error("This method need be implemented.")}get matrix(){return this.threeCamera.matrixWorld}updateProjectionMatrix(){this.threeCamera.updateProjectionMatrix()}static glslClass(){throw new Error("Generic: this function should be implemented")}static glslMapping(){throw new Error("Generic: this function should be implemented")}shader(e,t=void 0){e.addClass("Camera",this.constructor.glslClass()),void 0===t?e.addUniform("camera","Camera",this):e.addUniform("camera","Camera",this.fakeCameras[t]),e.addChunk(this.constructor.glslMapping())}}var Se=r(5682),Re=r.n(Se),Ie=r(5970),De=r.n(Ie),Ee=r(9222),Pe=r.n(Ee);class Ue extends Te{constructor(e){super(e)}setThreeCamera(e){this.threeCamera=new t.PerspectiveCamera(void 0!==e.fov?e.fov:70,window.innerWidth/window.innerHeight,.01,2e3),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}set aspect(e){this.threeCamera.aspect=e}get fov(){return this.threeCamera.fov}set fov(e){this.threeCamera.fov=e}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.SphereGeometry(1e3,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:Re(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return De()}static glslMapping(){return Pe()}}class ke extends Ue{constructor(e){super(e),this.isStereoOn=!1,this.ipDist=void 0!==e.ipDist?e.ipDist:.03200000151991844;for(const e in[Ve,Me])this.fakeCameras[e]={fov:this.fov,minDist:this.minDist,maxDist:this.maxDist,maxSteps:this.maxSteps,safetyDist:this.safetyDist,threshold:this.threshold,position:this.position.clone(),matrix:this.matrix}}get isStereoOff(){return!this.isStereoOn}switchStereo(){this.isStereoOn=!this.isStereoOn}setThreeScene(e){const n=new t.SphereGeometry(50,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e[Ve].uniforms,vertexShader:Re(),fragmentShader:e[Ve].fragmentShader}),a=new t.ShaderMaterial({uniforms:e[Me].uniforms,vertexShader:Re(),fragmentShader:e[Ve].fragmentShader}),o=new t.Mesh(n,r),s=new t.Mesh(n,a);o.layers.set(1),s.layers.set(2),this.threeScene.add(o,s)}updateFakeCamerasPosition(){if(this.fakeCameras[Ve].position.copy(this.position),this.fakeCameras[Me].position.copy(this.position),this.isStereoOn){const e=new s(1,0,0).multiplyScalar(2*this.ipDist).applyMatrix4(this.matrix).negate();this.fakeCameras[Ve].position.flow(e)}}get chaseThreeCamera(){if(void 0===this._chaseThreeCamera){const e=new s;this._chaseThreeCamera=function(){const t=(new s).setFromMatrixPosition(this.matrix),n=(new s).subVectors(t,e);this.position.flow(n),this.updateFakeCamerasPosition(),e.copy(t)}}return this._chaseThreeCamera}}var Be=r(8351),Ne=r.n(Be);class Le extends h{constructor(e,t,n={},r={}){super(e,t,n,r),this.threeRenderer.xr.enabled=!0,this.threeRenderer.xr.setReferenceSpaceType("local"),this.camera.threeCamera.layers.enable(1);const a=fe.createButton(this.threeRenderer),o=ge(this.camera,this.camera.switchStereo);a.addEventListener("click",o,!1),document.body.appendChild(a),this._fragmentBuilders=[new _,new _],this.postProcess=void 0!==n.postProcess&&n.postProcess,this.exposure=void 0!==n.exposure?n.exposure:1}get isVRRenderer(){return!0}get xr(){return this.threeRenderer.xr}buildFragmentShader(){for(const e of[Ve,Me])this._fragmentBuilders[e].addChunk(T()),Object.keys(this.globalUniforms).forEach((t=>{const n=this.globalUniforms[t].type,r=this.globalUniforms[t].value;this._fragmentBuilders[e].addUniform(t,n,r)})),this._fragmentBuilders[e].addChunk(this.constructor.shader1),this._fragmentBuilders[e].addChunk(R()),this._fragmentBuilders[e].addChunk(this.constructor.shader2),this._fragmentBuilders[e].addChunk(D()),this._fragmentBuilders[e].addChunk(N()),this.set.shader(this._fragmentBuilders[e]),this.camera.shader(this._fragmentBuilders[e],e),this.scene.shader(this._fragmentBuilders[e]),this._fragmentBuilders[e].addChunk(k()(this)),this._fragmentBuilders[e].addChunk(F()(this)),this._fragmentBuilders[e].addChunk(P()),this.postProcess?(this._fragmentBuilders[e].addUniform("exposure","float",this.exposure),this._fragmentBuilders[e].addChunk(Ne())):this._fragmentBuilders[e].addChunk(A()),this._fragmentBuilders[e].addChunk(H())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilders)}checkShader(e=Ve){console.log(this._fragmentBuilders[e].code)}render(){this.camera.chaseThreeCamera(),this.threeRenderer.render(this.camera.threeScene,this.camera.threeCamera)}}var Fe=r(6224),Ge=r.n(Fe),Ae=r(8710),ze=r.n(Ae),He=r(4750),je=r.n(He);class Oe extends Te{constructor(e){super(e),this.fov=void 0!==e.fov?e.fov:50}setThreeCamera(){this.threeCamera=new t.OrthographicCamera(-1,1,1,-1,0,1),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.PlaneGeometry(2,2),r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:Ge(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return ze()}static glslMapping(){return je()}}var We=r(6354),qe=r.n(We),Qe=r(6684),Ke=r.n(Qe);class $e extends Ue{constructor(e){super(e),this.focalLength=void 0!==e.focalLength?e.focalLength:1,this.aperture=void 0!==e.aperture?e.aperture:0}static glslClass(){return qe()}static glslMapping(){return Ke()}}class Ye{constructor(){}element(){throw new Error("Group: this method should be implemented")}shader(e){throw new Error("Group: this method should be implemented")}}class Ze extends _e{constructor(e){super(e),this.fake=!0}identity(){return this}multiply(e){return this}premultiply(e){return this}invert(){return this}toIsometry(){return new n}equals(e){return!0}clone(){return new Ze}copy(e){return this}}var Xe=r(9188),Je=r.n(Xe);class et extends Ye{constructor(){super()}element(){return new Ze(this)}shader(e){e.addChunk(Je())}}var tt=r(3148),nt=r.n(tt);const rt=/bool\s*(\w+)\(Point.*\)/m,at=/float\s*(\w+)\(ExtVector.*\)/m;class ot{constructor(e,n,r,a,o=void 0,s=void 0){let i;if(this.set=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.jsTest=n,this.glslTest=r,this.glslTestName=void 0,i=r.match(rt),!i)throw new Error("Teleportation: unable to find the name of the GLSL test");if(this.glslTestName=i[1],this.elt=a,this.inv=void 0!==o?o:a.clone().invert(),this.glslCreepCustom=void 0,this.glslCreep=void 0,this.glslCreepName=void 0,void 0!==s){if(this.glslCreepCustom=!0,this.glslCreep=s,i=s.match(at),!i)throw new Error("Teleportation: unable to find the name of the GLSL creep");this.glslCreepName=i[1]}else this.glslCreepCustom=!1,this.glslCreepName=`creep${this.uuid}`,this.glslCreep=nt()(this)}get name(){return void 0===this._name&&(this._name=`teleportation_${this.uuid}`),this._name}get usesCreepingCustom(){return this.set.usesCreeping&&this.glslCreepCustom}get usesCreepingBinary(){return this.set.creepingType===mt&&!this.glslCreepCustom}shader(e){e.addChunk(this.glslTest),this.set.usesCreeping&&e.addChunk(this.glslCreep),e.addUniform(this.elt.name,"GroupElement",this.elt),e.addUniform(this.elt.name,"GroupElement",this.inv)}}var st=r(2311),it=r.n(st),lt=r(7970),ct=r.n(lt),dt=r(5103),ut=r.n(dt);const ht=0,pt=1,mt=2;class bt{constructor(e=[],t=!1,n=ht){this.teleportations=[],this.neighbors=e,this.usesNearestNeighbors=t,this.creepingType=n}get usesCreeping(){return this.creepingType===pt||this.creepingType===mt}add(e,t,n,r=void 0,a=void 0){return this.teleportations.push(new ot(this,e,t,n,r,a)),this}get group(){return 0!==this.teleportations.length?this.teleportations[0].elt.group:new et}shader(e){this.group.shader(e),e.addChunk(it()),e.addChunk(ct());for(const t of this.teleportations)t.shader(e);for(const t of this.neighbors)e.addUniform(t.elt.name,"GroupElement",t.elt),e.addUniform(t.inv.name,"GroupElement",t.inv);e.addChunk(ut()(this))}}class vt{constructor(){this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.id=void 0,this.imports=[]}get className(){return this.constructor.name}get name(){return void 0===this._name&&(this._name=`${xe(this.className)}_${this.uuid}`),this._name}get uniformType(){return""}setId(e){this.id=e.nextId,e.nextId=e.nextId+1}onAdd(e){}addImport(e){for(const e of arguments)this.imports.push(e)}static glslClass(){throw new Error("Generic: this function should be implemented")}glslInstance(){throw new Error("Generic: this function should be implemented")}shader(e){for(const t of this.imports)e.addImport(t);e.addClass(this.constructor.name,this.constructor.glslClass()),""!==this.uniformType&&e.addUniform(this.name,this.uniformType,this),e.addInstance(this.name,this.glslInstance())}}var ft=r(8266),gt=r.n(ft);class xt extends vt{constructor(e=void 0){super(),this.isom=void 0!==e?e:new n,this.isomInv=this.isom.clone().invert(),this.parent=void 0,this._absoluteIsom=void 0,this._absoluteIsomInv=void 0}updateAbsoluteIsom(){void 0===this._absoluteIsom&&(this._absoluteIsom=new n,this._absoluteIsomInv=new n),this.isomInv=this.isom.clone().invert(),this._absoluteIsom.copy(this.isom),this._absoluteIsomInv.copy(this.isomInv),void 0!==this.parent&&(this._absoluteIsom.premultiply(this.parent.absoluteIsom),this._absoluteIsomInv.multiply(this.parent.absoluteIsomInv))}updateData(){this.updateAbsoluteIsom()}get absoluteIsom(){return void 0===this._absoluteIsom&&this.updateAbsoluteIsom(),this._absoluteIsom}get absoluteIsomInv(){return void 0===this._absoluteIsomInv&&this.updateAbsoluteIsom(),this._absoluteIsomInv}get isShape(){return!0}get isBasicShape(){throw new Error("Shape: this method should be implemented")}get isAdvancedShape(){return!this.isBasicShape}get isGlobal(){throw new Error("Shape: this method should be implemented")}get isLocal(){return!this.isGlobal}get hasUVMap(){return!1}glslSDF(){throw new Error("Shape: this method should be implemented")}glslGradient(){return gt()(this)}glslUVMap(){throw new Error("Shape: this method should be implemented")}glslInstance(){let e=this.glslSDF()+"\r\n"+this.glslGradient();return this.hasUVMap&&(e=e+"\r\n"+this.glslUVMap()),e}}class yt extends xt{constructor(e=void 0){super(e)}get isBasicShape(){return!0}}class Vt extends xt{constructor(e=void 0){super(e)}get isBasicShape(){return!1}}class Mt extends vt{constructor(e){super(),this.maxDirs=e}get isLight(){return!0}get isGlobal(){throw new Error("Generic: this method should be implemented")}get isLocal(){return!this.isGlobal}glslDirections(){throw new Error("Light: this method should be implemented")}glslInstance(){return this.glslDirections()}}class wt extends vt{constructor(){super(),this.lights=void 0,this.reflectivity=void 0}get isMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}get isTransparent(){return!1}onAdd(e){this.usesLight&&(this.hasOwnProperty("lights")&&void 0!==this.lights||(this.lights=e.lights))}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class _t extends vt{constructor(){super()}get isPTMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}onAdd(e){}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class Ct{constructor(){}shader(e){throw new Error("Fog: this method need be implemented")}}var Tt=r(2664),St=r.n(Tt),Rt=r(8778),It=r.n(Rt);class Dt extends wt{constructor(e){super(),this.color=e}get uniformType(){return"SingleColorMaterial"}get usesNormal(){return!1}static glslClass(){return St()}glslRender(){return It()(this)}}var Et=r(2143),Pt=r.n(Et),Ut=r(9606),kt=r.n(Ut),Bt=r(5363),Nt=r.n(Bt);class Lt extends _t{constructor(e){super(),this.emission=void 0!==e.emission?e.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==e.volumeEmission?e.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==e.opticalDepth?e.opticalDepth:1e3,this.diffuse=void 0!==e.diffuse?e.diffuse:new t.Color(1,1,1),this.specular=void 0!==e.specular?e.specular:new t.Color(1,1,1),this.absorb=void 0!==e.absorb?e.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==e.ior?e.ior:1,this.roughness=void 0!==e.roughness?e.roughness:.2,this.reflectionChance=void 0!==e.reflectionChance?e.reflectionChance:.1,this.refractionChance=void 0!==e.refractionChance?e.refractionChance:0,this.diffuseChance=void 0!==e.diffuseChance?e.diffuseChance:.9;const n=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/n,this.refractionChance=this.refractionChance/n,this.diffuseChance=this.diffuseChance/n,this.addImport(Nt())}get uniformType(){return"BasicPTMaterial"}static glslClass(){return Pt()}glslRender(){return kt()(this)}}class Ft{constructor(e={}){this.lights=[],this.solids=[],this.nextId=0,this.fog=e.fog,this.background=void 0!==e.background?e.background:new Dt(new t.Color(0,0,0)),this.ptBackground=void 0!==e.ptBackground?e.ptBackground:new Lt({diffuse:new t.Color(0,0,0),specular:new t.Color(0,0,0),absorb:new t.Color(.25,.25,.25)})}_add(e){return e.setId(this),e.onAdd(this),e.isLight&&this.lights.push(e),e.isSolid&&this.solids.push(e),this}add(e){for(const e of arguments)this._add(e);return this}shader(e){3===e.useCase?this.ptBackground.shader(e):this.background.shader(e);for(const t of this.lights)3!==e.useCase&&t.shader(e);for(const t of this.solids)t.shader(e);void 0!==this.fog&&this.fog.shader(e)}}var Gt=r(7885),At=r.n(Gt),zt=r(5348),Ht=r.n(zt);class jt extends Ct{constructor(e,t){super(),this.color=e,this.scattering=t}shader(e){e.addClass("ExpFog",At()),e.addUniform("fog","ExpFog",this),e.addChunk(Ht())}}const Ot=new bt;var Wt=r(3496),qt=r.n(Wt),Qt=r(6077),Kt=r.n(Qt);class $t extends wt{constructor(){super()}get uniformType(){return""}static glslClass(){return qt()}glslRender(){return Kt()(this)}}var Yt=r(6045),Zt=r.n(Yt),Xt=r(8149),Jt=r.n(Xt);class en extends wt{constructor(e={}){super(),this.color=void 0!==e.color?e.color:new t.Color(1,1,1),this.ambient=void 0!==e.ambient?e.ambient:.5,this.diffuse=void 0!==e.diffuse?e.diffuse:.4,this.specular=void 0!==e.specular?e.specular:.1;const n=this.ambient+this.diffuse+this.specular;this.ambient=this.ambient/n,this.diffuse=this.diffuse/n,this.specular=this.specular/n,this.shininess=void 0!==e.shininess?e.shininess:10,this._isReflecting=void 0!==e.isReflecting&&e.isReflecting,this.reflectivity=void 0!==e.reflectivity?e.reflectivity:new t.Color(0,0,0),this.lights=e.lights}get uniformType(){return"PhongMaterial"}get usesLight(){return!0}get isReflecting(){return this._isReflecting}static glslClass(){return Zt()}glslRender(){return Jt()(this)}shader(e){for(const t of this.lights)t.shader(e);super.shader(e)}}var tn=r(2197),nn=r.n(tn),rn=r(1215),an=r.n(rn);class on extends wt{constructor(e,t,n,r){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"CheckerboardMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return nn()}glslRender(){return an()(this)}}var sn=r(3801),ln=r.n(sn);class cn extends wt{constructor(e,t,n,r,a){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"GraphPaperMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return ln()}glslRender(){return an()(this)}}var dn=r(7793),un=r.n(dn),hn=r(9909),pn=r.n(hn);class mn extends wt{constructor(){super()}get uniformType(){return""}get usesNormal(){return!1}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}static glslClass(){return un()}glslRender(){return pn()(this)}shader(e){super.shader(e)}}var bn=r(9095),vn=r.n(bn);class fn extends wt{constructor(e,n={}){super(),this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==n.isTransparent&&n.isTransparent}get uniformType(){return"SimpleTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return vn()}glslRender(){return an()(this)}}var gn=r(1220),xn=r.n(gn);class yn extends wt{constructor(e,n=void 0,r={}){super(),this.quaternion=void 0!==n?n:new t.Quaternion,this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get uniformType(){return"RotatedSphericalTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return xn()}glslRender(){return an()(this)}}const Vn=r.p+"img/426f7657671a2811d4aa.png",Mn=r.p+"img/953837709706027f7dc2.jpg",wn=r.p+"img/eba62d0cff4836a949b8.png",_n=r.p+"img/26419cb1ce4138a11aa9.jpg",Cn=r.p+"img/33960f5af615e67309e5.jpg",Tn=r.p+"img/4b569137334e61081651.jpg";function Sn(e){let n;switch(e){case 0:default:n=Vn;break;case 1:n=Mn}return new fn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function Rn(e){let n;switch(e){case 0:default:n=wn;break;case 1:n=_n}return new fn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function In(){return new fn(Cn,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function Dn(e){return new fn(Tn,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}const En=r.p+"img/eb3dc827520201070f7e.jpg",Pn=r.p+"img/ce3e4a6e1affece0e902.jpg",Un=r.p+"img/370531b8ba6e5bd6a61e.jpg",kn=r.p+"img/29989970ee70af555fd4.jpg",Bn=r.p+"img/1a661a5afc65c969818f.jpg",Nn=r.p+"img/bb733e02d9f86b8b7433.jpg",Ln=r.p+"img/f5196bbc22091948755e.jpg",Fn=r.p+"img/9e3233c13cddac942dc4.jpg",Gn=r.p+"img/2528cfc76a03ca71fb7f.jpg";function An(e,n,r=void 0){let a;switch(e){case"eye":switch(n){case 0:a=En;break;case 1:a=Pn;break;case 2:a=Un;break;case 3:a=kn;break;case 4:a=Bn;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;case"hand":switch(n){case 0:a=Nn;break;case 1:a=Ln;break;case 2:a=Fn;break;case 3:a=Gn;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;default:throw new Error("WoodBallMaterial: this type of texture is not implemented.")}return new yn(a,r,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}var zn=r(533),Hn=r.n(zn);class jn extends wt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0!==n.transparent&&n.transparent}get uniformType(){return"VideoTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return Hn()}glslRender(){return an()(this)}}var On=r(2229),Wn=r.n(On);class qn extends wt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0===n.transparent||n.transparent}get uniformType(){return"VideoAlphaTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return Wn()}glslRender(){return an()(this)}}var Qn=r(4680),Kn=r.n(Qn);class $n extends wt{static REFRESH_READY=0;static REFRESH_IN_PROGRESS=1;static REFRESH_COMPLETE=2;constructor(e,n,r={}){super(),this.files=e,this.frameNumber=e.length,this.sampler=new t.Texture,this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent,this.loop=void 0!==r.loop&&r.loop,this.callback=void 0!==r.callback?r.callback:function(){},this.fps=void 0!==r.fps&&r.fps,this.imageStatus=$n.REFRESH_READY,this.imageLoader=new t.ImageLoader,this.imageLoader.setPath(n),this.currentFrame=0}nextFrameIndex(e){return this.loop?(e+1)%this.frameNumber:Math.min(e+1,this.frameNumber-1)}nextFrame(){if(this.imageStatus===$n.REFRESH_READY){this.imageStatus=$n.REFRESH_IN_PROGRESS;const e=this.files[this.currentFrame];this.currentFrame=this.nextFrameIndex(this.currentFrame);const t=this;this.imageLoader.load(e,(function(e){t.sampler.image=e,t.sampler.needsUpdate=!0,t.imageStatus=$n.REFRESH_COMPLETE}),void 0,(function(){console.log(`Cannot load the file ${e}`)}))}}get uniformType(){return"VideoFrameTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return Kn()}glslRender(){return an()(this)}}var Yn=r(3081),Zn=r.n(Yn);class Xn extends wt{constructor(e,n,r,a=void 0){super(),this.dir1=e,this.dir2=n;const o=void 0!==a?a:[.5,1,1,.5];let s=0;const i=[];for(let e=0;e<4;e++)void 0!==o[e]&&(s+=o[e]),i[e]=s;for(let e=0;e<4;e++)i[e]=i[e]/s;this.lengths=new t.Vector4(...i);let l=new t.Color(1,1,1);this.color0=void 0!==r[0]?r[0]:l.clone(),l=this.color0,this.color1=void 0!==r[1]?r[1]:l.clone(),l=this.color1,this.color2=void 0!==r[2]?r[2]:l.clone(),l=this.color2,this.color3=void 0!==r[3]?r[3]:l.clone()}get uniformType(){return"SquaresMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return Zn()}glslRender(){return an()(this)}}var Jn=r(9835),er=r.n(Jn);class tr extends wt{constructor(e,n,r=void 0){super(),this.dir=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"StripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return er()}glslRender(){return an()(this)}}var nr=r(7685),rr=r.n(nr);class ar extends wt{constructor(e,n,r=void 0){super(),this.totalWidth=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"HypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return rr()}glslRender(){return an()(this)}}var or=r(1917),sr=r.n(or);class ir extends wt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"EquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return sr()}glslRender(){return an()(this)}}var lr=r(4743),cr=r.n(lr);class dr extends wt{constructor(e,t,n,r){super(),this.distance=e,this.width=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"EquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return cr()}glslRender(){return an()(this)}}var ur=r(4566),hr=r.n(ur);class pr extends wt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"ImprovedEquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return hr()}glslRender(){return an()(this)}}var mr=r(1650),br=r.n(mr);class vr extends wt{constructor(e,n,r,a,o,s=void 0){super(),this.distance=e,this.halfWidth=n,this.fadingAmplitude=r,this.stripColor=a,this.bgColor=o,this.quaternion=void 0!==s?s:new t.Quaternion}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"ImprovedEquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return br()}glslRender(){return an()(this)}}var fr=r(5836),gr=r.n(fr),xr=r(3838),yr=r.n(xr),Vr=r(472),Mr=r.n(Vr),wr=r(8204),_r=r.n(wr),Cr=r(7660),Tr=r.n(Cr);class Sr extends wt{constructor(e,n={}){super(),this.material=e,this.ambient=void 0!==n.ambient?n.ambient:.5,this.diffuse=void 0!==n.diffuse?n.diffuse:.5,this.specular=void 0!==n.specular?n.specular:.5,this.shininess=void 0!==n.shininess?n.shininess:10,this._isReflecting=void 0!==n.isReflecting&&n.isReflecting,this.reflectivity=void 0!==n.reflectivity?n.reflectivity:new t.Vector3(0,0,0),this.lights=n.lights}get uniformType(){return"PhongWrapMaterial"}static glslClass(){return gr()}get usesNormal(){return!0}get usesUVMap(){return this.material.usesUVMap}get usesLight(){return!0}get isReflecting(){return this._isReflecting}glslRender(){return this.material.usesNormal?this.material.usesUVMap?Tr()(this):Mr()(this):this.material.usesUVMap?_r()(this):yr()(this)}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e);for(const t of this.lights)t.shader(e);super.shader(e)}}function Rr(e,t={}){return new Sr(e,t)}var Ir=r(3048),Dr=r.n(Ir),Er=r(8474),Pr=r.n(Er),Ur=r(5506),kr=r.n(Ur),Br=r(3045),Nr=r.n(Br),Lr=r(7397),Fr=r.n(Lr);class Gr extends wt{constructor(e,t){super(),this.defaultMat=e,this.highlightMat=t,this.isHighlightOn=!1}get uniformType(){return"HighlightWrapMaterial"}static glslClass(){return Dr()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Fr()(this):kr()(this):this.usesUVMap?Nr()(this):Pr()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function Ar(e,t){return new Gr(e,t)}var zr=r(2278),Hr=r.n(zr),jr=r(8906),Or=r.n(jr),Wr=r(1998),qr=r.n(Wr),Qr=r(4261),Kr=r.n(Qr),$r=r(699),Yr=r.n($r);class Zr extends wt{constructor(e,t,n){super(),this.defaultMat=e,this.highlightMat=t,this.cellBoost=n}get uniformType(){return"HighlightLocalWrapMaterial"}static glslClass(){return Hr()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Yr()(this):qr()(this):this.usesUVMap?Kr()(this):Or()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function Xr(e,t,n){return new Zr(e,t,n)}var Jr=r(5698),ea=r.n(Jr),ta=r(8402),na=r.n(ta),ra=r(6158),aa=r.n(ra),oa=r(2332),sa=r.n(oa),ia=r(4146),la=r.n(ia);class ca extends wt{constructor(e,n,r=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==r?r:5,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=ye(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionWrapMaterial"}static glslClass(){return ea()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?la()(this):aa()(this):this.usesUVMap?sa()(this):na()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function da(e,t,n){return new ca(e,t,n)}var ua=r(1888),ha=r.n(ua),pa=r(5377),ma=r.n(pa),ba=r(9441),va=r.n(ba),fa=r(6766),ga=r.n(fa),xa=r(9245),ya=r.n(xa);class Va extends wt{constructor(e,n,r,a=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==a?a:5,this.cellBoost=r,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=ye(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionLocalWrapMaterial"}static glslClass(){return ha()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?ya()(this):va()(this):this.usesUVMap?ga()(this):ma()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function Ma(e,t,n,r){return new Va(e,t,n,r)}var wa=r(7198),_a=r.n(wa),Ca=r(1202),Ta=r.n(Ca),Sa=r(2330),Ra=r.n(Sa),Ia=r(588),Da=r.n(Ia),Ea=r(9040),Pa=r.n(Ea),Ua=r(1365),ka=r.n(Ua);class Ba extends _t{constructor(e,n){super(),this.material=e,this.emission=void 0!==n.emission?n.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==n.volumeEmission?n.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==n.opticalDepth?n.opticalDepth:0,this.specular=void 0!==n.specular?n.specular:new t.Color(1,1,1),this.absorb=void 0!==n.absorb?n.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==n.ior?n.ior:1,this.roughness=void 0!==n.roughness?n.roughness:.2,this.reflectionChance=void 0!==n.reflectionChance?n.reflectionChance:.1,this.refractionChance=void 0!==n.refractionChance?n.refractionChance:0,this.diffuseChance=void 0!==n.diffuseChance?n.diffuseChance:.9;const r=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/r,this.refractionChance=this.refractionChance/r,this.diffuseChance=this.diffuseChance/r,this.addImport(Nt())}get uniformType(){return"PathTracerWrapMaterial"}static glslClass(){return _a()}get usesUVMap(){return this.material.usesUVMap}glslRender(){let e="";return e+=Ta()(this),this.material.usesNormal?this.material.usesUVMap?e+=Da()(this):e+=Pa()(this):this.material.usesUVMap?e+=ka()(this):e+=Ra()(this),e}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e),super.shader(e)}}function Na(e,t={}){return new Ba(e,t)}var La=r(7939),Fa=r.n(La),Ga=r(6142),Aa=r.n(Ga),za=r(7260),Ha=r.n(za);class ja extends Vt{constructor(e){super(),this.shape=e,this.shape.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData()}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Fa()(this)}glslGradient(){return Aa()(this)}glslUVMap(){return Ha()(this)}setId(e){this.shape.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),super.onAdd(e)}shader(e){this.shape.shader(e),super.shader(e)}}function Oa(e){return new ja(e)}var Wa=r(2093),qa=r.n(Wa),Qa=r(2076),Ka=r.n(Qa),$a=r(3335),Ya=r.n($a),Za=r(6428),Xa=r.n(Za),Ja=r(6861),eo=r.n(Ja),to=r(2905),no=r.n(to),ro=r(7333),ao=r.n(ro);const oo=1;class so extends Vt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("IntersectionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.maxType=void 0!==n.maxType?n.maxType:0,this.maxCoeff=0,this.maxType===oo)this.addImport(qa()),this.maxCoeff=void 0!==n.maxCoeff?n.maxCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"IntersectionShape"}static glslClass(){return ao()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.maxType===oo?Xa()(this):Ka()(this)}glslGradient(){return this.maxType===oo?eo()(this):Ya()(this)}glslUVMap(){return no()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function io(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new so(e,arguments[r],t));return e}var lo=r(5442),co=r.n(lo),uo=r(3908),ho=r.n(uo),po=r(7762),mo=r.n(po),bo=r(7500),vo=r.n(bo),fo=r(3238),go=r.n(fo),xo=r(519),yo=r.n(xo),Vo=r(8655),Mo=r.n(Vo);const wo=1;class _o extends Vt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("UnionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.minType=void 0!==n.minType?n.minType:0,this.minCoeff=0,this.minType===wo)this.addImport(co()),this.minCoeff=void 0!==n.minCoeff?n.minCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"UnionShape"}static glslClass(){return yo()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.minType===wo?go()(this):ho()(this)}glslGradient(){return this.minType===wo?Mo()(this):mo()(this)}glslUVMap(){return vo()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function Co(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new _o(e,arguments[r],t));return e}var To=r(3105),So=r.n(To),Ro=r(6242),Io=r.n(Ro),Do=r(9338),Eo=r.n(Do);class Po extends Vt{constructor(e,t){if(e.isGlobal!==t.isGlobal)throw new Error("WrapShape: the two shapes should be both local or both global");super(),this.wrap=e,this.shape=t,this.shape.parent=this,this.wrap.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom(),this.wrap.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData(),this.wrap.updateData()}get isWrapShape(){return!0}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return So()(this)}glslGradient(){return Io()(this)}glslUVMap(){return Eo()(this)}setId(e){this.wrap.setId(e),this.shape.setId(e),super.setId(e)}onAdd(e){this.wrap.onAdd(e),this.shape.onAdd(e),super.onAdd(e)}shader(e){this.wrap.shader(e),this.shape.shader(e),super.shader(e)}}function Uo(e,t){return new Po(e,t)}const ko={KeyA:"yawLeft",KeyD:"yawRight",KeyW:"pitchUp",KeyS:"pitchDown",KeyQ:"rollLeft",KeyE:"rollRight",ArrowUp:"forward",ArrowDown:"back",ArrowLeft:"left",ArrowRight:"right",Quote:"up",Slash:"down"};class Bo extends t.EventDispatcher{constructor(e){super(),this.camera=e,this.movementSpeed=.5,this.rollSpeed=.8,this._moveState={up:0,down:0,left:0,right:0,forward:0,back:0,pitchUp:0,pitchDown:0,yawLeft:0,yawRight:0,rollLeft:0,rollRight:0},this._moveVector=new s(0,0,0),this._rotationVector=new s(0,0,0),this._onKeyDown=ge(this,this.onKeyDown),this._onKeyUp=ge(this,this.onKeyUp),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}pause(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)}restore(){window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}onKeyDown(e){if(e.code in ko){const t=ko[e.code];this._moveState[t]=1,this.updateMovementVector(),this.updateRotationVector()}}onKeyUp(e){if(e.code in ko){const t=ko[e.code];this._moveState[t]=0,this.updateMovementVector(),this.updateRotationVector()}}updateMovementVector(){this._moveVector.x=-this._moveState.left+this._moveState.right,this._moveVector.y=-this._moveState.down+this._moveState.up,this._moveVector.z=-this._moveState.forward+this._moveState.back}updateRotationVector(){this._rotationVector.x=-this._moveState.pitchDown+this._moveState.pitchUp,this._rotationVector.y=-this._moveState.yawRight+this._moveState.yawLeft,this._rotationVector.z=-this._moveState.rollRight+this._moveState.rollLeft}update(e){const n=this._moveVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix);this.camera.position.flow(n);const r=this._rotationVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix),a=new t.Quaternion(r.x,r.y,r.z,1).normalize();this.camera.position.applyQuaternion(a)}}class No{constructor(e="i"){this.action=void 0,this.key=e;const t=ge(this,this.onKeyDown);window.addEventListener("keydown",t,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.action&&this.action()}}class Lo{constructor(e,t,n){this.controller=e,this.camera=t,this.solid=n,this._isSelecting=!1,this._isSqueezing=!1;const r=ge(this,this.onSelectStart),a=ge(this,this.onSelectEnd),o=ge(this,this.onSqueezeStart),s=ge(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",r),this.controller.addEventListener("selectend",a),this.controller.addEventListener("squeezestart",o),this.controller.addEventListener("squeezeend",s)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}chase(e){this.solid.isRendered=this._isSelecting;const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Ve].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.solid.isom.copy(i.globalBoost),this.solid.isom.matrix.multiply(i.facing),this.solid.updateData()}}class Fo{constructor(e="p"){this.actionKeyDown=void 0,this.actionKeyUp=void 0,this.key=e;const t=ge(this,this.onKeyDown),n=ge(this,this.onKeyUp);window.addEventListener("keydown",t,!1),window.addEventListener("keyup",n,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.actionKeyDown&&this.actionKeyDown()}onKeyUp(e){e.key===this.key&&void 0!==this.actionKeyUp&&this.actionKeyUp()}}class Go{constructor(e,n,r,a){this.controller=e,this.camera=n,this.solids=r,this.speed=a,this._status=0,this._nextBullet=0,this._clock=new t.Clock;const o=ge(this,this.onSelectStart),s=ge(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){0===this._status&&(this._status=1)}onSelectEnd(){}shoot(e){const t=this.solids[this._nextBullet];t.bulletData={time:this._clock.getElapsedTime(),position:e},t.isRendered=!0,this._nextBullet=(this._nextBullet+1)%this.solids.length}updateBullet(e){const t=this.solids[e];if(t.hasOwnProperty("bulletData")){const e=this._clock.getElapsedTime()-t.bulletData.time,n=t.bulletData.position.clone().flow(new s(0,0,-this.speed*e));t.isom.copy(n.boost),t.updateData()}}updateAllBullets(){for(let e=0;e<this.solids.length;e++)this.updateBullet(e)}update(e){if(1===this._status){const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Ve].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.shoot(i.globalPosition),this._status=0}this.updateAllBullets()}}class Ao{constructor(e="p",t=2,n=0){this.key=e,this.stateNumber=t,this.state=n,this.justChanged=!1;const r=ge(this,this.onKeyDown);window.addEventListener("keydown",r,!1)}onKeyDown(e){e.key===this.key&&(this.state=(this.state+1)%this.stateNumber,this.justChanged=!0)}}class zo extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this._isSelecting=!1,this._isSqueezing=!1;const n=ge(this,this.onSelectStart),r=ge(this,this.onSelectEnd),a=ge(this,this.onSqueezeStart),o=ge(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}get update(){if(void 0===this._update){const e=10,n=new s,r=new s;let a=[],o=0,i=!1;this._update=function(l){const c=new s;if(this.controller.getWorldDirection(c),c.normalize().multiplyScalar(1/e),r.add(c),i&&r.sub(a[o]),a[o]=c,i&&this._isSelecting){const e=r.clone().normalize(),a=n.clone().normalize(),o=(new t.Quaternion).setFromUnitVectors(e,a).normalize();this.position.applyQuaternion(o)}n.copy(r),o=(o+1)%e,0===o&&(i=!0)}}return this._update}}class Ho extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this.movementSpeed=.5,this._isSelecting=!1,this._isSqueezing=!1;const n=ge(this,this.onSelectStart),r=ge(this,this.onSelectEnd),a=ge(this,this.onSqueezeStart),o=ge(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}update(e){if(this._isSelecting){const t=new s;this.controller.getWorldDirection(t),t.normalize().multiplyScalar(-this.movementSpeed*e),this.position.flow(t)}}}class jo{constructor(e,t,n){this.controller=e,this.camera=t,this.light=n}chase(e){const n=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[Ve].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[Me].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),i=this.controller.matrixWorld.clone().setPosition(a),l=this.camera.position.clone().fakeDiffExpMap(i);this.light.position=(new o).applyIsometry(l.globalBoost)}}class Oo{constructor(e,t,n=!1,r=!1,a=void 0){if(this.position=e,this.controller=t,this._reset=0,this._alignFacing=n,this._snap=r,this._camera=a,this._alignFacing&&void 0===a)throw new Error("VRControlsReset.constructor, the camera is needed when the alignFacing option is on");const o=ge(this,this.onSelectStart),s=ge(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){this._reset=1}onSelectEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0}}}class Wo{constructor(e,t,n,r=!1,a=!1,o=void 0){if(this.position=e,this.targetPosition=t,this.controller=n,this._reset=0,this._alignFacing=r,this._snap=a,this._camera=o,this._alignFacing&&void 0===o)throw new Error("AdvancedResetVRControls.constructor, the camera is needed when the alignFacing option is on");const s=ge(this,this.onSqueezeStart),i=ge(this,this.onSqueezeEnd);this.controller.addEventListener("squeezestart",s),this.controller.addEventListener("squeezeend",i)}onSqueezeStart(){this._reset=1}onSqueezeEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0,this.position.local.boost.copy(this.targetPosition.boost),this.position.local.quaternion.premultiply(this.targetPosition.quaternion)}}}var qo=r(6947),Qo=r.n(qo);class Ko extends Q{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return Qo()}}var $o=r(4024),Yo=r.n($o);class Zo extends Q{constructor(){super()}fragmentShader(){return Yo()}}class Xo{constructor(e,t=0,n=0){this.ring=e,this.a=t,this.b=n,this.reduce()}reduce(){return this.a=Math.round(this.a),this.b=Math.round(this.b),this}negate(){return this.a=-this.a,this.b=-this.b,this}multiply(e){const t=this.a,n=this.b;return this.a=t*e.a+this.ring.d*n*e.b,this.b=t*e.b+n*e.a,this.reduce()}add(e){return this.a=this.a+e.a,this.b=this.b+e.b,this.reduce()}sub(e){return this.a=this.a-e.a,this.b=this.b-e.b,this.reduce()}sum(){this.copy(this.ring.zero);for(const e of arguments)this.add(e);return this}product(){this.copy(this.ring.one);for(const e of arguments)this.multiply(e);return this}addProduct(){const e=new Xo(this.ring).product(...arguments);return this.add(e),this}subProduct(){const e=new Xo(this.ring).product(...arguments);return this.sub(e),this}toNumber(){return this.a+this.b*Math.sqrt(this.ring.d)}equals(e){return this.a===e.a&&this.b===e.b}isZero(){return 0===this.a&&0===this.b}clone(){const e=new Xo(this.ring);return e.a=this.a,e.b=this.b,e}copy(e){return this.a=e.a,this.b=e.b,this}toLog(){return`${this.a} + ${this.b} _rD`}}var Jo=r(5688),es=r.n(Jo);class ts{constructor(e){this.ring=e,this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()]}get isQuadRingMatrix4(){return!0}get a(){const e=this.toArray().map((e=>e.a));return(new t.Matrix4).fromArray(e)}get b(){const e=this.toArray().map((e=>e.b));return(new t.Matrix4).fromArray(e)}getEntry(e,t){return this.elements[4*t+e]}setEntry(e,t,n){return this.elements[4*t+e].copy(n),this}set(e,t,n,r,a,o,s,i,l,c,d,u,h,p,m,b){for(let e=0;e<4;e++)for(let t=0;t<4;t++)this.setEntry(e,t,arguments[4*e+t]);return this}identity(){return this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()],this}multiplyMatrices(e,t){for(let n=0;n<4;n++)for(let r=0;r<4;r++){this.setEntry(n,r,this.ring.zero);for(let a=0;a<4;a++)this.getEntry(n,r).addProduct(e.getEntry(n,a),t.getEntry(a,r))}return this}multiply(e){return this.multiplyMatrices(this.clone(),e)}premultiply(e){return this.multiplyMatrices(e,this.clone())}multiplyScalar(e){for(let t=0;t<16;t++)this.elements[t].multiply(e);return this}transpose(){const e=this.elements;let t=this.ring.element();return t.copy(e[1]),e[1].copy(e[4]),e[4].copy(t),t.copy(e[2]),e[2].copy(e[8]),e[8].copy(t),t.copy(e[6]),e[6].copy(e[9]),e[9].copy(t),t.copy(e[3]),e[3].copy(e[12]),e[12].copy(t),t.copy(e[7]),e[7].copy(e[13]),e[13].copy(t),t.copy(e[11]),e[11].copy(e[14]),e[14].copy(t),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],a=e[3],o=e[4],s=e[5],i=e[6],l=e[7],c=e[8],d=e[9],u=e[10],h=e[11],p=e[12],m=e[13],b=e[14],v=e[15];return e[0]=this.ring.element().addProduct(d,b,l).subProduct(m,u,l).addProduct(m,i,h).subProduct(s,b,h).subProduct(d,i,v).addProduct(s,u,v),e[1]=this.ring.element().addProduct(m,u,a).subProduct(d,b,a).subProduct(m,r,h).addProduct(n,b,h).addProduct(d,r,v).subProduct(n,u,v),e[2]=this.ring.element().addProduct(s,b,a).subProduct(m,i,a).addProduct(m,r,l).subProduct(n,b,l).subProduct(s,r,v).addProduct(n,i,v),e[3]=this.ring.element().addProduct(d,i,a).subProduct(s,u,a).subProduct(d,r,l).addProduct(n,u,l).addProduct(s,r,h).subProduct(n,i,h),e[4]=this.ring.element().addProduct(p,u,l).subProduct(c,b,l).subProduct(p,i,h).addProduct(o,b,h).addProduct(c,i,v).subProduct(o,u,v),e[5]=this.ring.element().addProduct(c,b,a).subProduct(p,u,a).addProduct(p,r,h).subProduct(t,b,h).subProduct(c,r,v).addProduct(t,u,v),e[6]=this.ring.element().addProduct(p,i,a).subProduct(o,b,a).subProduct(p,r,l).addProduct(t,b,l).addProduct(o,r,v).subProduct(t,i,v),e[7]=this.ring.element().addProduct(o,u,a).subProduct(c,i,a).addProduct(c,r,l).subProduct(t,u,l).subProduct(o,r,h).addProduct(t,i,h),e[8]=this.ring.element().addProduct(c,m,l).subProduct(p,d,l).addProduct(p,s,h).subProduct(o,m,h).subProduct(c,s,v).addProduct(o,d,v),e[9]=this.ring.element().addProduct(p,d,a).subProduct(c,m,a).subProduct(p,n,h).addProduct(t,m,h).addProduct(c,n,v).subProduct(t,d,v),e[10]=this.ring.element().addProduct(o,m,a).subProduct(p,s,a).addProduct(p,n,l).subProduct(t,m,l).subProduct(o,n,v).addProduct(t,s,v),e[11]=this.ring.element().addProduct(c,s,a).subProduct(o,d,a).subProduct(c,n,l).addProduct(t,d,l).addProduct(o,n,h).subProduct(t,s,h),e[12]=this.ring.element().addProduct(p,d,i).subProduct(c,m,i).subProduct(p,s,u).addProduct(o,m,u).addProduct(c,s,b).subProduct(o,d,b),e[13]=this.ring.element().addProduct(c,m,r).subProduct(p,d,r).addProduct(p,n,u).subProduct(t,m,u).subProduct(c,n,b).addProduct(t,d,b),e[14]=this.ring.element().addProduct(p,s,r).subProduct(o,m,r).subProduct(p,n,i).addProduct(t,m,i).addProduct(o,n,b).subProduct(t,s,b),e[15]=this.ring.element().addProduct(o,d,r).subProduct(c,s,r).addProduct(c,n,i).subProduct(t,d,i).subProduct(o,n,u).addProduct(t,s,u),this}equals(e){for(let t=0;t<16;t++)if(!this.elements[t].equals(e.elements[t]))return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n].copy(e[n+t]);return this}toArray(e=[],t=0){const n=this.elements;for(let r=0;r<16;r++)e[t+r]=n[r].clone();return e}toMatrix4(){const e=this.toArray().map((e=>e.toNumber()));return(new t.Matrix4).fromArray(e)}clone(){return new ts(this.ring).fromArray(this.elements)}copy(e){return this.fromArray(e.elements)}toLog(){return this.toMatrix4().toLog()}}class ns{constructor(e){this.d=e}element(e=0,t=0){return new Xo(this,e,t)}matrix4(){return new ts(this)}get one(){return new Xo(this,1)}get zero(){return new Xo(this,0)}shader(e){e.addChunk(es()),e.addConstant("QUAD_RING_D","int",this.d)}}class rs{constructor(){this.elements=[1,0,0,1]}set(e,t,n,r){return this.elements=[e,n,t,r],this}identity(){return this.set(1,0,0,1),this}multplyMatrices(e,t){const[n,r,a,o]=e.elements,[s,i,l,c]=t.elements;return this.elements=[n*s+a*i,r*s+o*i,n*l+a*c,r*l+o*c],this}multiply(e){return this.multplyMatrices(this,e)}premultiply(e){return this.multplyMatrices(e,this)}power(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}}determinant(){const[e,t,n,r]=this.elements;return e*r-n*t}invert(){const[e,t,n,r]=this.elements,a=this.determinant();return this.elements=[r/a,-t/a,-n/a,e/a],this}clone(){const e=new rs;for(let t=0;t<4;t++)e.elements[t]=this.elements[t];return e}copy(e){for(let t=0;t<4;t++)this.elements[t]=e.elements[t];return this}equals(e){for(let t=0;t<4;t++)if(this.elements[t]!==e.elements[t])return!1;return!0}}var as=r(872),os=r.n(as),ss=r(1353),is=r.n(ss);class ls{constructor(e){this.threeCamera=new t.PerspectiveCamera(void 0!==e.fov?e.fov:70,window.innerWidth/window.innerHeight,.01,2e3),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1),this.minDist=void 0!==e.minDist?e.minDist:0,this.maxDist=void 0!==e.maxDist?e.maxDist:50,this.safetyDist=void 0!==e.safetyDist?e.safetyDist:0,this.maxSteps=void 0!==e.maxSteps?e.maxSteps:100,this.threshold=void 0!==e.threshold?e.threshold:1e-4,this.position=new Ce(e.set)}set aspect(e){this.threeCamera.aspect=e}get fov(){return this.threeCamera.fov}set fov(e){this.threeCamera.fov=e,this.threeCamera.updateProjectionMatrix()}get matrix(){return this.threeCamera.matrixWorld}updateProjectionMatrix(){this.threeCamera.updateProjectionMatrix()}shader(e){e.addClass("Camera",os()),e.addUniform("camera","Camera",this),e.addChunk(is())}}var cs=r(9642),ds=r.n(cs),us=r(3474),hs=r.n(us);class ps extends ls{constructor(e){super(e),this.focus=e.focus,this.center=e.center,this.screen=e.screen,this.radius=e.radius,this.ratio=e.ratio}shader(e){e.addClass("DollyCamera",ds()),e.addUniform("camera","DollyCamera",this),e.addChunk(hs())}}class ms extends _e{constructor(e,n=0,r=0,a=0){super(e),this.coords=new t.Vector3(n,r,a)}get icoords(){return this.coords.toArray()}identity(){return this.coords.set(0,0,0),this}multiply(e){return this.coords.add(e.coords),this}premultiply(e){return this.coords.add(e.coords),this}invert(){return this.coords.negate(),this}toIsometry(){const[e,r,a]=this.coords.toArray(),o=(new t.Vector4).add(this.group.halfTranslationA.clone().multiplyScalar(2*e)).add(this.group.halfTranslationB.clone().multiplyScalar(2*r)).add(this.group.halfTranslationC.clone().multiplyScalar(2*a)),s=new n;return s.matrix.set(1,0,0,o.x,0,1,0,o.y,0,0,1,o.z,0,0,0,1),s}equals(e){return this.coords.equals(e.coords)}clone(){const e=new ms(this.group);return e.coords.copy(this.coords),e}copy(e){return this.coords.copy(e.coords),this}}var bs=r(6599),vs=r.n(bs),fs=r(9106),gs=r.n(fs);const xs=new class extends Ye{constructor(e=void 0,n=void 0,r=void 0){super(),this._halfTranslationA=void 0!==e?e:new t.Vector4(1,0,0,0),this._halfTranslationB=void 0!==n?n:new t.Vector4(0,1,0,0),this._halfTranslationC=void 0!==r?r:new t.Vector4(0,0,1,0),this.updateDotMatrix()}get halfTranslationA(){return this._halfTranslationA}set halfTranslationA(e){this._halfTranslationA=void 0!==e?e:new t.Vector4(1,0,0,0),this.updateDotMatrix()}get halfTranslationB(){return this._halfTranslationB}set halfTranslationB(e){this._halfTranslationB=void 0!==e?e:new t.Vector4(0,1,0,0),this.updateDotMatrix()}get halfTranslationC(){return this._halfTranslationC}set halfTranslationC(e){this._halfTranslationC=void 0!==e?e:new t.Vector4(0,0,1,0),this.updateDotMatrix()}updateDotMatrix(){void 0===this._dotMatrix&&(this._dotMatrix=new t.Matrix4);const e=(new t.Matrix4).set(this.halfTranslationA.x,this.halfTranslationB.x,this.halfTranslationC.x,0,this.halfTranslationA.y,this.halfTranslationB.y,this.halfTranslationC.y,0,this.halfTranslationA.z,this.halfTranslationB.z,this.halfTranslationC.z,0,0,0,0,1).invert();this._dotMatrix.copy(e).transpose().multiply(e)}get dotMatrix(){return this._dotMatrix}element(){return new ms(this,arguments.length>0?arguments[0]:0,arguments.length>1?arguments[1]:0,arguments.length>2?arguments[2]:0)}shader(e){e.addChunk(gs()),e.addUniform("group","Group",this),e.addChunk(vs())}};function ys(e){const t=xs.halfTranslationA.clone().applyMatrix4(xs.dotMatrix);return e.coords.dot(t)>1}const Vs="//\nbool testXp(Point p){\n    return dot(p.coords, group.dotMatrix * group.halfTranslationA) > 1.;\n}\n",Ms="//\nfloat creepXp(ExtVector v, float offset){\n    Vector local = v.vector.local;\n    vec4 uAux = group.dotMatrix * group.halfTranslationA;\n    float aux0 = 1. - dot(local.pos.coords, uAux);\n    float aux1 = dot(local.dir, uAux);\n    return aux0 / aux1 + offset;\n}\n";function ws(e){const t=xs.halfTranslationA.clone().applyMatrix4(xs.dotMatrix);return e.coords.dot(t)<-1}const _s="//\nbool testXn(Point p){\n    return dot(p.coords, group.dotMatrix * group.halfTranslationA) < -1.;\n}\n",Cs="//\nfloat creepXn(ExtVector v, float offset){\n    Vector local = v.vector.local;\n    vec4 uAux = group.dotMatrix * group.halfTranslationA;\n    float aux0 = 1. + dot(local.pos.coords, uAux);\n    float aux1 = -dot(local.dir, uAux);\n    return aux0 / aux1 + offset;\n}\n";function Ts(e){const t=xs.halfTranslationB.clone().applyMatrix4(xs.dotMatrix);return e.coords.dot(t)>1}const Ss="//\nbool testYp(Point p){\n    return dot(p.coords, group.dotMatrix * group.halfTranslationB) > 1.;\n}\n",Rs="//\nfloat creepYp(ExtVector v, float offset){\n    Vector local = v.vector.local;\n    vec4 uAux = group.dotMatrix * group.halfTranslationB;\n    float aux0 = 1. - dot(local.pos.coords, uAux);\n    float aux1 = dot(local.dir, uAux);\n    return aux0 / aux1 + offset;\n}\n";function Is(e){const t=xs.halfTranslationB.clone().applyMatrix4(xs.dotMatrix);return e.coords.dot(t)<-1}const Ds="//\nbool testYn(Point p){\n    return dot(p.coords, group.dotMatrix * group.halfTranslationB) < -1.;\n}\n",Es="//\nfloat creepYn(ExtVector v, float offset){\n    Vector local = v.vector.local;\n    vec4 uAux = group.dotMatrix * group.halfTranslationB;\n    float aux0 = 1. + dot(local.pos.coords, uAux);\n    float aux1 = -dot(local.dir, uAux);\n    return aux0 / aux1 + offset;\n}\n";function Ps(e){const t=xs.halfTranslationC.clone().applyMatrix4(xs.dotMatrix);return e.coords.dot(t)>1}const Us="//\nbool testZp(Point p){\n    return dot(p.coords, group.dotMatrix * group.halfTranslationC) > 1.;\n}\n",ks="//\nfloat creepZp(ExtVector v, float offset){\n    Vector local = v.vector.local;\n    vec4 uAux = group.dotMatrix * group.halfTranslationC;\n    float aux0 = 1. - dot(local.pos.coords, uAux);\n    float aux1 = dot(local.dir, uAux);\n    return aux0 / aux1 + offset;\n}\n";function Bs(e){const t=xs.halfTranslationC.clone().applyMatrix4(xs.dotMatrix);return e.coords.dot(t)<-1}const Ns="//\nbool testZn(Point p){\n    return dot(p.coords, group.dotMatrix * group.halfTranslationC) < -1.;\n}\n",Ls="//\nfloat creepZn(ExtVector v, float offset){\n    Vector local = v.vector.local;\n    vec4 uAux = group.dotMatrix * group.halfTranslationC;\n    float aux0 = 1. + dot(local.pos.coords, uAux);\n    float aux1 = -dot(local.dir, uAux);\n    return aux0 / aux1 + offset;\n}\n",Fs=xs.element(-1,0,0),Gs=xs.element(1,0,0),As=xs.element(0,-1,0),zs=xs.element(0,1,0),Hs=xs.element(0,0,-1),js=xs.element(0,0,1),Os=[{elt:Fs,inv:Gs},{elt:Gs,inv:Fs},{elt:As,inv:zs},{elt:zs,inv:As},{elt:Hs,inv:js},{elt:js,inv:Hs}],Ws=[{elt:Fs,inv:Gs},{elt:Gs,inv:Fs},{elt:As,inv:zs},{elt:zs,inv:As},{elt:Hs,inv:js},{elt:js,inv:Hs},{elt:Fs.clone().multiply(As),inv:zs.clone().multiply(Gs)},{elt:Fs.clone().multiply(zs),inv:As.clone().multiply(Gs)},{elt:Gs.clone().multiply(As),inv:zs.clone().multiply(Fs)},{elt:Gs.clone().multiply(zs),inv:As.clone().multiply(Fs)},{elt:Fs.clone().multiply(Hs),inv:js.clone().multiply(Gs)},{elt:Fs.clone().multiply(js),inv:Hs.clone().multiply(Gs)},{elt:Gs.clone().multiply(Hs),inv:js.clone().multiply(Fs)},{elt:Gs.clone().multiply(js),inv:Hs.clone().multiply(Fs)},{elt:As.clone().multiply(Hs),inv:js.clone().multiply(zs)},{elt:As.clone().multiply(js),inv:Hs.clone().multiply(zs)},{elt:zs.clone().multiply(Hs),inv:js.clone().multiply(As)},{elt:zs.clone().multiply(js),inv:Hs.clone().multiply(As)}],qs=new bt(Os).add(ys,Vs,Fs,Gs,Ms).add(ws,_s,Gs,Fs,Cs).add(Ts,Ss,As,zs,Rs).add(Is,Ds,zs,As,Es).add(Ps,Us,Hs,js,ks).add(Bs,Ns,js,Hs,Ls),Qs=(new bt(Ws).add(ys,Vs,Fs,Gs,Ms).add(ws,_s,Gs,Fs,Cs).add(Ts,Ss,As,zs,Rs).add(Is,Ds,zs,As,Es).add(Ps,Us,Hs,js,ks).add(Bs,Ns,js,Hs,Ls),qs);class Ks extends _e{constructor(e,n=0,r=0,a=0){super(e),this.coords=new t.Vector3(n,r,a)}get icoords(){return this.coords.toArray()}identity(){return this.coords.set(0,0,0),this}multiply(e){const t=1-this.coords.x%2*2,n=e.coords.clone();return n.setY(t*e.coords.y),this.coords.add(n),this}premultiply(e){const t=1-e.coords.x%2*2;return this.coords.setY(t*this.coords.y),this.coords.add(e.coords),this}invert(){const e=1-this.coords.x%2*2;return this.coords.setY(e*this.coords.y),this.coords.negate(),this}toIsometry(){const[e,t,r]=this.coords.toArray(),a=1-e%2*2,o=new n;return o.matrix.set(1,0,0,2*this.group.halfWidth*e,0,a,0,2*this.group.halfWidth*t,0,0,a,2*this.group.halfWidth*r,0,0,0,1),o}equals(e){return this.coords.equals(e.coords)}clone(){const e=new Ks(this.group);return e.coords.copy(this.coords),e}copy(e){return this.coords.copy(e.coords),this}}var $s=r(4693),Ys=r.n($s),Zs=r(733),Xs=r.n(Zs);const Js=new class extends Ye{constructor(e=1){super(),this._halfWidth=e}get halfWidth(){return this._halfWidth}set halfWidth(e){this._halfWidth=e}element(){return new Ks(this,arguments.length>0?arguments[0]:0,arguments.length>1?arguments[1]:0,arguments.length>2?arguments[2]:0)}shader(e){e.addChunk(Xs()),e.addUniform("group","Group",this),e.addChunk(Ys())}};const ei=Js.element(-1,0,0),ti=Js.element(1,0,0),ni=Js.element(0,-1,0),ri=Js.element(0,1,0),ai=Js.element(0,0,-1),oi=Js.element(0,0,1),si=(new bt).add((function(e){return e.coords.x>Js.halfWidth}),"//\nbool testXp(Point p){\n    return p.coords.x > group.halfWidth;\n}\n",ei,ti).add((function(e){return e.coords.x<-Js.halfWidth}),"//\nbool testXn(Point p){\n    return p.coords.x < -group.halfWidth;\n}\n",ti,ei).add((function(e){return e.coords.y>Js.halfWidth}),"//\nbool testYp(Point p){\n    return p.coords.y > group.halfWidth;\n}\n",ni,ri).add((function(e){return e.coords.y<-Js.halfWidth}),"//\nbool testYn(Point p){\n    return p.coords.y < -group.halfWidth;\n}\n",ri,ni).add((function(e){return e.coords.z>Js.halfWidth}),"//\nbool testZp(Point p){\n    return p.coords.z > group.halfWidth;\n}\n",ai,oi).add((function(e){return e.coords.z<-Js.halfWidth}),"//\nbool testZn(Point p){\n    return p.coords.z < -group.halfWidth;\n}\n",oi,ai);class ii extends _e{constructor(e){super(e),this.rotation=new t.Vector3(1,1,1),this.translation=new t.Vector3(0,0,0)}get irotation(){return this.rotation.toArray()}get itranslation(){return this.translation.toArray()}setRotation(e,t,n){return this.rotation.set(e,t,n),this}setTranslation(e,t,n){return this.translation.set(e,t,n),this}identity(){return this.rotation.set(1,1,1),this.translation.set(0,0,0),this}multiply(e){const n=(new t.Vector3).multiplyVectors(this.rotation,e.rotation),r=(new t.Vector3).addVectors(this.translation,(new t.Vector3).multiplyVectors(this.rotation,e.translation));return this.rotation.copy(n),this.translation.copy(r),this}premultiply(e){const n=(new t.Vector3).multiplyVectors(e.rotation,this.rotation),r=(new t.Vector3).addVectors(e.translation,(new t.Vector3).multiplyVectors(e.rotation,this.translation));return this.rotation.copy(n),this.translation.copy(r),this}invert(){const e=(new t.Vector3).multiplyVectors(this.rotation,this.translation).negate();return this.translation.copy(e),this}toIsometry(){const[e,t,r]=this.rotation.toArray(),[a,o,s]=this.translation.toArray(),i=new n;return i.matrix.set(e,0,0,this.group.length*a,0,t,0,this.group.length*o,0,0,r,this.group.length*s,0,0,0,1),i}equals(e){return this.rotation.equals(e.rotation)&&this.translation.equals(e.rotation)}copy(e){return this.rotation.copy(e.rotation),this.translation.copy(e.translation),this}clone(){const e=new ii(this.group);return e.copy(this),e}}var li=r(6678),ci=r.n(li),di=r(3794),ui=r.n(di);const hi=new class extends Ye{constructor(e=1){super(),this._length=e}get length(){return this._length}set length(e){this._length=e}element(){return new ii(this)}shader(e){e.addChunk(ui()),e.addUniform("group","Group",this),e.addChunk(ci())}},pi=[hi.element().setRotation(1,-1,-1).setTranslation(1,1,0),hi.element().setRotation(1,-1,-1).setTranslation(-1,1,0),hi.element().setRotation(-1,1,-1).setTranslation(0,1,1),hi.element().setRotation(-1,1,-1).setTranslation(0,-1,1),hi.element().setRotation(-1,-1,1).setTranslation(1,0,1),hi.element().setRotation(-1,-1,1).setTranslation(1,0,-1),hi.element().setRotation(1,-1,-1).setTranslation(-1,-1,0),hi.element().setRotation(1,-1,-1).setTranslation(1,-1,0),hi.element().setRotation(-1,1,-1).setTranslation(0,-1,-1),hi.element().setRotation(-1,1,-1).setTranslation(0,1,-1),hi.element().setRotation(-1,-1,1).setTranslation(-1,0,-1),hi.element().setRotation(-1,-1,1).setTranslation(-1,0,1)],mi=[[new t.Vector4(-1,1,0,-hi.length),pi[0],pi[1]],[new t.Vector4(1,1,0,-hi.length),pi[1],pi[0]],[new t.Vector4(0,-1,1,-hi.length),pi[2],pi[3]],[new t.Vector4(0,1,1,-hi.length),pi[3],pi[2]],[new t.Vector4(1,0,-1,-hi.length),pi[4],pi[5]],[new t.Vector4(1,0,1,-hi.length),pi[5],pi[4]],[new t.Vector4(1,-1,0,-hi.length),pi[6],pi[7]],[new t.Vector4(-1,-1,0,-hi.length),pi[7],pi[6]],[new t.Vector4(0,1,-1,-hi.length),pi[8],pi[9]],[new t.Vector4(0,-1,-1,-hi.length),pi[9],pi[8]],[new t.Vector4(-1,0,1,-hi.length),pi[10],pi[11]],[new t.Vector4(-1,0,-1,-hi.length),pi[11],pi[10]]],bi=new bt;for(let e=0;e<mi.length;e++){const[t,n,r]=mi[e],a=function(e){return e.coords.dot(t)>0},o=`//\n    bool test${e}(Point p){\n        vec4 normal = vec4(${t.x}, ${t.y}, ${t.z}, ${t.w});\n        return dot(p.coords, normal) > 0.;\n    }\n    `;bi.add(a,o,n,r)}const vi=bi;var fi=r(6313),gi=r.n(fi),xi=r(7577),yi=r.n(xi),Vi=r(2898),Mi=r.n(Vi);class wi extends Mt{constructor(e,t,n=1){super(1),this.position=e,this.color=t,this.intensity=n,this.addImport(Mi())}get isGlobal(){return!0}get uniformType(){return"PointLight"}static glslClass(){return gi()}glslDirections(){return yi()(this)}}var _i=r(7091),Ci=r.n(_i);class Ti extends Mt{constructor(e,t=1,n){super(1),this.color=e,this.intensity=t,this.direction=n.clone().normalize()}get isGlobal(){return!0}get uniformType(){return"ConstDirLight"}static glslClass(){return Ci()}glslDirections(){return yi()(this)}}var Si=r(2297),Ri=r.n(Si);class Ii extends Mt{constructor(e,t,n=1){super(1),this.position=e,this.color=t,this.intensity=n,this.addImport(Mi())}get isGlobal(){return!0}get uniformType(){return"LocalPointLight"}static glslClass(){return Ri()}glslDirections(){return yi()(this)}}var Di=r(1754),Ei=r.n(Di);class Pi extends wt{constructor(e,t){super(),this.mainColor=e,this.weight=t}get uniformType(){return"VaryingColorMaterial"}get usesNormal(){return!1}static glslClass(){return Ei()}glslRender(){return It()(this)}}var Ui=r(9030),ki=r.n(Ui);class Bi extends wt{constructor(e,t,n,r,a){super(),this.mainColor=e,this.accent1=t,this.accent2=n,this.accent3=r,this.grid=null!=a&&a}get uniformType(){return"MultiColorMaterial"}get usesNormal(){return!1}static glslClass(){return ki()}glslRender(){return It()(this)}}var Ni=r(7329),Li=r.n(Ni),Fi=r(8976),Gi=r.n(Fi);class Ai extends Vt{constructor(e,t){super(e),this.shape=t,this.shape.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData()}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return!1}static glslClass(){return""}glslSDF(){return Li()(this)}glslGradient(){return Gi()(this)}setId(e){this.shape.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),super.onAdd(e)}shader(e){this.shape.shader(e),super.shader(e)}}var zi=r(8011),Hi=r.n(zi),ji=r(1241),Oi=r.n(ji),Wi=r(3707),qi=r.n(Wi),Qi=r(5030),Ki=r.n(Qi),$i=r(4355),Yi=r.n($i);class Zi extends yt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("BallShape: this type of location is not allowed");r.makeTranslation(e)}super(r),this.addImport(Hi()),this.radius=t,this._center=void 0,this.updateData()}get isBallShape(){return!0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!0}get uniformType(){return"BallShape"}get hasUVMap(){return!0}static glslClass(){return Oi()}glslSDF(){return qi()(this)}glslGradient(){return Ki()(this)}glslUVMap(){return Yi()(this)}}var Xi=r(7111),Ji=r.n(Xi);class el extends yt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("LocalBallShape: this type of location is not allowed");r.makeTranslation(e)}super(r),this.addImport(Hi()),this.radius=t,this._center=void 0}get isLocalBallShape(){return!0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get uniformType(){return"LocalBallShape"}get hasUVMap(){return!0}static glslClass(){return Ji()}glslSDF(){return qi()(this)}glslGradient(){return Ki()(this)}glslUVMap(){return Yi()(this)}}var tl=r(2130),nl=r.n(tl);class rl extends yt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else{if(!e.isPoint)throw new Error("LocalBallShape: this type of location is not allowed");r.makeTranslation(e)}super(r),this.addImport(Hi()),this.radius=t,this._center=void 0}get isLocalBallShape(){return!0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get uniformType(){return"LocalDirectedBallShape"}get hasUVMap(){return!0}static glslClass(){return nl()}glslSDF(){return qi()(this)}glslGradient(){return Ki()(this)}glslUVMap(){return Yi()(this)}}var al=r(5064),ol=r.n(al);new t.Vector3(1,0,0),new t.Vector3(0,1,0),new t.Vector3(0,0,1);class sl extends yt{constructor(e){super(e),this._pos=void 0,this._normal=void 0,this._uDir=void 0,this._vDir=void 0}updateData(){super.updateData();const e=(new o).applyIsometry(this.absoluteIsom),n=new t.Vector4(0,0,1,0).applyMatrix4(this.absoluteIsom.matrix);this._normal={pos:e,dir:n},this._uDir=new s(1,0,0).applyMatrix4(this.absoluteIsom.matrix),this._vDir=new s(0,1,0).applyMatrix4(this.absoluteIsom.matrix)}get normal(){return void 0===this._normal&&this.updateData(),this._normal}get uDir(){return void 0===this._uDir&&this.updateData(),this._uDir}get vDir(){return void 0===this._vDir&&this.updateData(),this._vDir}get isGlobal(){return!0}get isHalfSpaceShape(){return!0}get hasUVMap(){return!0}get uniformType(){return"HalfSpaceShape"}static glslClass(){return ol()}glslSDF(){return qi()(this)}glslGradient(){return Ki()(this)}glslUVMap(){return Yi()(this)}}var il=r(3510),ll=r.n(il);class cl extends yt{constructor(e,t){super(e),this.radius=t,this._vector=void 0}updateData(){super.updateData();const e=(new o).applyIsometry(this.absoluteIsom),n=new t.Vector4(0,0,1,0).applyMatrix4(this.absoluteIsom.matrix);this._vector={pos:e,dir:n}}get vector(){return void 0===this._vector&&this.updateData(),this._vector}get isGlobal(){return!0}get hasUVMap(){return!0}get uniformType(){return"CylinderShape"}static glslClass(){return ll()}glslSDF(){return qi()(this)}glslGradient(){return Ki()(this)}glslUVMap(){return Yi()(this)}}var dl=r(793),ul=r.n(dl);class hl extends yt{constructor(e,t){super(e),this.radius=t,this._vector=void 0}updateData(){super.updateData();const e=(new o).applyIsometry(this.absoluteIsom),n=new t.Vector4(0,0,1,0).applyMatrix4(this.absoluteIsom.matrix);this._vector={pos:e,dir:n}}get vector(){return void 0===this._vector&&this.updateData(),this._vector}get isGlobal(){return!1}get hasUVMap(){return!0}get uniformType(){return"LocalCylinderShape"}static glslClass(){return ul()}glslSDF(){return qi()(this)}glslGradient(){return Ki()(this)}glslUVMap(){return Yi()(this)}}var pl=r(7499),ml=r.n(pl);class bl extends vt{constructor(e,t,n=void 0){if(!e.hasUVMap){if(t.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map");if(void 0!==n&&n.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map")}super(),this.shape=e,this.material=t,this.ptMaterial=n,this.isRendered=!0,this.addImport(ml())}get isSolid(){return!0}get isom(){return this.shape.isom}get absoluteIsom(){return this.shape.absoluteIsom}get isGlobal(){return this.shape.isGlobal}get isLocal(){return this.shape.isLocal}get uniformType(){return"Solid"}updateData(){this.shape.updateData()}setId(e){this.shape.setId(e),this.material.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),this.material.onAdd(e),super.onAdd(e)}static glslClass(){return""}glslInstance(){return`\n            bool ${this.name}_isRenderedHack = true;\n        `}shader(e){this.shape.shader(e),3===e.useCase&&void 0!==this.ptMaterial?this.ptMaterial.shader(e):this.material.shader(e),super.shader(e)}}class vl extends bl{constructor(e,t,n,r=void 0){super(new Zi(e,t),n,r)}}var fl=r(7479),gl=r.n(fl);class xl extends yt{constructor(e,t,r){const a=new n;if(e.isIsometry)a.copy(e);else{if(!e.isPoint)throw new Error("BoxShape: this type of location is not allowed");a.makeTranslation(e)}super(a),this.addImport(Hi()),this.sides=t,this.rounded=r,this._center=void 0,this.updateData()}get isBoxShape(){return!0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!0}get uniformType(){return"BoxShape"}get hasUVMap(){return!1}static glslClass(){return gl()}glslSDF(){return qi()(this)}}class yl extends bl{constructor(e,t,n,r,a=void 0){super(new xl(e,t,n),r,a)}}class Vl extends bl{constructor(e,t,n,r=void 0){super(new el(e,t),n,r)}}class Ml extends bl{constructor(e,t,n,r=void 0){super(new rl(e,t),n,r)}}class wl extends bl{constructor(e,t,n=void 0){super(new sl(e),t,n)}}class _l extends bl{constructor(e,t,n,r=void 0){super(new cl(e,t),n,r)}}class Cl extends bl{constructor(e,t,n,r=void 0){super(new hl(e,t),n,r)}}h.prototype.constructor.shader1=c(),h.prototype.constructor.shader2=u()})();var o=a.T0,s=a.FJ,i=a.GU,l=a.XH,c=a.ec,d=a.Yb,u=a.ZH,h=a.K9,p=a.FT,m=a.xu,b=a.cK,v=a._x,f=a.kj,g=a.V1,x=a.Vz,y=a.ck,V=a.Iy,M=a.Vf,w=a.Ab,_=a.g6,C=a.TB,T=a.n$,S=a.ak,R=a.Al,I=a.ix,D=a.jZ,E=a.c$,P=a.Qj,U=a.mD,k=a.yb,B=a.iJ,N=a.ZA,L=a.Jz,F=a.eK,G=a.Fr,A=a.RM,z=a.fR,H=a.kK,j=a.ZX,O=a._f,W=a.Ht,q=a.HZ,Q=a.TN,K=a.JV,$=a.Sc,Y=a.Nh,Z=a.RL,X=a._k,J=a.uR,ee=a.gU,te=a.jo,ne=a.Q,re=a.gq,ae=a.Gj,oe=a.s8,se=a.EH,ie=a.L8,le=a.F5,ce=a.Uc,de=a.Fh,ue=a.O5,he=a.oB,pe=a.pJ,me=a.GW,be=a.DZ,ve=a._K,fe=a.JF,ge=a.Lv,xe=a.E9,ye=a.ce,Ve=a.Ly,Me=a.iv,we=a.mH,_e=a.xd,Ce=a.pX,Te=a.Dz,Se=a.Th,Re=a.Uj,Ie=a.bY,De=a.cV,Ee=a.lR,Pe=a.xs,Ue=a.bn,ke=a.oC,Be=a.Z1,Ne=a.h8,Le=a.Qf,Fe=a.jE,Ge=a.k1,Ae=a.ew,ze=a.$p,He=a.xG,je=a.l_,Oe=a.pk,We=a.yI,qe=a.E6,Qe=a.zO,Ke=a.cB,$e=a.OW,Ye=a.n3,Ze=a.Se,Xe=a.PQ,Je=a.$9,et=a.t1,tt=a.uZ,nt=a.Cy,rt=a.qM,at=a.BO,ot=a.mV,st=a.Gi,it=a.jV,lt=a.PB,ct=a.j9,dt=a.oc,ut=a.wS,ht=a.IJ,pt=a.p2,mt=a.w0,bt=a.VL,vt=a.UR,ft=a.dV,gt=a.G0,xt=a.YL,yt=a.re;export{o as AcesFilmPostProcess,s as AdvancedResetVRControls,i as AdvancedShape,l as BOTH,c as Ball,d as BallShape,u as BasicPTMaterial,h as BasicRenderer,p as BasicShape,m as Box,b as CREEPING_FULL,v as CREEPING_OFF,f as CREEPING_STRICT,g as Camera,x as CheckerboardMaterial,y as CombinedPostProcess,V as ComplementShape,M as ConstDirLight,w as Cylinder,_ as CylinderShape,C as DebugMaterial,T as DisplacementShape,S as DollyCamera,R as DragVRControls,I as EquidistantHypStripsMaterial,D as EquidistantSphStripsMaterial,E as ExpFog,P as FlatCamera,U as FlyControls,k as Fog,B as GraphPaperMaterial,N as Group,L as GroupElement,F as HWSet,G as HalfSpace,A as HalfSpaceShape,z as HighlightLocalWrapMaterial,H as HighlightWrapMaterial,j as HypStripsMaterial,O as ImprovedEquidistantHypStripsMaterial,W as ImprovedEquidistantSphStripsMaterial,q as InfoControls,Q as IntersectionShape,K as Isometry,$ as IsotropicChaseVRControls,Y as KeyGenericControls,Z as LEFT,X as Light,J as LightVRControls,ee as LinearToSRGBPostProcess,te as LocalBall,ne as LocalBallShape,re as LocalCylinder,ae as LocalCylinderShape,oe as LocalDirectedBall,se as LocalDirectedBallShape,ie as LocalPointLight,le as Material,ce as Matrix2,de as MoveVRControls,ue as MultiColorMaterial,he as NormalMaterial,pe as PTMaterial,me as PathTracerCamera,be as PathTracerRenderer,ve as PathTracerWrapMaterial,fe as PhongMaterial,ge as PhongWrapMaterial,xe as Point,ye as PointLight,Ve as Position,Me as QuadRing,we as QuadRingElement,_e as QuadRingMatrix4,Ce as RIGHT,Te as RelPosition,Se as Renderer,Re as ResetVRControls,Ie as RotatedSphericalTextureMaterial,De as SMOOTH_MAX_POLY,Ee as SMOOTH_MIN_POLY,Pe as Scene,Ue as Shape,ke as ShootVRControls,Be as SimpleTextureMaterial,Ne as SingleColorMaterial,Le as Solid,Fe as SphereCamera,Ge as SquaresMaterial,Ae as StripsMaterial,ze as SwitchControls,He as TeleportationSet,je as TransitionLocalWrapMaterial,Oe as TransitionWrapMaterial,We as UnionShape,qe as VRCamera,Qe as VRRenderer,Ke as VaryingColorMaterial,$e as Vector,Ye as VideoAlphaTextureMaterial,Ze as VideoFrameTextureMaterial,Xe as VideoTextureMaterial,Je as WrapShape,et as bind,tt as clamp,nt as complement,rt as earthTexture,at as freeAbelianSet,ot as highlightLocalWrap,st as highlightWrap,it as intersection,lt as kleinS1,ct as marsTexture,dt as moonTexture,ut as pathTracerWrap,ht as phongWrap,pt as safeString,mt as sunTexture,bt as transitionLocalWrap,vt as transitionWrap,ft as trivialSet,gt as union,xt as woodBallMaterial,yt as wrap};