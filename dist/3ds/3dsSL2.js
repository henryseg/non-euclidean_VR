import*as e from"three";var t={9397:(e,t)=>{!function(e){var t=/\S/,n=/\"/g,r=/\n/g,a=/\r/g,o=/\\/g,s=/\u2028/,i=/\u2029/;function l(e){"}"===e.n.substr(e.n.length-1)&&(e.n=e.n.substring(0,e.n.length-1))}function c(e){return e.trim?e.trim():e.replace(/^\s*|\s*$/g,"")}function h(e,t,n){if(t.charAt(n)!=e.charAt(0))return!1;for(var r=1,a=e.length;r<a;r++)if(t.charAt(n+r)!=e.charAt(r))return!1;return!0}e.tags={"#":1,"^":2,"<":3,$:4,"/":5,"!":6,">":7,"=":8,_v:9,"{":10,"&":11,_t:12},e.scan=function(n,r){var a=n.length,o=0,s=null,i=null,u="",d=[],m=!1,b=0,p=0,v="{{",f="}}";function g(){u.length>0&&(d.push({tag:"_t",text:new String(u)}),u="")}function x(n,r){if(g(),n&&function(){for(var n=!0,r=p;r<d.length;r++)if(!(n=e.tags[d[r].tag]<e.tags._v||"_t"==d[r].tag&&null===d[r].text.match(t)))return!1;return n}())for(var a,o=p;o<d.length;o++)d[o].text&&((a=d[o+1])&&">"==a.tag&&(a.indent=d[o].text.toString()),d.splice(o,1));else r||d.push({tag:"\n"});m=!1,p=d.length}function y(e,t){var n="="+f,r=e.indexOf(n,t),a=c(e.substring(e.indexOf("=",t)+1,r)).split(" ");return v=a[0],f=a[a.length-1],r+n.length-1}for(r&&(r=r.split(" "),v=r[0],f=r[1]),b=0;b<a;b++)0==o?h(v,n,b)?(--b,g(),o=1):"\n"==n.charAt(b)?x(m):u+=n.charAt(b):1==o?(b+=v.length-1,"="==(s=(i=e.tags[n.charAt(b+1)])?n.charAt(b+1):"_v")?(b=y(n,b),o=0):(i&&b++,o=2),m=b):h(f,n,b)?(d.push({tag:s,n:c(u),otag:v,ctag:f,i:"/"==s?m-v.length:b+f.length}),u="",b+=f.length-1,o=0,"{"==s&&("}}"==f?b++:l(d[d.length-1]))):u+=n.charAt(b);return x(m,!0),d};var u={_t:!0,"\n":!0,$:!0,"/":!0};function d(t,n,r,a){var o,s=[],i=null,l=null;for(o=r[r.length-1];t.length>0;){if(l=t.shift(),o&&"<"==o.tag&&!(l.tag in u))throw new Error("Illegal content in < super tag.");if(e.tags[l.tag]<=e.tags.$||m(l,a))r.push(l),l.nodes=d(t,l.tag,r,a);else{if("/"==l.tag){if(0===r.length)throw new Error("Closing tag without opener: /"+l.n);if(i=r.pop(),l.n!=i.n&&!b(l.n,i.n,a))throw new Error("Nesting error: "+i.n+" vs. "+l.n);return i.end=l.i,s}"\n"==l.tag&&(l.last=0==t.length||"\n"==t[0].tag)}s.push(l)}if(r.length>0)throw new Error("missing closing tag: "+r.pop().n);return s}function m(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n].o==e.n)return e.tag="#",!0}function b(e,t,n){for(var r=0,a=n.length;r<a;r++)if(n[r].c==e&&n[r].o==t)return!0}function p(e){var t=[];for(var n in e.partials)t.push('"'+f(n)+'":{name:"'+f(e.partials[n].name)+'", '+p(e.partials[n])+"}");return"partials: {"+t.join(",")+"}, subs: "+function(e){var t=[];for(var n in e)t.push('"'+f(n)+'": function(c,p,t,i) {'+e[n]+"}");return"{ "+t.join(",")+" }"}(e.subs)}e.stringify=function(t,n,r){return"{code: function (c,p,i) { "+e.wrapMain(t.code)+" },"+p(t)+"}"};var v=0;function f(e){return e.replace(o,"\\\\").replace(n,'\\"').replace(r,"\\n").replace(a,"\\r").replace(s,"\\u2028").replace(i,"\\u2029")}function g(e){return~e.indexOf(".")?"d":"f"}function x(e,t){var n="<"+(t.prefix||"")+e.n+v++;return t.partials[n]={name:e.n,partials:{}},t.code+='t.b(t.rp("'+f(n)+'",c,p,"'+(e.indent||"")+'"));',n}function y(e,t){t.code+="t.b(t.t(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'}function V(e){return"t.b("+e+");"}e.generate=function(t,n,r){v=0;var a={code:"",subs:{},partials:{}};return e.walk(t,a),r.asString?this.stringify(a,n,r):this.makeTemplate(a,n,r)},e.wrapMain=function(e){return'var t=this;t.b(i=i||"");'+e+"return t.fl();"},e.template=e.Template,e.makeTemplate=function(e,t,n){var r=this.makePartials(e);return r.code=new Function("c","p","i",this.wrapMain(e.code)),new this.template(r,t,this,n)},e.makePartials=function(e){var t,n={subs:{},partials:e.partials,name:e.name};for(t in n.partials)n.partials[t]=this.makePartials(n.partials[t]);for(t in e.subs)n.subs[t]=new Function("c","p","t","i",e.subs[t]);return n},e.codegen={"#":function(t,n){n.code+="if(t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,0,'+t.i+","+t.end+',"'+t.otag+" "+t.ctag+'")){t.rs(c,p,function(c,p,t){',e.walk(t.nodes,n),n.code+="});c.pop();}"},"^":function(t,n){n.code+="if(!t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,1,0,0,"")){',e.walk(t.nodes,n),n.code+="};"},">":x,"<":function(t,n){var r={partials:{},code:"",subs:{},inPartial:!0};e.walk(t.nodes,r);var a=n.partials[x(t,n)];a.subs=r.subs,a.partials=r.partials},$:function(t,n){var r={subs:{},code:"",partials:n.partials,prefix:t.n};e.walk(t.nodes,r),n.subs[t.n]=r.code,n.inPartial||(n.code+='t.sub("'+f(t.n)+'",c,p,i);')},"\n":function(e,t){t.code+=V('"\\n"'+(e.last?"":" + i"))},_v:function(e,t){t.code+="t.b(t.v(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'},_t:function(e,t){t.code+=V('"'+f(e.text)+'"')},"{":y,"&":y},e.walk=function(t,n){for(var r,a=0,o=t.length;a<o;a++)(r=e.codegen[t[a].tag])&&r(t[a],n);return n},e.parse=function(e,t,n){return d(e,0,[],(n=n||{}).sectionTags||[])},e.cache={},e.cacheKey=function(e,t){return[e,!!t.asString,!!t.disableLambda,t.delimiters,!!t.modelGet].join("||")},e.compile=function(t,n){n=n||{};var r=e.cacheKey(t,n),a=this.cache[r];if(a){var o=a.partials;for(var s in o)delete o[s].instance;return a}return a=this.generate(this.parse(this.scan(t,n.delimiters),t,n),t,n),this.cache[r]=a}}(t)},5485:(e,t,n)=>{var r=n(9397);r.Template=n(2882).Template,r.template=r.Template,e.exports=r},2882:(e,t)=>{!function(e){function t(e,t,n){var r;return t&&"object"==typeof t&&(void 0!==t[e]?r=t[e]:n&&t.get&&"function"==typeof t.get&&(r=t.get(e))),r}e.Template=function(e,t,n,r){e=e||{},this.r=e.code||this.r,this.c=n,this.options=r||{},this.text=t||"",this.partials=e.partials||{},this.subs=e.subs||{},this.buf=""},e.Template.prototype={r:function(e,t,n){return""},v:function(e){return e=l(e),i.test(e)?e.replace(n,"&amp;").replace(r,"&lt;").replace(a,"&gt;").replace(o,"&#39;").replace(s,"&quot;"):e},t:l,render:function(e,t,n){return this.ri([e],t||{},n)},ri:function(e,t,n){return this.r(e,t,n)},ep:function(e,t){var n=this.partials[e],r=t[n.name];if(n.instance&&n.base==r)return n.instance;if("string"==typeof r){if(!this.c)throw new Error("No compiler available.");r=this.c.compile(r,this.options)}if(!r)return null;if(this.partials[e].base=r,n.subs){for(key in t.stackText||(t.stackText={}),n.subs)t.stackText[key]||(t.stackText[key]=void 0!==this.activeSub&&t.stackText[this.activeSub]?t.stackText[this.activeSub]:this.text);r=function(e,t,n,r,a,o){function s(){}function i(){}var l;s.prototype=e,i.prototype=e.subs;var c=new s;for(l in c.subs=new i,c.subsText={},c.buf="",r=r||{},c.stackSubs=r,c.subsText=o,t)r[l]||(r[l]=t[l]);for(l in r)c.subs[l]=r[l];for(l in a=a||{},c.stackPartials=a,n)a[l]||(a[l]=n[l]);for(l in a)c.partials[l]=a[l];return c}(r,n.subs,n.partials,this.stackSubs,this.stackPartials,t.stackText)}return this.partials[e].instance=r,r},rp:function(e,t,n,r){var a=this.ep(e,n);return a?a.ri(t,n,r):""},rs:function(e,t,n){var r=e[e.length-1];if(c(r))for(var a=0;a<r.length;a++)e.push(r[a]),n(e,t,this),e.pop();else n(e,t,this)},s:function(e,t,n,r,a,o,s){var i;return(!c(e)||0!==e.length)&&("function"==typeof e&&(e=this.ms(e,t,n,r,a,o,s)),i=!!e,!r&&i&&t&&t.push("object"==typeof e?e:t[t.length-1]),i)},d:function(e,n,r,a){var o,s=e.split("."),i=this.f(s[0],n,r,a),l=this.options.modelGet,h=null;if("."===e&&c(n[n.length-2]))i=n[n.length-1];else for(var u=1;u<s.length;u++)void 0!==(o=t(s[u],i,l))?(h=i,i=o):i="";return!(a&&!i)&&(a||"function"!=typeof i||(n.push(h),i=this.mv(i,n,r),n.pop()),i)},f:function(e,n,r,a){for(var o=!1,s=!1,i=this.options.modelGet,l=n.length-1;l>=0;l--)if(void 0!==(o=t(e,n[l],i))){s=!0;break}return s?(a||"function"!=typeof o||(o=this.mv(o,n,r)),o):!a&&""},ls:function(e,t,n,r,a){var o=this.options.delimiters;return this.options.delimiters=a,this.b(this.ct(l(e.call(t,r)),t,n)),this.options.delimiters=o,!1},ct:function(e,t,n){if(this.options.disableLambda)throw new Error("Lambda features disabled.");return this.c.compile(e,this.options).render(t,n)},b:function(e){this.buf+=e},fl:function(){var e=this.buf;return this.buf="",e},ms:function(e,t,n,r,a,o,s){var i,l=t[t.length-1],c=e.call(l);return"function"==typeof c?!!r||(i=this.activeSub&&this.subsText&&this.subsText[this.activeSub]?this.subsText[this.activeSub]:this.text,this.ls(c,l,n,i.substring(a,o),s)):c},mv:function(e,t,n){var r=t[t.length-1],a=e.call(r);return"function"==typeof a?this.ct(l(a.call(r)),r,n):a},sub:function(e,t,n,r){var a=this.subs[e];a&&(this.activeSub=e,a(t,n,this,r),this.activeSub=!1)}};var n=/&/g,r=/</g,a=/>/g,o=/\'/g,s=/\"/g,i=/[&<>\"\']/;function l(e){return String(null==e?"":e)}var c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}}(t)},9606:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n, r);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, rayType);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n, r);\n}\n\nvec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    return render({{name}}, v, rayType);\n}",r);return e.render.apply(e,arguments)}},9909:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);"),r.b("\n"+n),r.b("    //return vec4(debugColor,1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);\n    //return vec4(debugColor,1);\n}",r);return e.render.apply(e,arguments)}},8906:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},1998:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,220,289,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,481,540,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},699:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,405,478,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,580,881,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,764,845,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1119,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1289,1570,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1464,1535,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},4261:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,210,275,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,463,518,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},8474:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},5506:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,171,240,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,432,491,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},7397:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,356,429,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,531,832,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,715,796,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1070,1133,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1240,1521,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1415,1486,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},3045:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,161,226,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,414,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},6077:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    return normalMaterialRender(v, normal);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    return normalMaterialRender(v, normal);\n}",r);return e.render.apply(e,arguments)}},1202:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n,r);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n,r);\n}",r);return e.render.apply(e,arguments)}},2330:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v).rgb;\n}",r);return e.render.apply(e,arguments)}},9040:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, normal).rgb;\n}",r);return e.render.apply(e,arguments)}},588:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;   "),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;   \n    }\n    return {{material.name}}_render(v, normal, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},1365:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("      return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n      return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},8149:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,204,519,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongMaterial material = {{name}};\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},3838:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,261,587,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},472:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,269,595,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},7660:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,282,608,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},8204:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,275,601,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},5377:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.b("        color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    color0 = {{mat0.name}}_render(v);\n\n    if(v.vector.cellBoost == material.cellBoost){\n        color1 = {{mat1.name}}_render(v);\n    } else{\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},9441:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,156,212,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,405,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else {"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionLocalWrapMaterial material = {{name}};\n    vec4 color0, color1;\n    {{#mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v, normal);\n        {{/mat1.usesNormal}}\n        {{^mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v);\n        {{/mat1.usesNormal}}\n    } else {\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},9245:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,296,355,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,429,658,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,567,634,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,834,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,1017,1274,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1171,1246,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            {{^mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal);\n            {{/mat1.usesUVMap}}\n            {{#mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal, uv);\n            {{/mat1.usesUVMap}}\n        {{/mat1.usesNormal}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},6766:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,147,198,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,386,445,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},8402:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    TransitionWrapMaterial material = {{name}};\n\n    vec4 color0 = {{mat0.name}}_render(v);\n    vec4 color1 = {{mat1.name}}_render(v);\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},6158:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,127,188,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,332,393,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    {{#mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v, normal);\n    {{/mat1.usesNormal}}\n    {{^mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v);\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},4146:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,271,335,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,409,648,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,552,624,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,829,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,967,1206,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1110,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n    \n    {{#mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},2332:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,117,173,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,312,368,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    {{#mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v, uv);\n    {{/mat1.usesUVMap}}\n    {{^mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v);\n    {{/mat1.usesUVMap}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},6142:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return negate("),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v));"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the complement of a shape\n */\nRelVector {{name}}_gradient(RelVector v){\n    return negate({{shape.name}}_gradient(v));\n}",r);return e.render.apply(e,arguments)}},7939:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    return - "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the complement of a shape\n */\nfloat {{name}}_sdf(RelVector v){\n    return - {{shape.name}}_sdf(v);\n}",r);return e.render.apply(e,arguments)}},7260:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},6861:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMaxPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMaxPoly(dist1, dist2, grad1, grad2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},3335:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the intersection of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6428:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMaxPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMaxPoly(dist1, dist2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},2076:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return max(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the intersection of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return max(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},2905:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},8655:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMinPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMinPoly(dist1, dist2, grad1, grad2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},7762:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},3238:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMinPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMinPoly(dist1, dist2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},3908:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return min(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return min(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},7500:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6242:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for a wrapping\n */\nRelVector {{name}}_gradient(RelVector v){\n    return {{shape.name}}_gradient(v);\n}",r);return e.render.apply(e,arguments)}},3105:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float wrap = "),r.b(r.v(r.d("wrap.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(wrap > camera.threshold){"),r.b("\n"+n),r.b("        return wrap;"),r.b("\n"+n),r.b("    } else {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for a wrapping\n */\nfloat {{name}}_sdf(RelVector v){\n    float wrap = {{wrap.name}}_sdf(v);\n    if(wrap > camera.threshold){\n        return wrap;\n    } else {\n        return {{shape.name}}_sdf(v);\n    }\n}",r);return e.render.apply(e,arguments)}},9338:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},7577:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("bool "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(RelVector v, int i, out RelVector dir, out float intensity) {"),r.b("\n"+n),r.b("    return directions("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, i, dir, intensity);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"bool {{name}}_directions(RelVector v, int i, out RelVector dir, out float intensity) {\n    return directions({{name}}, v, i, dir, intensity);\n}",r);return e.render.apply(e,arguments)}},8778:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return render({{name}}, v);\n}\n",r);return e.render.apply(e,arguments)}},1215:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, uv);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    return render({{name}}, v, uv);\n}\n",r);return e.render.apply(e,arguments)}},2044:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1403,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1386,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representation of v can be updated"),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2169,2585,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2232,2533,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3143,3524,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3165,3506,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representation of v can be updated\n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},7781:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec4 color;"),r.b("\n"+n),r.b("    vec4 reflectivity;"),r.b("\n"+n),r.b("    float opacity;"),r.b("\n"+n),r.b("    float t;"),r.b("\n"),r.b("\n"+n),r.b("    switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,315,5918,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,0,373,2190,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,589,724,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,822,1314,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,1071,1278,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("            if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                opacity = 1.;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else {"),r.b("\n"+n),r.b("                opacity = color.a;"),r.b("\n"+n),r.b("            }"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,1525,1604,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                //color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("            if(opacity == 1.) {"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else{"),r.b("\n"+n),r.b("                v.data.stop = false;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;"),r.b("\n"+n),r.b("            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;"),r.b("\n"+n),r.b("            "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack = false;"),r.b("\n"+n),r.b("            v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("            v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("            //v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,1,0,0,"")||(r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,0,2294,4409,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("                if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                    reflectivity = vec4(0);"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else {"),r.b("\n"+n),r.b("                    reflectivity = vec4("),r.b(r.v(r.d("material.name",e,t,0))),r.b(".reflectivity,1);"),r.b("\n"+n),r.b("                }"),r.b("\n"),r.b("\n"+n),r.b("                normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                // in general the gradient is not necessarily a unit vector"),r.b("\n"+n),r.b("                normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,2944,3091,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,3197,3593,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,3398,3553,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,3649,3734,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                if(length(reflectivity) == 0.) {"),r.b("\n"+n),r.b("                    v.data.stop = true;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else{"),r.b("\n"+n),r.b("                    v.data.stop = false;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;"),r.b("\n"+n),r.b("                v.vector = geomReflect(v.vector,normal);"),r.b("\n"+n),r.b("                v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("                v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("                v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,4710,4857,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,4963,5495,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,5232,5455,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,5551,5636,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n)),r.b("\n"+n)),r.b("        break;"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec4 color = "),r.b(r.v(r.d("scene.background.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));\n}\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    vec2 uv;\n    vec4 color;\n    vec4 reflectivity;\n    float opacity;\n    float t;\n\n    switch(objId){\n    {{#scene.solids}}\n\n        case {{id}}:\n        {{#material.isTransparent}}\n\n            {{^material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color =  {{material.name}}_render(v);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            {{#material.usesNormal}}\n                {{^material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    color = {{material.name}}_render(v, normal);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, normal, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            if(v.data.iBounce == maxBounces){\n                opacity = 1.;\n            }\n            else {\n                opacity = color.a;\n            }\n\n            {{#scene.fog}}\n                //color = applyFog(color, v.data.lastBounceDist);\n            {{/scene.fog}}\n\n            if(opacity == 1.) {\n                v.data.stop = true;\n            }\n            else{\n                v.data.stop = false;\n            }\n            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;\n            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;\n            {{name}}_isRenderedHack = false;\n            v.data.lastBounceDist = 0.;\n            v.data.iBounce = v.data.iBounce + 1;\n            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n            //v = flow(v, t);\n\n        {{/material.isTransparent}}\n\n        {{^material.isTransparent}}\n\n            {{#material.isReflecting}}\n\n                if(v.data.iBounce == maxBounces){\n                    reflectivity = vec4(0);\n                }\n                else {\n                    reflectivity = vec4({{material.name}}.reflectivity,1);\n                }\n\n                normal = {{shape.name}}_gradient(v.vector);\n                // in general the gradient is not necessarily a unit vector\n                normal = geomNormalize(normal);\n\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                if(length(reflectivity) == 0.) {\n                    v.data.stop = true;\n                }\n                else{\n                    v.data.stop = false;\n                }\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;\n                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;\n                v.vector = geomReflect(v.vector,normal);\n                v.data.lastBounceDist = 0.;\n                v.data.iBounce = v.data.iBounce + 1;\n                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n                v = flow(v, t);\n\n            {{/material.isReflecting}}\n\n            {{^material.isReflecting}}\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n                v.data.leftToComputeColor = vec4(0);\n                v.data.stop = true;\n            {{/material.isReflecting}}\n\n        {{/material.isTransparent}}\n        break;\n\n    {{/scene.solids}}\n    }\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec4 color = {{scene.background.name}}_render(v);\n        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},4122:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * We assume that we are inside a solid"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("void nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    ior = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.ior; // index of the "air"'),r.b("\n"+n),r.b("    absorb = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.absorb; // absorb of the "air"'),r.b("\n"+n),r.b("    emission=vec3(0,0,0);//no emission from 'air'"),r.b("\n"+n),r.b("    opticalDepth="),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.opticalDepth; // opticalDepth of the "air"'),r.b("\n"+n),r.b("    isInside = false;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    RelVector v = flow(normal, 2. * camera.threshold);"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,579,1010,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("            dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("            if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                ior = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("                absorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("                emission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("                opticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("                isInside = true;"),r.b("\n"+n),r.b("                return;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("}"),r.fl()},partials:{},subs:{}},'/**\n * We assume that we are inside a solid\n */\nvoid nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){\n    float dist;\n    ior = {{scene.ptBackground.name}}.ior; // index of the "air"\n    absorb = {{scene.ptBackground.name}}.absorb; // absorb of the "air"\n    emission=vec3(0,0,0);//no emission from \'air\'\n    opticalDepth={{scene.ptBackground.name}}.opticalDepth; // opticalDepth of the "air"\n    isInside = false;\n    \n    RelVector v = flow(normal, 2. * camera.threshold);\n    {{#scene.solids}}\n        if({{name}}.isRendered){\n            dist = {{shape.name}}_sdf(v);\n            if(dist < camera.threshold) {\n                ior = {{ptMaterial.name}}.ior;\n                absorb = {{ptMaterial.name}}.absorb;\n                emission = {{ptMaterial.name}}.volumeEmission;\n                opticalDepth = {{ptMaterial.name}}.opticalDepth;\n                isInside = true;\n                return;\n            }\n        }\n    {{/scene.solids}}\n}',r);return e.render.apply(e,arguments)}},6172:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1381,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1364,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representatiion of v can be updated "),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2149,2565,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2212,2513,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3123,3482,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3145,3464,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representatiion of v can be updated \n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},6272:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".absorb, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".volumeEmission, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".opticalDepth, false);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void roulette(inout ExtVector v){"),r.b("\n"+n),r.b("    // as the light left gets smaller, the ray is more likely to get terminated early."),r.b("\n"+n),r.b("    // survivors have their value boosted to make up for fewer samples being in the average."),r.b("\n"+n),r.b("    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));"),r.b("\n"+n),r.b("    if (randomFloat() > p){"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    // add the energy we 'lose' by randomly terminating paths"),r.b("\n"+n),r.b("    v.data.light = v.data.light / p;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    RayType rayType;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec3 color;"),r.b("\n"+n),r.b("    vec3 reflectivity;"),r.b("\n"+n),r.b("    float hackCoeff = 1.;"),r.b("\n"+n),r.b("    float r; /** ratio of IOR */"),r.b("\n"+n),r.b("    float nextIOR; /** IOR of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextAbsorb; /** absorb of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextEmission;/** volumetric emission of the neighbor solid */"),r.b("\n"+n),r.b("    float nextOpticalDepth;/** optical depth of the neighbor solid */"),r.b("\n"+n),r.b("    bool nextIsInside = true;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector diffuseDir;"),r.b("\n"+n),r.b("    RelVector reflectDir;"),r.b("\n"+n),r.b("    RelVector refractDir;"),r.b("\n"),r.b("\n"+n),r.b("    // get a uniformly distributed vector on the sphere"),r.b("\n"+n),r.b("    RelVector random = randomVector(v.vector);"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("    //get volumetric coloring:"),r.b("\n"+n),r.b("    //portion of light is absorbed."),r.b("\n"+n),r.b("    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    //light is emitted along the journey (linear or expoenential pickup)"),r.b("\n"+n),r.b("    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;"),r.b("\n"+n),r.b("    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);"),r.b("\n"),r.b("\n"+n),r.b("    //use these quantities to update pixel and light:"),r.b("\n"+n),r.b("    v.data.light = v.data.light * volAbsorb;"),r.b("\n"+n),r.b("    v.data.pixel = v.data.pixel + v.data.light*volEmit;"),r.b("\n"+n),r.b("    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output"),r.b("\n"+n),r.b("    "),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,2036,5260,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("    "),r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.b("            normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("            normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.b("            "),r.b("\n"+n),r.b("            // get info and reset normal based on which side we are on."),r.b("\n"+n),r.b('            // starting assumption: in the "air"'),r.b("\n"+n),r.b("            r = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".ior / "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("            nextAbsorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("            nextEmission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("            nextOpticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(v.data.isInside){"),r.b("\n"+n),r.b("                //things to change if we are inside a material instead:"),r.b("\n"+n),r.b("                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);"),r.b("\n"+n),r.b("                r = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior / nextIOR;"),r.b("\n"+n),r.b("                normal = negate(normal);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            rayType = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_setRayType(v, normal,r);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color =  "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, rayType);"),r.b("\n"+n)),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,0,3160,3302,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                color = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, uv, rayType);"),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("        // hack to make sure that lights are not too bright"),r.b("\n"+n),r.b("            if(v.data.iBounce == 0){"),r.b("\n"+n),r.b("                hackCoeff = 0.2;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            //apply surface effects"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".emission;"),r.b("\n"+n),r.b("            if(!rayType.refract){"),r.b("\n"+n),r.b("                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);"),r.b("\n"+n),r.b("             }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            // update the ray direction"),r.b("\n"+n),r.b("            // diffuse uses a normal oriented cosine weighted hemisphere sample."),r.b("\n"+n),r.b("            diffuseDir = geomNormalize(add(normal, random));"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.diffuse){"),r.b("\n"+n),r.b("                v.vector = diffuseDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.reflect){"),r.b("\n"+n),r.b("                // perfectly smooth specular uses the reflection ray."),r.b("\n"+n),r.b("                reflectDir = geomReflect(v.vector, normal);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                v.vector = reflectDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.refract){"),r.b("\n"+n),r.b("                    refractDir = geomRefract(v.vector,normal, r);"),r.b("\n"+n),r.b("                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                    v.data.isInside = nextIsInside;"),r.b("\n"+n),r.b("                    v.data.currentAbsorb = nextAbsorb;"),r.b("\n"+n),r.b("                    v.data.currentEmission = nextEmission;"),r.b("\n"+n),r.b("                    v.data.currentOpticalDepth = nextOpticalDepth;"),r.b("\n"+n),r.b("                    v.vector = refractDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("    v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("    // be carefull, v is not normal to the surface"),r.b("\n"+n),r.b("    // if the time we flow is too small, we are still below the camera threshold"),r.b("\n"+n),r.b("    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("    v = flow(v, t);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor.rgb;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec3 bgColor = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".diffuse;"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.light * bgColor;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        roulette(v);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), {{scene.ptBackground.name}}.absorb, {{scene.ptBackground.name}}.volumeEmission, {{scene.ptBackground.name}}.opticalDepth, false);\n}\n\n\n\nvoid roulette(inout ExtVector v){\n    // as the light left gets smaller, the ray is more likely to get terminated early.\n    // survivors have their value boosted to make up for fewer samples being in the average.\n    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));\n    if (randomFloat() > p){\n        v.data.stop = true;\n    }\n    // add the energy we 'lose' by randomly terminating paths\n    v.data.light = v.data.light / p;\n}\n\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    RayType rayType;\n    vec2 uv;\n    vec3 color;\n    vec3 reflectivity;\n    float hackCoeff = 1.;\n    float r; /** ratio of IOR */\n    float nextIOR; /** IOR of the neighbor solid */\n    vec3 nextAbsorb; /** absorb of the neighbor solid */\n    vec3 nextEmission;/** volumetric emission of the neighbor solid */\n    float nextOpticalDepth;/** optical depth of the neighbor solid */\n    bool nextIsInside = true;\n\n    RelVector diffuseDir;\n    RelVector reflectDir;\n    RelVector refractDir;\n\n    // get a uniformly distributed vector on the sphere\n    RelVector random = randomVector(v.vector);\n\n\n\n\n\n    //get volumetric coloring:\n    //portion of light is absorbed.\n    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);\n    \n    //light is emitted along the journey (linear or expoenential pickup)\n    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;\n    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);\n\n    //use these quantities to update pixel and light:\n    v.data.light = v.data.light * volAbsorb;\n    v.data.pixel = v.data.pixel + v.data.light*volEmit;\n    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output\n    \n\n\n\n\n\n\nswitch(objId){\n    {{#scene.solids}}\n    \n        case {{id}}:\n            normal = {{shape.name}}_gradient(v.vector);\n            normal = geomNormalize(normal);\n\n            \n            // get info and reset normal based on which side we are on.\n            // starting assumption: in the \"air\"\n            r = {{scene.ptBackground.name}}.ior / {{ptMaterial.name}}.ior;\n            nextAbsorb = {{ptMaterial.name}}.absorb;\n            nextEmission = {{ptMaterial.name}}.volumeEmission;\n            nextOpticalDepth = {{ptMaterial.name}}.opticalDepth;\n        \n            if(v.data.isInside){\n                //things to change if we are inside a material instead:\n                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);\n                r = {{ptMaterial.name}}.ior / nextIOR;\n                normal = negate(normal);\n            }\n        \n            rayType = {{ptMaterial.name}}_setRayType(v, normal,r);\n        \n            {{^ptMaterial.usesUVMap}}\n                color =  {{ptMaterial.name}}_render(v, normal, rayType);\n            {{/ptMaterial.usesUVMap}}\n            {{#ptMaterial.usesUVMap}}\n                uv = {{shape.name}}_uvMap(v.vector);\n                color = {{ptMaterial.name}}_render(v, normal, uv, rayType);\n            {{/ptMaterial.usesUVMap}}\n        \n        \n        // hack to make sure that lights are not too bright\n            if(v.data.iBounce == 0){\n                hackCoeff = 0.2;\n            }\n        \n            //apply surface effects\n            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * {{ptMaterial.name}}.emission;\n            if(!rayType.refract){\n                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);\n             }\n        \n            // update the ray direction\n            // diffuse uses a normal oriented cosine weighted hemisphere sample.\n            diffuseDir = geomNormalize(add(normal, random));\n        \n            if(rayType.diffuse){\n                v.vector = diffuseDir;\n            }\n        \n            if(rayType.reflect){\n                // perfectly smooth specular uses the reflection ray.\n                reflectDir = geomReflect(v.vector, normal);\n        \n                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                v.vector = reflectDir;\n            }\n        \n            if(rayType.refract){\n                    refractDir = geomRefract(v.vector,normal, r);\n                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                    v.data.isInside = nextIsInside;\n                    v.data.currentAbsorb = nextAbsorb;\n                    v.data.currentEmission = nextEmission;\n                    v.data.currentOpticalDepth = nextOpticalDepth;\n                    v.vector = refractDir;\n            }\n            break;\n    \n    {{/scene.solids}}\n    }\n\n    v.data.lastBounceDist = 0.;\n    v.data.iBounce = v.data.iBounce + 1;\n    // be carefull, v is not normal to the surface\n    // if the time we flow is too small, we are still below the camera threshold\n    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n    v = flow(v, t);\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor.rgb;\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec3 bgColor = {{scene.ptBackground.name}}.diffuse;\n        v.data.pixel = v.data.pixel + v.data.light * bgColor;\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        roulette(v);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},8266:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float newEp = 0.001;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));"),r.b("\n"+n),r.b("    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));"),r.b("\n"),r.b("\n"+n),r.b("    float vgx = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPX) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMX);"),r.b("\n"+n),r.b("    float vgy = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPY) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMY);"),r.b("\n"+n),r.b("    float vgz = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPZ) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMZ);"),r.b("\n"+n),r.b("    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));"),r.b("\n"),r.b("\n"+n),r.b("    n = geomNormalize(n);"),r.b("\n"+n),r.b("    return n;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    float newEp = 0.001;\n\n    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));\n    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));\n    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));\n    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));\n    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));\n    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));\n\n    float vgx = {{name}}_sdf(shiftPX) - {{name}}_sdf(shiftMX);\n    float vgy = {{name}}_sdf(shiftPY) - {{name}}_sdf(shiftMY);\n    float vgz = {{name}}_sdf(shiftPZ) - {{name}}_sdf(shiftMZ);\n    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));\n\n    n = geomNormalize(n);\n    return n;\n}",r);return e.render.apply(e,arguments)}},3707:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v) {"),r.b("\n"+n),r.b("    return sdf("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"float {{name}}_sdf(RelVector v) {\n    return sdf({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},4355:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return uvMap("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return uvMap({{name}}, v);\n}",r);return e.render.apply(e,arguments)}},3148:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Default creeping function (binary search)"),r.b("\n"+n),r.b(" * @param start starting point of the creeping"),r.b("\n"+n),r.b(" * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)"),r.b("\n"+n),r.b(" * @param offset how long we flow after passing the boundary"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(ExtVector v, ExtVector outside,  float offset){"),r.b("\n"+n),r.b("    ExtVector try = outside;"),r.b("\n"+n),r.b("    float sIn = 0.;"),r.b("\n"+n),r.b("    float sOut = try.data.lastFlowDist;"),r.b("\n"+n),r.b("    float s;"),r.b("\n"+n),r.b("    for(int i=0; i < 100; i++){"),r.b("\n"+n),r.b("        if(sOut - sIn < offset){"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("        s = 0.5 * sIn + 0.5 * sOut;"),r.b("\n"+n),r.b("        try = flow(v,s);"),r.b("\n"+n),r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("            sOut = s;"),r.b("\n"+n),r.b("            outside = try;"),r.b("\n"+n),r.b("        } else {"),r.b("\n"+n),r.b("            sIn = s;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return sOut;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Default creeping function (binary search)\n * @param start starting point of the creeping\n * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)\n * @param offset how long we flow after passing the boundary\n */\nfloat {{glslCreepName}}(ExtVector v, ExtVector outside,  float offset){\n    ExtVector try = outside;\n    float sIn = 0.;\n    float sOut = try.data.lastFlowDist;\n    float s;\n    for(int i=0; i < 100; i++){\n        if(sOut - sIn < offset){\n            break;\n        }\n        s = 0.5 * sIn + 0.5 * sOut;\n        try = flow(v,s);\n        if({{glslTestName}}(try.vector.local.pos)){\n            sOut = s;\n            outside = try;\n        } else {\n            sIn = s;\n        }\n    }\n    return sOut;\n}",r);return e.render.apply(e,arguments)}},5103:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* Teleportation."),r.b("\n"+n),r.b("* Check if the local vector is still in the fundamental domain define by the teleportation tests."),r.b("\n"+n),r.b("* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true"),r.b("\n"+n),r.b("* Otherwise, do nothing and set teleported to false"),r.b("\n"+n),r.b("* @param[in] v the relative vector to teleport."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("ExtVector teleport(ExtVector v){"),r.b("\n"+n),r.b("    v.data.isTeleported = false;"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,424,621,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(v.vector.local.pos)){"),r.b("\n"+n),r.b("            v.vector = rewrite(v.vector, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("            v.data.isTeleported = true;"),r.b("\n"+n),r.b("            return v;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    return v;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Does one of the two following transformation:"),r.b("\n"+n),r.b("* flow the vector by the given time, if the vector escape the fundamental domain,"),r.b("\n"+n),r.b("* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain"),r.b("\n"+n),r.b("* (and even a bit further)"),r.b("\n"+n),r.b("*"),r.b("\n"+n),r.b("* @param[inout] v the relative vector to flow / teleport / creep."),r.b("\n"+n),r.b("* @param[in] t the (maximal) time to flow"),r.b("\n"+n),r.b("* @param[in] offset the amount we march passed the boundary"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float creepingDist(ExtVector v, float t, float offset){"),r.b("\n"+n),r.b("    float res = t;"),r.b("\n"+n),r.b("    ExtVector try = flow(v, t);"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,1233,1638,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.f("usesCreepingCustom",e,t,1),e,t,0,1266,1407,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.f("usesCreepingBinary",e,t,1),e,t,0,1463,1609,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, try, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n)})),e.pop()),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"/**\n* Teleportation.\n* Check if the local vector is still in the fundamental domain define by the teleportation tests.\n* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true\n* Otherwise, do nothing and set teleported to false\n* @param[in] v the relative vector to teleport.\n*/\nExtVector teleport(ExtVector v){\n    v.data.isTeleported = false;\n    {{#teleportations}}\n        if({{glslTestName}}(v.vector.local.pos)){\n            v.vector = rewrite(v.vector, {{elt.name}}, {{inv.name}});\n            v.data.isTeleported = true;\n            return v;\n        }\n    {{/teleportations}}\n    return v;\n}\n\n\n/**\n* Does one of the two following transformation:\n* flow the vector by the given time, if the vector escape the fundamental domain,\n* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain\n* (and even a bit further)\n*\n* @param[inout] v the relative vector to flow / teleport / creep.\n* @param[in] t the (maximal) time to flow\n* @param[in] offset the amount we march passed the boundary\n*/\nfloat creepingDist(ExtVector v, float t, float offset){\n    float res = t;\n    ExtVector try = flow(v, t);\n    {{#teleportations}}\n\n        {{#usesCreepingCustom}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, offset));\n            }\n        {{/usesCreepingCustom}}\n\n        {{#usesCreepingBinary}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, try, offset));\n            }\n        {{/usesCreepingBinary}}\n\n    {{/teleportations}}\n    return res;\n}\n\n\n",r);return e.render.apply(e,arguments)}},6097:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                                    \n                                                                                                                        \n\nstruct GroupElement {\n    Isometry isom;                                 \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(IDENTITY);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(multiply(elt1.isom, elt2.isom));\n}\n\n                                              \n                                                 \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return elt.isom;\n}"},9188:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                               \n                                                                                                                        \n\nstruct GroupElement {\n    bool fake;                                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(true);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(true);\n}\n\n                                              \n                                \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return IDENTITY;\n}"},5363:e=>{e.exports="   \n                                                                \n   \nfloat fresnelReflectAmount(RelVector incident, RelVector normal, float r, float reflecAt0, float relfectAt90) {\n                           \n    float r0 = (r - 1.) / (r + 1.);\n    r0 = r0 * r0;\n    float cosX = -geomDot(normal, incident);\n    if (r > 1.)\n    {\n        float sinT2 = r * r * (1. - cosX * cosX);\n                                    \n        if (sinT2 > 1.){\n            return relfectAt90;\n        }\n        cosX = sqrt(1. - sinT2);\n    }\n    float x = 1.- cosX;\n    float ret = clamp(r0 + (1. - r0) * x * x * x * x * x, 0., 1.);\n\n                                                        \n                               \n    return reflecAt0 + (relfectAt90 - reflecAt0) * ret;\n}"},2093:e=>{e.exports="   \n                                  \n   \nfloat smoothMaxPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return max(a, b) + 0.25 * k * h * h;\n}\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMaxPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n    return add(multiplyScalar(1. - 0.5 * h, gradMax), multiplyScalar(0.5 * h, gradMin));\n}\n"},5442:e=>{e.exports="float smoothMinPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return min(a, b) - 0.25 * k * h * h;\n}\n\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMinPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n\n    return add(multiplyScalar(1. - 0.5 * h, gradMin), multiplyScalar(0.5 * h, gradMax));\n}\n"},2143:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct BasicPTMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(BasicPTMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n                                                         \n                                  \n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\nvec3 render(BasicPTMaterial material, ExtVector v, RayType rayType) {\n    if (rayType.reflect){\n        return material.specular;\n    }\n                               \n                                              \n                                         \n       \n    return material.diffuse;\n}\n\n"},2197:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct CheckerboardMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\nvec4 render(CheckerboardMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    if (x1 < 1. && x2 < 1.){\n        return vec4(material.color1, 1);\n    } else if (x1 >= 1. && x2 >= 1.) {\n        return vec4(material.color1, 1);\n    } else {\n        return vec4(material.color2, 1);\n    }\n}\n\n"},7793:e=>{e.exports="\n                                                                                                                        \n                       \n                                                                                                                        \n"},4743:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct EquidistantHypStripsMaterial {\n    float distance;\n    float width;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(EquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float distP = atanh(uv.x);\n    float k = round(distP / material.distance);\n    vec2 q = horizontalTranslate(uv, -k * material.distance);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1917:e=>{e.exports="                                                                                                                        \n                                                  \n                                                                                                                        \n\nstruct EquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n\nvec4 render(EquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n    float theta = uv.x;\n    float phi = uv.y;\n    theta = theta - round(theta / material.distance) * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n                                                                                            \n    if (cosDistSq > material.cosHalfWidthSq) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},3801:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct GraphPaperMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\n\nfloat gridLines(vec2 uv, float size){\n    float brightness = 1./(2.*sqrt(size));\n    float gridPattern = abs(sin(3.14*size*uv.x)*sin(1.*3.14*size*uv.y));\n                                   \n    gridPattern = 1.-clamp(pow(gridPattern,0.05),0.,1.);\n    return gridPattern*brightness;\n}\n\nfloat grid(vec2 uv){\n    float grid1 = gridLines(uv,1.);\n    float grid2 = gridLines(uv,5.);\n    float grid3 = gridLines(uv,10.);\n    float grid4 = gridLines(uv,50.);\n    float gridTotal = grid1+grid2+grid3+grid4;\n    gridTotal *=5.;\n   return gridTotal;\n}\n\nvec4 render(GraphPaperMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    float gridPattern = grid(vec2(x1,x2));\n\n    vec3 col1 = material.color1*(1.-gridPattern);\n    vec3 col2 = material.color2*gridPattern;\n    return vec4(col1+col2,1.);\n\n}\n\n"},2278:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightLocalWrapMaterial {\n    GroupElement cellBoost;\n    bool isHighlightOn;\n};\n"},3048:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightWrapMaterial {\n    bool isHighlightOn;\n};\n"},7685:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct HypStripsMaterial {\n    float totalWidth;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n};\n\nvec4 render(HypStripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float aux = clamp(uv.x, -1., 1.);\n    float dist = atanh(aux);\n    float x = mod(dist / material.totalWidth, 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}"},4566:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantHypStripsMaterial {\n    float distance;\n    float halfWidth;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(ImprovedEquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float t = atanh(uv.x) - material.distance;\n    vec2 m = horizontalTranslate(uv, -t);\n    float distM = abs(distToYAxis(m));\n    float n = floor(log(distM / material.distance) / log(2.));\n\n    float distP = atanh(uv.x);\n    float period = pow(2., -n) * material.distance;\n    float k = round(distP / period);\n    vec2 q = horizontalTranslate(uv, -k * period);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1650:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    float fadingAmplitude;\n    vec3 stripColor;\n    vec3 bgColor;\n    mat4 rotation;\n};\n\nvec4 render(ImprovedEquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n                         \n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n\n\n                                                                                              \n    float ln2 = 0.6931471;                               \n\n    float theta = rotatedUV.x;\n    float phi = rotatedUV.y;\n    float k = round(theta / material.distance);\n    theta = theta - k * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n\n                                                                                            \n    if (cosDistSq < material.cosHalfWidthSq) {\n                                                               \n        return vec4(material.bgColor, 1);\n    }\n    if (k == 0.) {\n        return vec4(material.stripColor, 1);\n    }\n\n                                                                        \n                                                                             \n    int kInt = int(k);\n    int nInt = kInt & (~kInt + 1);\n    float n = float(nInt);\n                                \n                                                                                        \n    float theta0 = material.distance;\n    float theta1 = n * theta0;\n\n                                                    \n                                   \n                                                  \n           \n\n    float c = 0.66;\n    float sinPh1 = sin(c * theta0) / sin(theta1);\n    float phi1 = asin(clamp(sinPh1, 0., 1.));\n\n    float coeff = ((0.5 * PI - phi1) - abs(0.5 * PI - phi)) / material.fadingAmplitude + 0.5;\n    coeff = clamp(coeff, 0., 1.);\n    vec3 base = coeff * material.stripColor + (1. - coeff) * material.bgColor;\n    return vec4(base, 1);\n\n                         \n                                                                                       \n                                                                           \n                                       \n                                                        \n      \n                                                        \n}"},3496:e=>{e.exports="                                                                                                                        \n                  \n                                            \n                                                     \n                                                                                                                        \n\nvec4 normalMaterialRender(ExtVector v, RelVector normal) {\n    Vector[3] f;\n    Point pos = applyGroupElement(v.vector.cellBoost, v.vector.local.pos);\n    frame(pos, f);\n\n    f[0] = applyGroupElement(v.vector.invCellBoost, f[0]);\n    f[1] = applyGroupElement(v.vector.invCellBoost, f[1]);\n    f[2] = applyGroupElement(v.vector.invCellBoost, f[2]);\n    \n                  \n                            \n    float r =  geomDot(normal.local, f[0]);\n    float g =  geomDot(normal.local, f[1]);\n    float b =  geomDot(normal.local, f[2]);\n    return abs(vec4(r, g, b, 1));\n}"},7198:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct PathTracerWrapMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(PathTracerWrapMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\n"},6045:e=>{e.exports="                                                                                                                        \n                 \n                                                                                                                        \n\nstruct PhongMaterial {\n    vec3 color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, PhongMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * material.color;\n    vec3 ambient = ambientCoeff * ambientLight * material.color;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},5836:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct PhongWrapMaterial {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, vec3 baseColor, PhongWrapMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * baseColor;\n    vec3 ambient = ambientCoeff * ambientLight * baseColor;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},1220:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct RotatedSphericalTextureMaterial {\n    sampler2D sampler;\n    mat4 rotation;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(RotatedSphericalTextureMaterial material, ExtVector v, vec2 uv) {\n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n    vec2 texCoords = (rotatedUV - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},9095:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SimpleTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(SimpleTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},2664:e=>{e.exports="                                                                                                                        \n                        \n                                                                                                                        \n\nstruct SingleColorMaterial {\n    vec3 color;\n};\n\nvec4 render(SingleColorMaterial material, ExtVector v) {\n    return vec4(material.color, 1);\n}"},3081:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SquaresMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(SquaresMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x1 = mod(dot(uv, material.dir1) / dot(material.dir1, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2) / dot(material.dir2, material.dir2), 2.);\n    float c1 = abs(x1 - 1.);\n    float c2 = abs(x2 - 1.);\n    if (c1 < material.lengths.x && c2 < material.lengths.x){\n        color = material.color0;\n    } else if (c1 < material.lengths.y && c2 < material.lengths.y){\n        color = material.color1;\n    } else if (c1 < material.lengths.z && c2 < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n    return vec4(color, 1);\n}\n\n"},9835:e=>{e.exports="                                                                                                                        \n          \n                  \n                                                                                                                        \nstruct StripsMaterial {\n    vec2 dir;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(StripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x = mod(dot(uv, material.dir) / dot(material.dir, material.dir), 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}\n\n"},1888:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionLocalWrapMaterial {\n    GroupElement cellBoost;\n    float ratio;\n};\n"},5698:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionWrapMaterial {\n    float ratio;\n};\n"},2229:e=>{e.exports="\n\n                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoAlphaTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoAlphaTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    vec2 texCoordsUV = vec2(texCoords.x, 0.5 + 0.5 * texCoords.y);\n    vec2 texCoordsAlpha = vec2(texCoords.x, 0.5 * texCoords.y);\n    vec4 color =  texture(material.sampler, texCoordsUV);\n    float alpha = texture(material.sampler, texCoordsAlpha).x;\n    return vec4(color.rgb, alpha);\n}"},4680:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoFrameTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoFrameTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},533:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},6947:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = exposure * color.rgb;\n    pixelColor = ACESFilm(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},2690:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 postProcess(vec3 pixelColor){\n\n                      \n    pixelColor *= exposure;\n\n                   \n    pixelColor = ACESFilm(pixelColor);\n    pixelColor = LinearToSRGB(pixelColor);\n\n    return pixelColor;\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 aux = postProcess(color.rgb);\n    gl_FragColor = vec4(min(vec3(1.0), aux), color.a);\n}"},4024:e=>{e.exports="uniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = color.rgb;\n    pixelColor = LinearToSRGB(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},5348:e=>{e.exports="vec3 applyFog(vec3 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * fog.color;\n}\n\nvec4 applyFog(vec4 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * vec4(fog.color, 1);\n}"},7885:e=>{e.exports="                                                                                                                        \n  \n          \n                                 \n  \n                                                                                                                        \n\nstruct ExpFog {\n    vec3 color;                             \n    float scattering;                                                    \n};\n"},7333:e=>{e.exports="struct IntersectionShape {\n    float maxCoeff;\n};"},519:e=>{e.exports="struct UnionShape {\n    float minCoeff;\n};\n"},4750:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec3 dir = vec3(coords.xy, -1. / tan(0.5 * camera.fovRadians));\n    Vector v = createVector(ORIGIN, dir);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},8710:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fovRadians;                                          \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},6224:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},6684:e=>{e.exports="   \n                                                                                                 \n                                                                                        \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}\n\n   \n                                                                                             \n                                                               \n   \nRelVector mappingFromFlatScreen(vec2 coords) {\n                                                         \n    vec2 jitter = vec2(randomFloat(), randomFloat()) - 0.5;\n\n                                                                            \n    vec2 planeCoords = (coords - 0.5 * resolution + jitter) / (0.5 * resolution.y);\n\n                              \n    float z = - 1. / tan(radians(0.5 * camera.fov));\n\n                                                      \n    vec4 dir = vec4(planeCoords, z, 0);\n\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},6354:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n    float focalLength;                    \n    float aperture;                \n};"},9222:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}\n\n                     \n\n  \n                               \n                               \n                         \n                                             \n                                                      \n                              \n \n  "},5970:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},5682:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},4770:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}"},8415:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},190:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n\nVector geomMix(Vector v1, Vector v2, float a){\n    return add(multiplyScalar(1.-a, v1), multiplyScalar(a, v2));\n}\n\n   \n                                           \n                         \n             \n   \nVector negate(Vector v) {\n    return multiplyScalar(-1., v);\n}\n\n\n   \n                                         \n                       \n   \nfloat geomLength(Vector v){\n    return sqrt(geomDot(v, v));\n}\n\n   \n                                                          \n                            \n   \nVector geomNormalize(Vector v){\n    float a = geomLength(v);\n    return multiplyScalar(1./a, v);\n}\n\n   \n                                                     \n   \nfloat cosAngle(Vector v1, Vector v2){\n    float a1 = geomLength(v1);\n    float a2 = geomLength(v2);\n    return geomDot(v1, v2)/ (a1 * a2);\n}\n\n   \n                                                           \n                                   \n                                                                                                        \n                                     \n                                                                   \n                                                                       \n   \nVector geomReflect(Vector v, Vector n){\n    return sub(v, multiplyScalar(2. * geomDot(v, n), n));\n}\n\n\n   \n                                         \n                                                                        \n                                                                                   \n                                              \n   \nVector geomRefract(Vector v, Vector n, float r){\n    float cosTheta1 = -geomDot(n, v);\n    float sinTheta2Sq = r * r * (1. - cosTheta1 * cosTheta1);\n\n    if (sinTheta2Sq > 1.){\n               \n        return zeroVector(v.pos);\n    }\n                                                                 \n    float cosTheta2 = sqrt(1. - sinTheta2Sq);\n    float aux = r * cosTheta1 - cosTheta2;\n    return add(multiplyScalar(r, v), multiplyScalar(aux, n));\n}\n\n   \n                                                                          \n                                           \n   \nIsometry makeTranslation(Vector v) {\n    return makeTranslation(v.pos);\n}\n\n   \n                                                                          \n                                              \n   \nIsometry makeInvTranslation(Vector v) {\n    return makeInvTranslation(v.pos);\n}\n"},4168:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                                                                         \n               \n   \nVector createVector(Point p, vec3 coords, Vector[3] frame){\n    Vector c0 = multiplyScalar(coords[0], frame[0]);\n    Vector c1 = multiplyScalar(coords[1], frame[1]);\n    Vector c2 = multiplyScalar(coords[2], frame[2]);\n    return add(c0, add(c1, c2));\n}\n\n\n\n   \n                                                                                          \n               \n   \nVector createVector(Point p, vec3 coords){\n    Vector[3] f;\n    frame(p, f);\n    return createVector(p, coords, f);\n}\n\n   \n                                                                                          \n               \n   \nVector createVectorOrtho(Point p, vec3 coords){\n    Vector[3] f;\n    orthoFrame(p, f);\n    return createVector(p, coords, f);\n}\n\n\n                                                                                                                        \n  \n                   \n                                                             \n                                                                       \n  \n                                                                                                                        \n\nstruct Position {\n    Isometry boost;\n    mat4 facing;\n};\n\n\n   \n                                        \n                          \n                                           \n   \nVector applyPosition(Position p, Vector v){\n    Vector res = applyFacing(p.facing, v);\n    return applyIsometry(p.boost, res);\n}"},2311:e=>{e.exports="   \n              \n                                \n   \nPoint applyIsometry(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\nPoint applyGroupElement(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\n   \n              \n                                \n   \nVector applyIsometry(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\nVector applyGroupElement(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\n\n"},5315:e=>{e.exports="   \n                          \n   \nvarying vec3 screenPosition;\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    RelVector vector = mapping(screenPosition);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = postProcess(getColor(v));\n}"},6159:e=>{e.exports="vec4 postProcess(vec4 color) {\n    return color;\n}"},2977:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n        }\n    }\n\n                               \n                     \n       \n\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + dist;\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    v = flow(v, camera.safetyDist);\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = raymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return v.data.pixel;\n}"},9461:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec4 pixel;                                                                   \n    vec4 leftToComputeColor;                                                                      \n};"},1767:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                             \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n              \n   \nconst float PI = 3.1415926538;\n\n   \n                      \n   \nvec4 debugColor = vec4(0.5, 0, 0.8, 1);\n\n   \n                                    \n         \n   \nconst int HIT_NOTHING = 0;\n   \n                                    \n         \n   \nconst int HIT_SOLID = 1;\n   \n                                  \n         \n   \nconst int HIT_DEBUG = -1;\n"},7962:e=>{e.exports="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"},8187:e=>{e.exports="   \n                          \n   \nvarying vec3 spherePosition;\n\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    initSeed(gl_FragCoord.xy, frameSeed);\n    RelVector vector = mappingFromFlatScreen(gl_FragCoord.xy);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = getColor(v);\n}\n"},9638:e=>{e.exports="   \n                                                \n  \n   \nuint seed;\n\n   \n                                                \n                                                                  \n                                                \n                                                                                                         \n   \nvoid initSeed(vec2 coords, uint frameSeed){\n    uvec2 aux = uvec2(coords);\n    seed =  aux.x * uint(1973) + aux.y * uint(925277) + frameSeed * uint(26699) | uint(1);\n}\n\n   \n                           \n               \n                                                                                                     \n   \nuint wangHash() {\n    seed = (seed ^ uint(61)) ^ (seed >> uint(16));\n    seed = seed * uint(9);\n    seed = seed ^ (seed >> 4);\n    seed = seed * uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n   \n                                                  \n   \nfloat randomFloat() {\n    return float(wangHash()) / 4294967296.;\n}\n\n   \n                                                                           \n                                                                                                    \n                                                                                                       \n                                          \n   \nvec3 randomUnitVec3() {\n    float z = randomFloat() * 2. - 1.;\n    float theta = randomFloat() * 2. * PI;\n    float r = sqrt(1. - z * z);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x, y, z);\n}\n\n   \n                                                   \n                                                      \n   \nVector randomVector(Point p) {\n    vec3 dir = randomUnitVec3();\n    return createVectorOrtho(p, dir);\n}\n\n   \n                                                                     \n                                                                                               \n   \nvec2 randomNormal2D(){\n    float u = randomFloat();\n    float v = randomFloat();\n\n    float r = sqrt(abs(2. * log(u)));\n    float x = r * cos(2. * PI * v);\n    float y = r * sin(2. * PI * v);\n\n    return vec2(x, y);\n\n}\n\n   \n                                                      \n   \nfloat randomNormal(float mean, float stdev){\n\n                           \n    float x = randomNormal2D().x;\n\n                                   \n    return stdev * x + mean;\n}\n"},7920:e=>{e.exports="   \n                                                                                      \n  \n   \n\n\n   \n                                                                                   \n                                                                          \n                                                       \n   \nRelVector randomVector(RelVector v) {\n    v.local = randomVector(v.local.pos);\n    return v;\n}"},3499:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n                                                                  \n                                                                                         \n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + abs(dist);\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nbool doesItScatter(inout float dist, float opticalDepth){\n                          \n    if (opticalDepth>100.){\n        return false;\n    }\n    else {\n        float probScatter=1.-exp(-dist/opticalDepth);\n        float flip=randomFloat();\n        if (flip<probScatter){\n                                           \n                                                \n            dist=dist*randomFloat();\n            return true;\n        }\n                                              \n        return false;\n    }\n}\n\n\nvoid scatterRay(inout ExtVector v){\n                                         \n    RelVector w=randomVector(v.vector);\n\n                                                 \n                                                  \n    v.vector=w;\n                                             \n                                                      \n}\n\n\n\nint scatterRaymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n    float d;\n    bool doScatter;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n\n                                          \n            d=abs(dist);\n            doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                                \n            marchingStep = marchingStep + creepingDist(localV, d, camera.threshold);\n            localV = flow(localV0, marchingStep);\n\n\n                                               \n                                                                              \n\n                                                       \n            if (doScatter){\n                scatterRay(localV);\n            }\n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n\n                                      \n        d=abs(dist);\n        doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                            \n        marchingStep = marchingStep + d;\n        globalV = flow(globalV0, marchingStep);\n\n                                                   \n        if (doScatter){\n            scatterRay(globalV);\n        }\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = scatterRaymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return vec4(v.data.pixel,1);\n}"},3888:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n           \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct RayType{\n    bool diffuse;\n    bool reflect;\n    bool refract;\n    float chance;\n};\n\n                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec3 pixel;         \n    vec3 light;         \n    vec3 currentAbsorb;                                                    \n    vec3 currentEmission;                                                             \n    float currentOpticalDepth;                                                              \n    bool isInside;                                        \n};\n\n"},8351:e=>{e.exports="vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec4 postProcess(vec4 pixelColor) {\n\n                      \n    pixelColor.xyz *= exposure;\n\n                   \n    pixelColor.xyz = ACESFilm(pixelColor.xyz);\n    pixelColor.xyz = LinearToSRGB(pixelColor.xyz);\n\n    return pixelColor;\n}"},7499:e=>{e.exports="                                                                                                                        \n  \n           \n                               \n  \n                                                                                                                        \n \n struct Solid {\n    bool isRendered;\n };\n"},7970:e=>{e.exports="                                                                                                                        \n  \n                      \n                                                        \n                                                                     \n                        \n                                                                                 \n                                                                                 \n                                                                                   \n                                                                                    \n                                                                       \n                                                                                                                        \n\nstruct RelPosition {\n    Position local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n                                                                                                                        \n  \n                    \n                                  \n                                                                       \n                      \n                                                                                 \n                                                                                 \n                                                                            \n                                                                                    \n                                                                                                                        \n\nstruct RelVector {\n    Vector local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n   \n                                                            \n   \nRelVector reduceError(RelVector v){\n    v.local = reduceError(v.local);\n    return v;\n}\n\n   \n                         \n                            \n                                                      \n   \nRelVector add(RelVector v1, RelVector v2){\n    v1.local = add(v1.local, v2.local);\n    return v1;\n}\n\n   \n                              \n                            \n                                                      \n   \nRelVector sub(RelVector v1, RelVector v2){\n    v1.local = sub(v1.local, v2.local);\n    return v1;\n}\n\n   \n                                   \n                         \n                      \n   \nRelVector multiplyScalar(float s, RelVector v){\n    v.local = multiplyScalar(s, v.local);\n    return v;\n}\n\n   \n                                                                                 \n                     \n                                                        \n   \nfloat geomDot(RelVector v1, RelVector v2) {\n    return geomDot(v1.local, v2.local);\n}\n\n   \n                              \n   \nRelVector geomNormalize(RelVector v){\n    v.local = geomNormalize(v.local);\n    return v;\n}\n\n   \n                                   \n                                                        \n   \nRelVector geomMix(RelVector v1, RelVector v2, float a) {\n    v1.local = geomMix(v1.local, v2.local, a);\n    return v1;\n}\n\n   \n                                            \n   \nRelVector negate(RelVector v){\n    v.local = negate(v.local);\n    return v;\n}\n\n   \n                                                                     \n                                                       \n   \nRelVector geomReflect(RelVector v, RelVector normal){\n    v.local = geomReflect(v.local, normal.local);\n    return v;\n}\n\n\n   \n                                                                     \n                                                       \n   \nRelVector geomRefract(RelVector v, RelVector normal, float n){\n    v.local = geomRefract(v.local, normal.local, n);\n    return v;\n}\n\n   \n                         \n                                            \n                                                                         \n   \nRelVector flow(RelVector v, float t) {\n    v.local = flow(v.local, t);\n    return v;\n}\n\n   \n                                                                                          \n                                                                           \n                                                                          \n                               \n                                                                                              \n   \nRelVector smallShift(RelVector v, vec3 dp){\n    v.local = smallShift(v.local, dp);\n    return v;\n                                                 \n                                                               \n}\n\n\n   \n                                                                                                            \n                           \n                                                   \n                                                                                             \n                                            \n   \n                                                   \n                                                   \n               \n                                                             \n                                                                 \n   \n\n   \n                                                                                                            \n                                                   \n                                                                                             \n   \nRelVector createRelVector(RelVector v, vec3 coords){\n    v.local =  createVector(v.local.pos, coords);\n    return v;\n                                                           \n                                                               \n}\n\n   \n                                                                  \n                          \n                                           \n   \nRelVector applyPosition(RelPosition position, Vector v) {\n    Vector local = applyPosition(position.local, v);\n    return RelVector(local, position.cellBoost, position.invCellBoost);\n}\n\n   \n                                                                                                                    \n   \nRelVector rewrite(RelVector v, GroupElement elt, GroupElement inv){\n    v.local = applyGroupElement(elt, v.local);\n                                     \n                                       \n    v.cellBoost = multiply(v.cellBoost, inv);\n    v.invCellBoost = multiply(elt, v.invCellBoost);\n    return v;\n}\n\n\n                                                                                                                        \n  \n                    \n                                    \n                                                                              \n                  \n                                                      \n                                                                                         \n  \n                                                                                                                        \n\nstruct ExtVector {\n    RelVector vector;\n    VectorData data;\n};\n\n\nExtVector flow(ExtVector v, float t) {\n    v.vector = flow(v.vector, t);\n    v.data.lastFlowDist = t;\n    v.data.lastBounceDist = v.data.lastBounceDist + t;\n    v.data.totalDist  = v.data.totalDist + t;\n    return v;\n}\n\n\n\n"},8348:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n  \n          \n                                                                         \n                                                                     \n  \n                                                                                                                        \n\nconst vec4 SL_ORIGIN = vec4(1, 0, 0, 0);\n\n                                                                          \nvec4 SLreduceError(vec4 elt) {\n                                                                                \n    mat4 J = mat4(\n    -1, 0, 0, 0,\n    0, -1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n    );\n    float q = dot(elt, J * elt);\n                            \n    return elt / sqrt(abs(q));\n}\n\n                  \n                                             \nmat2 SLtoMatrix2(vec4 elt) {\n    mat2 ex = mat2(\n    1, 0,\n    0, 1\n    );\n    mat2 ey = mat2(\n    0, -1,\n    1, 0\n    );\n    mat2 ez = mat2(\n    0, 1,\n    1, 0\n    );\n    mat2 ew = mat2(\n    1, 0,\n    0, -1\n    );\n    mat2 res = elt.x * ex + elt.y * ey + elt.z * ez + elt.w * ew;\n                                  \n                                         \n    res = res / sqrt(abs(determinant(res)));\n    return res;\n}\n\n                  \n                                                         \nvec4 SLfromMatrix2(mat2 m) {\n    float a = m[0][0];\n    float b = m[1][0];\n    float c = m[0][1];\n    float d = m[1][1];\n    vec4 res = 0.5 * vec4(a + d, b - c, b + c, a - d);\n    return SLreduceError(res);\n}\n\n                                     \nmat3 SLtoMatrix3(vec4 elt){\n    mat4x3 aux1 = mat4x3(\n    elt.x, elt.y, elt.z,\n    -elt.y, elt.x, elt.w,\n    elt.z, elt.w, elt.x,\n    -elt.w, elt.z, elt.y\n    );\n    mat3x4 aux2 = mat3x4(\n    elt.x, elt.y, elt.z, elt.w,\n    -elt.y, elt.x, elt.w, -elt.z,\n    elt.z, elt.w, elt.x, elt.y\n    );\n    mat3 res = aux1 * aux2;\n                                                                        \n    return res;\n}\n\n                      \nvec3 SLtoH2(vec4 elt) {\n    mat3 m = SLtoMatrix3(elt);\n    vec3 res = vec3(0., 0., 1.);\n    res = m * res;\n                                 \n                                           \n    mat3 J = mat3(\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, -1\n    );\n    float q = dot(res, J * res);\n                           \n    res = res / sqrt(abs(q));\n    return res;\n}\n\n                                          \nvec4 SLinvert(vec4 elt) {\n    vec4 res = vec4(elt.x, -elt.y, -elt.z, -elt.w);\n    return SLreduceError(res);\n}\n\n                                                                                              \nmat4 SLtoMatrix4(vec4 elt) {\n    mat4 res = mat4(\n    elt.x, elt.y, elt.z, elt.w,\n    -elt.y, elt.x, elt.w, -elt.z,\n    elt.z, elt.w, elt.x, elt.y,\n    elt.w, -elt.z, -elt.y, elt.x\n    );\n    return res;\n}\n\n                                                                   \nvec4 SLmultiply(vec4 elt1, vec4 elt2) {\n    mat4 L1 = SLtoMatrix4(elt1);\n    return SLreduceError(L1 * elt2);\n}\n\n                                                           \nvec4 SLtranslateFiberBy(vec4 elt, float angle) {\n    float aux = 0.5 * angle;\n    mat4 T = mat4(\n    cos(aux), sin(aux), 0., 0.,\n    -sin(aux), cos(aux), 0., 0.,\n    0., 0., cos(aux), -sin(aux),\n    0., 0., sin(aux), cos(aux)\n    );\n    return SLreduceError(T * elt);\n}\n\n                                                              \nvec4 SLrotateBy(vec4 elt, float angle) {\n    mat4 R = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, cos(angle), sin(angle),\n    0, 0, -sin(angle), cos(angle)\n    );\n    return SLreduceError(R * elt);\n}\n\n                                         \nvec4 SLflip(vec4 elt) {\n    mat4 F = mat4(\n    1, 0, 0, 0,\n    0, -1, 0, 0,\n    0, 0, 0, 1,\n    0, 0, 1, 0\n    );\n    return SLreduceError(F * elt);\n}\n\n\n                                                                                                                        \n  \n                \n                                        \n  \n                                                                                                                        \nstruct Point{\n    vec4 proj;\n    float fiber;\n};\n\n\nconst Point ORIGIN = Point(vec4(1, 0, 0, 0), 0.);                              \n\n\n   \n                                                           \n   \nPoint reduceError(Point p){\n    p.proj = SLreduceError(p.proj);\n    return p;\n}\n\n   \n                  \n                                                                \n                                                                       \n                              \n   \nvec4 toVec4(Point p) {\n    vec4 res;\n                                                                     \n    res.xyz = SLtoH2(p.proj);\n    res.w = p.fiber;\n    return res;\n}\n\n\n\n   \n                  \n                                                                \n                                                               \n                              \n   \nvec4 toKlein(Point p){\n                                                                     \n    vec4 res = toVec4(p);\n    res.xyz = res.xyz / res.z;\n    return res;\n}\n\n\n                                                                                                                        \n  \n                   \n                                            \n  \n                                                                                                                        \nstruct Isometry{\n    mat4 matrix;\n    float fiber;\n    bool isInSL;\n};\n\n   \n                    \n   \nconst Isometry IDENTITY = Isometry(mat4(1.), 0., true);                          \n\n   \n                                                              \n                      \n   \nIsometry reduceError(Isometry isom){\n    return isom;\n}\n\n   \n                                                                               \n   \nbool doesFlip(Isometry isom){\n    if (isom.isInSL){\n        return false;\n    } else {\n        float a00 = isom.matrix[0][0];\n        float a10 = isom.matrix[1][0];\n        float a01 = isom.matrix[0][1];\n        float a11 = isom.matrix[1][1];\n        return (a00 * a11 - a01 * a10) < 0.;\n    }\n}\n\n   \n                                       \n   \nPoint applyIsometry(Isometry isom, Point p) {\n    vec4 proj = isom.matrix * p.proj;\n    float dir;\n    if (doesFlip(isom)){\n        dir = -1.;\n    } else {\n        dir = 1.;\n    }\n    vec4 aux = SLtranslateFiberBy(proj, -isom.fiber - dir * p.fiber);\n    float fiber = isom.fiber + dir * p.fiber + 2. * atan(aux.y, aux.x);\n    return Point(proj, fiber);\n}\n\n   \n                                                                     \n                                  \n   \n\nIsometry makeTranslation(Point p) {\n    mat4 matrix = SLtoMatrix4(p.proj);\n    return Isometry(matrix, p.fiber, true);\n}\n\n   \n                                                                     \n                                     \n   \nIsometry makeInvTranslation(Point p) {\n    mat4 matrix = SLtoMatrix4(SLinvert(p.proj));\n    return Isometry(matrix, -p.fiber, true);\n}\n\n   \n                                     \n   \nIsometry multiply(Isometry isom1, Isometry isom2) {\n    Point aux2 = Point(isom2.matrix * SL_ORIGIN, isom2.fiber);\n    Point aux = applyIsometry(isom1, aux2);\n    return Isometry(isom1.matrix * isom2.matrix, aux.fiber, isom1.isInSL && isom2.isInSL);\n}\n\n   \n                                            \n   \nIsometry geomInverse(Isometry isom) {\n    float fiber;\n    if (doesFlip(isom)){\n        fiber = isom.fiber;\n    } else {\n        fiber = -isom.fiber;\n    }\n    mat4 inv = inverse(isom.matrix);\n    return Isometry(inv, fiber, isom.isInSL);\n}\n\n\n                                                                                                                        \n  \n                 \n                                                          \n                       \n                               \n                                 \n                                                                                                             \n                                                                             \n                                                    \n                                                    \n                                      \n                                                                                                                        \nstruct Vector{\n    Point pos;                        \n    vec3 dir;                                       \n};\n\n   \n                                \n   \nVector zeroVector(Point pos){\n    return Vector(pos, vec3(0));\n}\n\n   \n                                                            \n   \nVector reduceError(Vector v){\n    v.pos = reduceError(v.pos);\n    return v;\n}\n\n   \n                         \n                            \n   \nVector add(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir + v2.dir);\n}\n\n   \n                              \n                            \n   \nVector sub(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir - v2.dir);\n}\n\n   \n                                   \n                         \n                      \n   \nVector multiplyScalar(float s, Vector v){\n    return Vector(v.pos, s * v.dir);\n}\n\n\n   \n                                                                                 \n                     \n   \nfloat geomDot(Vector v1, Vector v2) {\n    return dot(v1.dir, v2.dir);\n}\n\n\n   \n                                        \n   \nVector applyIsometry(Isometry isom, Vector v) {\n    Point p = applyIsometry(isom, v.pos);\n    if (isom.isInSL) {\n        return Vector(p, v.dir);\n    } else {\n        vec4 aux = vec4(0, v.dir.zxy);\n        mat4 push = SLtoMatrix4(v.pos.proj);\n        mat4 pull = SLtoMatrix4(SLinvert(p.proj));\n        vec4 dir = pull * isom.matrix * push * aux;\n        return Vector(p, aux.zwy);\n    }\n}\n\n\n   \n                                                                         \n                                                                                                           \n                                           \n   \nVector applyFacing(mat4 m, Vector v) {\n                                                                                          \n                                                                               \n    vec4 aux = m * vec4(v.dir, 0);\n    return Vector(v.pos, aux.xyz);\n}\n\nvoid initFlow(Vector v){\n}\n"},1455:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                     \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                               \n                                                                       \n                                     \n                                                      \n                                                                                             \n                                     \n   \nvoid frame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec3(1, 0, 0));\n    f[1] = Vector(p, vec3(0, 1, 0));\n    f[2] = Vector(p, vec3(0, 0, 1));\n}\n\n   \n                                           \n                                                                       \n                                     \n                                                      \n   \nvoid orthoFrame(Point p, out Vector[3] f){\n    f[0] = Vector(p, vec3(1, 0, 0));\n    f[1] = Vector(p, vec3(0, 1, 0));\n    f[2] = Vector(p, vec3(0, 0, 1));\n}\n\n   \n                                                                                         \n                              \n                                                                                              \n   \nPoint smallShift(Point p, vec3 dp){\n                                                   \n    vec4 SLdirAtOrigin = 0.5 * vec4(0, dp.z, dp.x, dp.y);\n                                               \n    vec4 SLdirAtP =  SLtoMatrix4(p.proj) * SLdirAtOrigin;\n\n                                                   \n    float den = p.proj.x * p.proj.x + p.proj.y * p.proj.y;\n    float coeffX = (p.proj.x * p.proj.w - p.proj.y * p.proj.z) / den;\n    float coeffY = -(p.proj.x * p.proj.z + p.proj.y * p.proj.w) / den;\n    float dfiberAtP = coeffX * dp.x + coeffY * dp.y + dp.z;\n\n    vec4 newProj = SLreduceError(p.proj + SLdirAtP);\n    float newFiber = p.fiber + dfiberAtP;\n\n    return Point(newProj, newFiber);\n}\n\nVector smallShift(Vector v, vec3 dp){\n    Point pos = smallShift(v.pos, dp);\n    return Vector(pos, v.dir);\n}\n\n\n   \n                                  \n                                                 \n   \nVector flow(Vector v, float t){\n    Vector res;\n\n    float c = v.dir.z;\n    float a = sqrt(1. - c * c);\n    float absC = abs(c);\n\n    vec4 spin = vec4(cos(c * t), sin(c * t), 0, 0);\n    vec4 trans;\n    float omega, tanTheta;\n    res.pos.fiber = 2. * c * t;\n\n    if (a == absC){\n        trans = vec4(\n        1.,\n        -0.25 * sqrt(2.) * t,\n        0.5 * t,\n        0);\n        tanTheta = -0.25 * sqrt(2.) * t;\n        res.pos.fiber = res.pos.fiber + 2. * atan(tanTheta);\n    } else if (a > absC){\n        omega = sqrt(a * a - c * c);\n        trans = vec4(\n        cosh(0.5 * omega * t),\n        -(c / omega) * sinh(0.5 * omega * t),\n        (1. / omega) * sinh(0.5 * omega * t),\n        0);\n        tanTheta = - (c / omega) * tanh(0.5 * omega * t);\n        res.pos.fiber = res.pos.fiber + 2. * atan(tanTheta);\n    } else if (a < absC){\n        omega = sqrt(c * c - a * a);\n        trans = vec4(\n        cos(0.5 * omega * t),\n        -(c / omega) * sin(0.5 * omega * t),\n        (1. / omega) * sin(0.5 * omega *t),\n        0\n        );\n        tanTheta = - (c / omega) * tan(0.5 * omega *t);\n        float n = floor(0.5 * omega * t / PI + 0.5);\n        if (c < 0.){\n            n = -n;\n        }\n        res.pos.fiber = res.pos.fiber + 2. * atan(tanTheta) - 2. * n * PI;\n    }\n\n    res.pos.proj = SLmultiply(trans, spin);\n    mat2 rotation = mat2(\n    v.dir.x, v.dir.y,\n    -v.dir.y, v.dir.x\n    );\n    res.pos.proj.zw = rotation * res.pos.proj.zw;\n\n                                                 \n                                                                         \n                                                       \n    mat3 S = mat3(\n    cos(2. * c * t), -sin(2. * c * t), 0.,\n    sin(2. * c * t), cos(2. * c * t), 0.,\n    0., 0., 1.\n    );\n    res.dir = S * v.dir;\n\n    Isometry isom = makeTranslation(v.pos);\n    res = applyIsometry(isom, res);\n    return res;\n}\n"},7158:e=>{e.exports="Vector _fakeDirectionFromOrigin(Point p) {\n                              \n\n    vec4 aux = toVec4(p);\n    vec3 oh = vec3(0, 0, 1);\n    mat3 J = mat3(\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, -1\n    );\n    float c = dot(aux.xyz, J * oh);\n\n                                                                       \n                                                                                   \n                                                                                                                      \n                            \n                                                                      \n    float fix;\n    if (-c < 2.) fix = max(1., -c); else fix = -c;\n\n    float lenAux = acosh(fix);\n    vec3 dirAux = aux.xyz + c * oh;\n    dirAux = (lenAux / sqrt(c * c  - 1.)) * dirAux;\n    Vector res = Vector(p, vec3(dirAux.xy, aux.w));\n    return geomNormalize(res);\n}\n\n                                   \nVector fakeDirection(Point p1, Point p2){\n    Isometry shift = makeTranslation(p1);\n    Isometry shiftInv = makeInvTranslation(p1);\n    Vector _dirFromOrigin = _fakeDirectionFromOrigin(applyIsometry(shiftInv, p2));\n    return applyIsometry(shift, _dirFromOrigin);\n}\n\n                                                                         \nVector fakeDirection(Vector v1, Vector v2){\n    return fakeDirection(v1.pos, v2.pos);\n}"},2927:e=>{e.exports="float _fakeDistanceFromOrigin(Point p) {\n                          \n    \n    vec4 aux = toVec4(p);\n    vec3 oh = vec3(0, 0, 1);\n    mat3 J = mat3(\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, -1\n    );\n    float q = dot(aux.xyz, J * oh);\n\n                                                                       \n                                                                                   \n                                                                                                                      \n                            \n                                                                      \n    float fix;\n    if (-q < 2.) fix = max(1., -q); else fix = -q;\n    return 0.5 * sqrt(pow(acosh(fix), 2.) + pow(aux.w, 2.));\n}\n\n                                   \nfloat fakeDistance(Point p1, Point p2){\n    Isometry shift = makeInvTranslation(p1);\n    return _fakeDistanceFromOrigin(applyIsometry(shift, p2));\n}\n\n                                                                         \nfloat fakeDistance(Vector v1, Vector v2){\n    return fakeDistance(v1.pos, v2.pos);\n}"},3348:e=>{e.exports="                                                  \n\nfloat H2EhypDot(vec3 v1, vec3 v2){\n    return v1.x * v2.x + v1.y * v2.y - v1.z * v2.z;\n}\n\nfloat H2EhypLengthSq(vec3 v) {\n    return abs(H2EhypDot(v, v));\n}\n\nfloat H2EhypLength(vec3 v) {\n    return sqrt(H2EhypLengthSq(v));\n}\n\n                                                 \n\nfloat H2EhypDot(vec4 v1, vec4 v2){\n    return H2EhypDot(v1.xyz, v2.xyz);\n}\n\nfloat H2EhypLengthSq(vec4 v) {\n    return abs(H2EhypDot(v, v));\n}\n\nfloat H2EhypLength(vec4 v) {\n    return sqrt(H2EhypLengthSq(v));\n}\n\n\n\n\n                                                           \n                                   \n\nvec4 H2Edirection(vec4 p, vec4 q){\n    vec3 pAux = p.xyz;\n    vec3 qAux = q.xyz;\n    float c = H2EhypDot(pAux, qAux);\n    float lenAux = acosh(-c);\n    vec3 dirAux = qAux + c * pAux;\n    dirAux = (lenAux / sqrt(c * c  - 1.)) * dirAux;\n    return vec4(dirAux, q.w - p.w);\n}"},3876:e=>{e.exports="   \n                                                                                   \n                                                  \n                                        \n                                \n  \nfloat lightIntensity(float len){\n                            \n    return 1./ len;\n}"},2173:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct ConstDirLight {\n    int id;\n    vec3 color;\n    float intensity;\n    vec3 direction;\n    int maxDirs;\n};\n\nbool directions(ConstDirLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    intensity = light.intensity;\n                                                             \n                                                                        \n    Vector local = Vector(v.local.pos, light.direction);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}"},8442:e=>{e.exports="                                                                                                                        \n          \n                    \n                                                                                                                        \nstruct LocalFakePointLight {\n    int id;\n    vec3 color;\n    float intensity;\n    Point position;\n    int maxDirs;\n};\n\nbool directions(LocalFakePointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n                                                                         \n    float dist = fakeDistance(v.local.pos, light.position);\n    intensity = lightIntensity(dist) * light.intensity;\n    Vector local = fakeDirection(v.local.pos, light.position);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}\n"},7538:e=>{e.exports="                                                                                                                        \n                       \n                                                                                                                        \n\nstruct MultiColorMaterial {\n    vec3 mainColor;\n    vec3 accent1;\n    vec3 accent2;\n    vec3 accent3;\n    bool grid;\n};\n\nvec4 render(MultiColorMaterial material, ExtVector v) {\n    vec4 coords = toVec4(v.vector.local.pos);\n    vec3 dir = normalize(coords.xyw);\n    vec3 color = material.mainColor;\n    color += material.accent1 * dir.x;\n    color += material.accent2 * dir.y;\n    color += material.accent3 * dir.z;\n\n    float rDist = acosh(hypLength(v.vector.local.pos.coords));\n    float theta = atan(dir.y,dir.x);\n    float height = coords.w;\n\n    if(material.grid){\n        float test = sin(70.*rDist)*sin(70.*theta)*sin(70.*height);\n        float sgn = sign(test);\n        if (sgn<0.){\n            color *=0.9;\n        }\n    }\n\n    return vec4(color, 1);\n}"},1855:e=>{e.exports="                                                                                                                        \n                         \n                                                                                                                        \n\nstruct VaryingColorMaterial {\n    vec3 mainColor;\n    vec3 weight;\n};\n\nvec4 render(VaryingColorMaterial material, ExtVector v) {\n    vec3 color =  material.mainColor + material.weight * normalize(v.vector.local.pos.proj.yzw);\n    return vec4(color, 1);\n}"},3931:e=>{e.exports="                                                                                                                        \n          \n                   \n                                                                                                                        \n\nstruct FakeBallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                                \n   \nfloat sdf(FakeBallShape ball, RelVector v) {\n    Point center = applyIsometry(v.invCellBoost, ball.center);\n    return fakeDistance(v.local.pos, center) - ball.radius;\n}\n\n\n"},3053:e=>{e.exports="                                                                                                                        \n          \n                   \n                                                                                                                        \n\nstruct LocalFakeBallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                                \n   \nfloat sdf(LocalFakeBallShape ball, RelVector v) {\n    return fakeDistance(v.local.pos, ball.center) - ball.radius;\n}\n\n                                                      \nvec2 uvMap(LocalFakeBallShape ball, RelVector v){\n    vec4 center = toVec4(ball.center);\n    vec4 p = toVec4(v.local.pos);\n    vec4 dir = H2Edirection(center, p);\n    float sinPhi = H2EhypLength(dir.xyz);\n    float cosPhi = dir.w;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}"},9302:e=>{e.exports="                                                                                                                        \n          \n                   \n                                                                                                                        \n\nstruct LocalPotatoShape {\n    int id;\n    Point center;\n    float radius;\n    float wRescale;\n};\n\n\nfloat _potatoDistanceFromOrigin(Point p, float wRescale) {\n    vec4 aux = toVec4(p);\n    vec3 oh = vec3(0, 0, 1);\n    mat3 J = mat3(\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, -1\n    );\n    float q = dot(aux.xyz, J * oh);\n\n                                                                       \n                                                                                   \n                                                                                                                      \n                            \n                                                                      \n    float fix;\n    if (-q < 2.) fix = max(1., -q); else fix = -q;\n    return 0.5 * sqrt(pow(acosh(fix), 2.) + pow(aux.w / wRescale, 2.));\n}\n\n                                   \nfloat _potatoDistance(Point p1, Point p2, float wRescale){\n    Isometry shift = makeInvTranslation(p1);\n    return _potatoDistanceFromOrigin(applyIsometry(shift, p2), wRescale);\n}\n\n\n   \n                                                \n   \nfloat sdf(LocalPotatoShape ball, RelVector v) {\n    return _potatoDistance(v.local.pos, ball.center, ball.wRescale) - ball.radius;\n}\n"},5688:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                            \n  \n                                                                                                                        \n                                                                                                                        \n\n\n"}},n={};function r(e){var a=n[e];if(void 0!==a)return a.exports;var o=n[e]={exports:{}};return t[e](o,o.exports,r),o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})();var a={};(()=>{r.d(a,{T0:()=>Zo,FJ:()=>$o,GU:()=>_t,XH:()=>Te,ZH:()=>zt,K9:()=>W,FT:()=>wt,cK:()=>ft,_x:()=>pt,kj:()=>vt,V1:()=>Ie,Vz:()=>cn,ck:()=>J,Iy:()=>Wa,Vf:()=>_i,TB:()=>fn,Al:()=>qo,ix:()=>mr,jZ:()=>hr,c$:()=>Wt,OZ:()=>al,Ao:()=>qi,Qj:()=>Ke,mD:()=>Fo,yb:()=>Rt,iJ:()=>dn,ZA:()=>Je,Jz:()=>Ce,fR:()=>ea,kK:()=>Ar,ZX:()=>ir,_f:()=>vr,Ht:()=>xr,HZ:()=>jo,TN:()=>co,JV:()=>n,Sc:()=>zo,Nh:()=>Ho,RL:()=>_e,_k:()=>St,uR:()=>Wo,gU:()=>es,oR:()=>ol,lt:()=>Zi,_r:()=>ki,tl:()=>sl,HI:()=>el,F5:()=>Tt,Uc:()=>ss,Fh:()=>Oo,O5:()=>ji,oB:()=>Xt,pJ:()=>Ct,GW:()=>Xe,DZ:()=>xe,_K:()=>Fa,JF:()=>rn,Lv:()=>Dr,E9:()=>s,Ly:()=>l,jo:()=>os,mH:()=>ts,xd:()=>as,pX:()=>Se,Dz:()=>Re,Th:()=>p,Uj:()=>Ko,bY:()=>wn,cV:()=>lo,lR:()=>To,xs:()=>Ht,bn:()=>Mt,oC:()=>Ao,Z1:()=>yn,h8:()=>kt,Qf:()=>rl,jE:()=>Be,k1:()=>tr,ew:()=>ar,$p:()=>Go,xG:()=>gt,l_:()=>_a,pk:()=>da,yI:()=>Co,E6:()=>Ne,zO:()=>ze,cB:()=>Bi,OW:()=>i,n3:()=>Qn,Se:()=>Xn,PQ:()=>Wn,$9:()=>Lo,ak:()=>Ve,uZ:()=>we,Cy:()=>Ka,qM:()=>Dn,tA:()=>fs,Zk:()=>Zs,mV:()=>ta,Gi:()=>Gr,jV:()=>ho,j9:()=>Pn,oc:()=>En,mm:()=>xi,wS:()=>ja,IJ:()=>Er,p2:()=>Me,w0:()=>kn,VL:()=>Sa,UR:()=>ma,dV:()=>Kt,G0:()=>Ro,YL:()=>Gn,re:()=>Bo});const t=(e=>{var t={};return r.d(t,e),t})({BufferGeometry:()=>e.BufferGeometry,Clock:()=>e.Clock,Color:()=>e.Color,EventDispatcher:()=>e.EventDispatcher,Float32BufferAttribute:()=>e.Float32BufferAttribute,HalfFloatType:()=>e.HalfFloatType,ImageLoader:()=>e.ImageLoader,LinearFilter:()=>e.LinearFilter,MathUtils:()=>e.MathUtils,Matrix3:()=>e.Matrix3,Matrix4:()=>e.Matrix4,Mesh:()=>e.Mesh,NearestFilter:()=>e.NearestFilter,NoBlending:()=>e.NoBlending,OrthographicCamera:()=>e.OrthographicCamera,PerspectiveCamera:()=>e.PerspectiveCamera,PlaneGeometry:()=>e.PlaneGeometry,Quaternion:()=>e.Quaternion,RGBAFormat:()=>e.RGBAFormat,RepeatWrapping:()=>e.RepeatWrapping,Scene:()=>e.Scene,ShaderMaterial:()=>e.ShaderMaterial,SphereGeometry:()=>e.SphereGeometry,Texture:()=>e.Texture,TextureLoader:()=>e.TextureLoader,Uniform:()=>e.Uniform,UniformsUtils:()=>e.UniformsUtils,Vector2:()=>e.Vector2,Vector3:()=>e.Vector3,Vector4:()=>e.Vector4,VideoTexture:()=>e.VideoTexture,WebGLRenderTarget:()=>e.WebGLRenderTarget,WebGLRenderer:()=>e.WebGLRenderer});class n{constructor(){this.build(...arguments)}build(){throw new Error("This method need be overloaded.")}get isIsometry(){return!0}identity(){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}multiply(e){throw new Error("This method need be overloaded.")}premultiply(e){throw new Error("This method need be overloaded.")}invert(){return this.matrix.invert(),this}makeTranslation(e){throw new Error("This method need be overloaded.")}makeInvTranslation(e){throw new Error("This method need be overloaded.")}makeTranslationFromDir(e){throw new Error("This method need be overloaded.")}diffExpMap(e){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new n;return e.copy(this),e}}t.Vector4.prototype.hypDot=function(e){return this.x*e.x+this.y*e.y-this.z*e.z},t.Vector4.prototype.hypLengthSq=function(){return Math.abs(this.hypDot(this))},t.Vector4.prototype.hypLength=function(){return Math.sqrt(this.hypLengthSq())},t.Vector4.prototype.hypNormalize=function(){const[e,t,n,r]=this.toArray(),a=this.hypLength();return this.set(e/a,t/a,n/a,r),this};class o extends t.Vector4{constructor(){super(...arguments),0===arguments.length&&this.set(1,0,0,0)}toMatrix3(){let e=(new t.Matrix4).set(this.x,-this.y,this.z,-this.w,this.y,this.x,this.w,this.z,this.z,this.w,this.x,this.y,0,0,0,0),n=(new t.Matrix4).set(this.x,-this.y,this.z,0,this.y,this.x,this.w,0,this.z,this.w,this.x,0,this.w,-this.z,this.y,0),r=e.multiply(n);return(new t.Matrix3).setFromMatrix4(r)}toH2(){let e=this.toMatrix3(),n=(new t.Vector3).set(0,0,1);return n.applyMatrix3(e),n}toMatrix4(){const[e,n,r,a]=this.toArray();return(new t.Matrix4).set(e,-n,r,a,n,e,a,-r,r,a,e,-n,a,-r,n,e)}premultiply(e){let t=e.toMatrix4();return this.applyMatrix4(t),this.reduceError(),this}multiply(e){let t=this.toMatrix4();return this.copy(e.clone().applyMatrix4(t)),this.reduceError(),this}rotateBy(e){let n=(new t.Matrix4).set(1,0,0,0,0,1,0,0,0,0,Math.cos(e),-Math.sin(e),0,0,Math.sin(e),Math.cos(e));return this.applyMatrix4(n),this.reduceError(),this}flip(){let e=(new t.Matrix4).set(1,0,0,0,0,-1,0,0,0,0,0,1,0,0,1,0);return this.applyMatrix4(e),this.reduceError(),this}translateFiberBy(e){let n=.5*e,r=(new t.Matrix4).set(Math.cos(n),-Math.sin(n),0,0,Math.sin(n),Math.cos(n),0,0,0,0,Math.cos(n),Math.sin(n),0,0,-Math.sin(n),Math.cos(n));return this.applyMatrix4(r),this.reduceError(),this}invert(){return this.set(this.x,-this.y,-this.z,-this.w),this}reduceError(){let e=-Math.pow(this.x,2)-Math.pow(this.y,2)+Math.pow(this.z,2)+Math.pow(this.w,2);return this.multiplyScalar(1/Math.sqrt(-e)),this}}class s{constructor(...e){this.build(...e)}build(){throw new Error("This method need be overloaded.")}get isPoint(){return!0}set(){throw new Error("This method need be overloaded.")}applyIsometry(e){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new s;return e.copy(this),e}}s.prototype.build=function(){0===arguments.length?(this.proj=new o,this.fiber=0):(this.proj=new o(...arguments),this.fiber=arguments[4])},s.prototype.set=function(e,t,n,r,a){return this.proj.set(e,t,n,r),this.fiber=a,this},s.prototype.applyIsometry=function(e){this.proj.applyMatrix4(e.matrix);const t=e.doesFlip()?-1:1,n=this.proj.clone();return n.translateFiberBy(-e.fiber-t*this.fiber),this.fiber=e.fiber+t*this.fiber+2*Math.atan2(n.y,n.x),this},s.prototype.toVector4=function(){let e=this.proj.toH2();return new t.Vector4(e.x,e.y,e.z,this.fiber)},s.prototype.fromVector4=function(e){const[t,n,r,a]=e.toArray();return this.fiber=a,this.proj.set(Math.sqrt(.5*r+.5),0,t/Math.sqrt(2*r+2),n/Math.sqrt(2*r+2)),this.proj.translateFiberBy(this.fiber),this},s.prototype.toKlein=function(){let e=this.toVector4();return new t.Vector4(e.x/e.z,e.y/e.z,1,e.w)},s.prototype.equals=function(e){return this.proj.equals(e.proj)&&this.fiber===e.fiber},s.prototype.reduceError=function(){return this.proj.reduceError(),this},s.prototype.copy=function(e){return this.proj.copy(e.proj),this.fiber=e.fiber,this},n.prototype.build=function(){this.matrix=new t.Matrix4,this.fiber=0,this.isInSL=!0},n.prototype.identity=function(){return this.matrix.identity(),this.fiber=0,this.isInSL=!0,this},n.prototype.reduceError=function(){return this},n.prototype.doesFlip=function(){if(this.isInSL)return!1;{const e=this.matrix.elements[0],t=this.matrix.elements[1],n=this.matrix.elements[4];return e*this.matrix.elements[5]-t*n<0}},n.prototype.multiplyIsometries=function(e,t){const n=new s;n.proj.copy((new o).applyMatrix4(t.matrix)),n.fiber=t.fiber;const r=n.applyIsometry(e);return this.matrix.multiplyMatrices(e.matrix,t.matrix),this.fiber=r.fiber,this.isInSL=e.isInSL&&t.isInSL,this},n.prototype.multiply=function(e){return this.multiplyIsometries(this,e)},n.prototype.premultiply=function(e){return this.multiplyIsometries(e,this)},n.prototype.invert=function(){return this.fiber=this.doesFlip()?this.fiber:-this.fiber,this.matrix.invert(),this},n.prototype.makeTranslation=function(e){return this.matrix.copy(e.proj.toMatrix4()),this.fiber=e.fiber,this.isInSL=!0,this},n.prototype.makeTranslationFromUnitDir=function(e,n){const r=e.z,a=Math.sqrt(1-r*r),i=new s,l=(new o).set(Math.cos(r*n),Math.sin(r*n),0,0);let c,h,u=2*r*n;const d=Math.abs(r);if(a===d)i.proj.set(1,-.25*Math.sqrt(2)*n,.5*n,0),h=-.25*Math.sqrt(2)*n,i.fiber=u+2*Math.atan(h);else if(a>d)c=Math.sqrt(a*a-r*r),i.proj.set(Math.cosh(.5*c*n),-r/c*Math.sinh(.5*c*n),1/c*Math.sinh(.5*c*n),0),h=-r/c*Math.tanh(.5*c*n),i.fiber=u+2*Math.atan(h);else if(a<d){c=Math.sqrt(r*r-a*a),i.proj.set(Math.cos(.5*c*n),-r/c*Math.sin(.5*c*n),1/c*Math.sin(.5*c*n),0),h=-r/c*Math.tan(.5*c*n);let e=Math.floor(.5*c*n/Math.PI+.5);r<0&&(e=-e),i.fiber=u+2*Math.atan(h)-2*e*Math.PI}i.proj.multiply(l);const m=(new t.Matrix4).set(1,0,0,0,0,1,0,0,0,0,e.x,-e.y,0,0,e.y,e.x);return i.proj.applyMatrix4(m),this.makeTranslation(i),this},n.prototype.makeTranslationFromDir=function(e){const t=e.length();if(0===t)return this.identity(),this;const n=e.clone().normalize();return this.makeTranslationFromUnitDir(n,t)},n.prototype.makeInvTranslation=function(e){const t=e.proj.clone().invert();return this.matrix.copy(t.toMatrix4()),this.fiber=-e.fiber,this.isInSL=!0,this},n.prototype.equals=function(e){return this.matrix.equals(e.matrix)&&this.fiber===e.fiber},n.prototype.copy=function(e){return this.matrix.copy(e.matrix),this.fiber=e.fiber,this.isInSL=e.isInSL,this};class i extends t.Vector3{get isVector(){return!0}applyMatrix4(e){const n=new t.Vector4(this.x,this.y,this.z,0);return n.applyMatrix4(e),this.set(n.x,n.y,n.z),this}applyFacing(e){return this.applyQuaternion(e.quaternion),this}}class l{constructor(){this.boost=new n,this.quaternion=new t.Quaternion}get isPosition(){return!0}get facing(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion)}setBoost(e){return this.boost.copy(e),this}setQuaternion(e){return this.quaternion.copy(e),this}reduceErrorBoost(){return this.boost.reduceError(),this}reduceErrorQuaternion(){return this.quaternion.normalize(),this}reduceError(){return this.reduceErrorBoost(),this.reduceErrorQuaternion(),this}get point(){return(new s).applyIsometry(this.boost)}reset(){return this.boost.identity(),this.quaternion.identity(),this}applyIsometry(e){return this.boost.premultiply(e),this}applyQuaternion(e){return this.quaternion.multiply(e),this}multiply(e){return this.boost.multiply(e.boost),this.quaternion.premultiply(e.quaternion),this}premultiply(e){return this.boost.premultiply(e.boost),this.quaternion.multiply(e.quaternion),this}flowFromOrigin(e){throw new Error("This method need be overloaded.")}flow(e){const t=e.clone().applyFacing(this),n=(new l).flowFromOrigin(t);return this.multiply(n),this}fakeDiffExpMap(e){const n=(new i).setFromMatrixPosition(e),r=(new t.Quaternion).setFromRotationMatrix(e);return this.flow(n),this.quaternion.multiply(r),this}equals(e){return this.boost.equals(e.boost)&&this.quaternion.equals(e.quaternion)}copy(e){return this.boost.copy(e.boost),this.quaternion.copy(e.quaternion),this}clone(){const e=new l;return e.copy(this),e}}const c=new t.Vector3(1,0,0),h=new t.Vector3(0,0,1);l.prototype.flowFromOrigin=function(e){const n=e.length();if(0===n)return this.boost.identity(),this.quaternion.identity(),this;const r=e.clone().normalize(),a=r.z;this.boost.makeTranslationFromUnitDir(r,n);const o=(new t.Quaternion).setFromAxisAngle(h,-2*a*n),s=(new t.Quaternion).setFromAxisAngle(c,.5*n),i=(new t.Quaternion).setFromUnitVectors(c,r);return this.quaternion.identity().multiply(o).multiply(i).multiply(s).multiply(i.conjugate()),this.reduceErrorQuaternion(),this};var u=r(8348),d=r.n(u),m=r(1455),b=r.n(m);class p{static shader1=void 0;static shader2=void 0;constructor(e,n,r={},a={}){this.camera=e,this.scene=n,this.threeRenderer=a.isWebGLRenderer?a:new t.WebGLRenderer(a),this.globalUniforms=void 0!==r.globalUniforms?r.globalUniforms:{},void 0===this.globalUniforms.maxBounces&&(this.globalUniforms.maxBounces={type:"int",value:0}),this.globalUniforms.windowSize={type:"vec2",value:new t.Vector2(window.innerWidth,window.innerHeight)}}get set(){return this.camera.position.set}setPixelRatio(e){this.threeRenderer.setPixelRatio(e)}setSize(e,t,n=!0){this.threeRenderer.setSize(e,t,n)}setClearColor(e,t){this.threeRenderer.setClearColor(e,t)}setAnimationLoop(e){this.threeRenderer.setAnimationLoop(e)}get domElement(){return this.threeRenderer.domElement}build(){throw new Error("Renderer: this method is not implemented")}render(){throw new Error("Renderer: this method is not implemented")}}class v{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const f=new t.OrthographicCamera(-1,1,1,-1,0,1);class g extends t.BufferGeometry{constructor(){super(),this.setAttribute("position",new t.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new t.Float32BufferAttribute([0,2,0,0,2,0],2))}}const x=new g;class y{constructor(e){this._mesh=new t.Mesh(x,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,f)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class V extends v{constructor(e,n,r=null,a=null,o=null){super(),this.scene=e,this.camera=n,this.overrideMaterial=r,this.clearColor=a,this.clearAlpha=o,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new t.Color}render(e,t,n){const r=e.autoClear;let a,o;e.autoClear=!1,null!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor)),null!==this.clearAlpha&&(a=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(a),null!==this.overrideMaterial&&(this.scene.overrideMaterial=o),e.autoClear=r}}class M extends v{constructor(e,n){super(),this.textureID=void 0!==n?n:"tDiffuse",e instanceof t.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=t.UniformsUtils.clone(e.uniforms),this.material=new t.ShaderMaterial({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new y(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}const w={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class _ extends v{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const r=e.getContext(),a=e.state;let o,s;a.buffers.color.setMask(!1),a.buffers.depth.setMask(!1),a.buffers.color.setLocked(!0),a.buffers.depth.setLocked(!0),this.inverse?(o=0,s=1):(o=1,s=0),a.buffers.stencil.setTest(!0),a.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),a.buffers.stencil.setFunc(r.ALWAYS,o,4294967295),a.buffers.stencil.setClear(s),a.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),a.buffers.color.setLocked(!1),a.buffers.depth.setLocked(!1),a.buffers.color.setMask(!0),a.buffers.depth.setMask(!0),a.buffers.stencil.setLocked(!1),a.buffers.stencil.setFunc(r.EQUAL,1,4294967295),a.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),a.buffers.stencil.setLocked(!0)}}class S extends v{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class T{constructor(e,n){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===n){const r=e.getSize(new t.Vector2);this._width=r.width,this._height=r.height,(n=new t.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:t.HalfFloatType})).texture.name="EffectComposer.rt1"}else this._width=n.width,this._height=n.height;this.renderTarget1=n,this.renderTarget2=n.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new M(w),this.copyPass.material.blending=t.NoBlending,this.clock=new t.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,r=this.passes.length;t<r;t++){const r=this.passes[t];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==_&&(r instanceof _?n=!0:r instanceof S&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const n=this.renderer.getSize(new t.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=n.width,this._height=n.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class C{constructor(e=1){this.useCase=e,this.code="",this.includedImports=[],this.includedClasses=[],this.includedConstants=[],this.includedUniforms=[],this.includedInstances=[],this.uniforms={}}get fragmentShader(){return this.code}addChunk(e){return this.code=this.code+"\r\n\r\n"+e,this}addImport(e){return this.includedImports.includes(e)||(this.includedImports.push(e),this.code=this.code+"\r\n\r\n"+e),this}addClass(e,t){return this.includedClasses.includes(e)||(this.includedClasses.push(e),this.code=this.code+"\r\n\r\n"+t),this}addConstant(e,t,n){return this.includedConstants.includes(e)||(this.includedConstants.push(e),this.code=this.code+"\r\n\r\n"+`const ${t} ${e} = ${n};`),this}addUniform(e,t,n){return this.includedUniforms.includes(e)||(this.includedUniforms.push(e),this.code=this.code+"\r\n\r\n"+`uniform ${t} ${e};`,this.uniforms[e]={type:t,value:n}),this}updateUniform(e,t){return this.uniforms[e].value=t,this}addInstance(e,t){return this.includedInstances.includes(e)||(this.includedInstances.push(e),this.code=this.code+"\r\n\r\n"+t),this}}var R=r(1767),I=r.n(R),D=r(190),E=r.n(D),P=r(4168),k=r.n(P),U=r(2977),L=r.n(U),B=r(2044),N=r.n(B),F=r(9461),j=r.n(F),z=r(7781),H=r.n(z),A=r(6159),G=r.n(A),q=r(5315),O=r.n(q);class W extends p{constructor(e,t,n={},r={}){super(e,t,n,r),this._fragmentBuilder=new C,this.postProcess=void 0!==n.postProcess?n.postProcess:[],this.composer=new T(this.threeRenderer)}get isBasicRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.composer.setSize(e,t)}buildFragmentShader(){this._fragmentBuilder.addChunk(I()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)})),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(E()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(k()),this._fragmentBuilder.addChunk(j()),this.set.shader(this._fragmentBuilder),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(N()(this)),this._fragmentBuilder.addChunk(H()(this)),this._fragmentBuilder.addChunk(L()),this._fragmentBuilder.addChunk(G()),this._fragmentBuilder.addChunk(O())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder);const e=new V(this.camera.threeScene,this.camera.threeCamera);e.clear=!1,this.composer.addPass(e);for(let e=0;e<this.postProcess.length;e++){const t=new M(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}render(){this.composer.render()}}class K extends v{constructor(e,n){super();const r=w;this.map=e,this.opacity=void 0!==n?n:1,this.uniforms=t.UniformsUtils.clone(r.uniforms),this.material=new t.ShaderMaterial({uniforms:this.uniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,depthTest:!1,depthWrite:!1,premultipliedAlpha:!0}),this.needsSwap=!1,this.fsQuad=new y(null)}render(e,t,n){const r=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.uniforms.opacity.value=this.opacity,this.uniforms.tDiffuse.value=this.map,this.material.transparent=this.opacity<1,e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(),this.fsQuad.render(e),e.autoClear=r}dispose(){this.material.dispose(),this.fsQuad.dispose()}}var $=r(7962),Q=r.n($);class Y{constructor(){}uniforms(){return{tDiffuse:{value:null}}}vertexShader(){return Q()}fragmentShader(){throw new Error("Shape: this method should be implemented")}fullShader(){return{uniforms:this.uniforms(),vertexShader:this.vertexShader(),fragmentShader:this.fragmentShader()}}}var Z=r(2690),X=r.n(Z);class J extends Y{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return X()}}var ee=r(6172),te=r.n(ee),ne=r(3499),re=r.n(ne),ae=r(9638),oe=r.n(ae),se=r(7920),ie=r.n(se),le=r(3888),ce=r.n(le),he=r(6272),ue=r.n(he),de=r(8187),me=r.n(de),be=r(4122),pe=r.n(be);const ve=new t.ShaderMaterial({uniforms:{accTex:new t.Uniform(null),newTex:new t.Uniform(null),iFrame:new t.Uniform(0)},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D accTex;\n        uniform sampler2D newTex;\n        uniform float iFrame;\n        void main() {\n            float den = 1./ (1. + iFrame);\n            gl_FragColor = den * (iFrame *  texture2D(accTex, vUv) + texture2D(newTex, vUv));\n        }"}),fe=new y(ve),ge={minFilter:t.NearestFilter,magFilter:t.NearestFilter,format:t.RGBAFormat,type:t.HalfFloatType};class xe extends p{constructor(e,n,r={},a={}){super(e,n,r,a),this.globalUniforms.maxBounces.value=void 0!==r.maxBounces?r.maxBounces:50,this.postProcess=void 0!==r.postProcess?r.postProcess:[],0===this.postProcess.length&&this.postProcess.push(new J),this._fragmentBuilder=new C(3),this.sceneTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,ge),this.accReadTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,ge),this.accWriteTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight,ge),this.iFrame=0,this.composer=new T(this.threeRenderer)}get isPathTracerRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.sceneTarget.setSize(e,t),this.accReadTarget.setSize(e,t),this.accWriteTarget.setSize(e,t),this.composer.setSize(e,t)}updateFrameSeed(){const e=Math.floor(1e4*Math.random());this._fragmentBuilder.updateUniform("frameSeed",e)}buildFragmentShader(){this._fragmentBuilder.addChunk(I()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)}));const e=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.addUniform("resolution","vec2",e),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(E()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(k()),this._fragmentBuilder.addUniform("frameSeed","uint",Math.floor(1e4*Math.random())),this._fragmentBuilder.addChunk(oe()),this._fragmentBuilder.addChunk(ce()),this.set.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(ie()),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(te()(this)),this._fragmentBuilder.addChunk(pe()(this)),this._fragmentBuilder.addChunk(ue()(this)),this._fragmentBuilder.addChunk(re()),this._fragmentBuilder.addChunk(me())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder),this.composer.addPass(new K(this.accReadTarget.texture));for(let e=0;e<this.postProcess.length;e++){const t=new M(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}renderAccTarget(){this.threeRenderer.setRenderTarget(null),this.composer.render()}render(){let e;this.updateFrameSeed();const n=new t.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.updateUniform("resolution",n),this.threeRenderer.setRenderTarget(this.sceneTarget),this.threeRenderer.render(this.threeScene,this.camera.threeCamera),this.threeRenderer.setRenderTarget(this.accWriteTarget),ve.uniforms.accTex.value=this.accReadTarget.texture,ve.uniforms.newTex.value=this.sceneTarget.texture,ve.uniforms.iFrame.value=this.iFrame,fe.render(this.threeRenderer),e=this.accReadTarget,this.accReadTarget=this.accWriteTarget,this.accWriteTarget=e,this.renderAccTarget(),this.iFrame=this.iFrame+1}}class ye{static createButton(e){const t=document.createElement("button");function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",r(t),navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){let n=null;async function r(r){r.addEventListener("end",a),await e.xr.setSession(r),t.textContent="EXIT VR",n=r}function a(){n.removeEventListener("end",a),t.textContent="ENTER VR",n=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){if(null===n){const e={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};navigator.xr.requestSession("immersive-vr",e).then(r)}else n.end()}}():(n(),t.textContent="VR NOT SUPPORTED"),r&&ye.xrSessionIsGranted&&t.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{ye.xrSessionIsGranted=!0}))}}}function Ve(e,t){return function(){return t.apply(e,arguments)}}function Me(e){return e.replace(/\W/g,"_")}function we(e,t,n){return Math.max(t,Math.min(n,e))}ye.xrSessionIsGranted=!1,ye.registerSessionGrantedListener(),t.Vector3.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}]`},t.Vector4.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Matrix3.prototype.toLog=function(){let e="\r\n";for(let t=0;t<3;t++){for(let n=0;n<3;n++)0!==n&&(e+=",\t"),e+=this.elements[t+3*n];e+="\r\n"}return e},t.Matrix3.prototype.power=function(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}},t.Matrix3.prototype.makeRotation=function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this},t.Matrix4.prototype.toLog=function(){let e="\r\n";for(let t=0;t<4;t++){for(let n=0;n<4;n++)0!==n&&(e+=",\t"),e+=this.elements[t+4*n];e+="\r\n"}return e},t.Matrix4.prototype.add=function(e){return this.set.apply(this,[].map.call(this.elements,(function(t,n){return t+e.elements[n]}))),this},t.Quaternion.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},t.Quaternion.prototype.multiplyScalar=function(e){return this.set(e*this.x,e*this.y,e*this.z,e*this.w),this},t.Quaternion.prototype.add=function(e){return this.set(this.x+e.x,this.y+e.y,this.z+e.z,this.w+e.w),this};const _e=0,Se=1,Te=2;class Ce{constructor(e){this.group=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.name=`groupElement_${this.uuid}`}identity(){throw new Error("GroupElement: This method need be overloaded.")}multiply(e){throw new Error("GroupElement: This method need be overloaded.")}premultiply(e){throw new Error("GroupElement: This method need be overloaded.")}invert(){throw new Error("GroupElement: This method need be overloaded.")}toIsometry(){throw new Error("GroupElement: This method need be overloaded.")}equals(e){throw new Error("GroupElement: This method need be overloaded.")}clone(){throw new Error("GroupElement: This method need be overloaded.")}copy(e){throw new Error("GroupElement: This method need be overloaded.")}}class Re{constructor(e){this.local=new l,this.set=e,this.cellBoost=this.set.group.element(),this.invCellBoost=this.set.group.element()}reduceErrorBoost(){return this.local.reduceErrorBoost(),this}reduceErrorFacing(){return this.local.reduceErrorFacing(),this}reduceErrorLocal(){return this.local.reduceError(),this}reduceError(){return this.reduceErrorLocal(),this}get facing(){return this.local.facing}get localPoint(){return this.local.point}get point(){return this.local.point.applyIsometry(this.cellBoost.toIsometry())}get globalBoost(){return this.cellBoost.toIsometry().multiply(this.local.boost)}get globalPosition(){const e=new l;return e.boost.copy(this.globalBoost),e.quaternion.copy(this.local.quaternion),e}reset(){this.local.reset(),this.cellBoost.identity(),this.invCellBoost.identity()}applyQuaternion(e){return this.local.applyQuaternion(e),this}teleport(){let e,t;for(;;){t=this.localPoint,e=!0;for(const n of this.set.teleportations)if(e=e&&!n.jsTest(t),!e){this.local.applyIsometry(n.elt.toIsometry()),this.cellBoost.multiply(n.inv),this.invCellBoost.premultiply(n.elt);break}if(e)break}return this}flow(e){return this.local.flow(e),this.teleport(),this}fakeDiffExpMap(e){return this.local.fakeDiffExpMap(e),this}equals(e){let t=!0;return t=t&&this.local.equals(e.local),t=t&&this.cellBoost.equals(e.cellBoost),t}copy(e){return this.cellBoost.copy(e.cellBoost),this.invCellBoost.copy(e.invCellBoost),this.local.copy(e.local),this}clone(){const e=new Re(this.set);return e.copy(this),e}}r(8415),r(4770);class Ie{constructor(e){this.threeCamera=void 0,this.threeScene=new t.Scene,this.minDist=void 0!==e.minDist?e.minDist:0,this.maxDist=void 0!==e.maxDist?e.maxDist:50,this.safetyDist=void 0!==e.safetyDist?e.safetyDist:0,this.maxSteps=void 0!==e.maxSteps?e.maxSteps:100,this.threshold=void 0!==e.threshold?e.threshold:1e-4,this.position=new Re(e.set),this.fakeCameras=[],this.setThreeCamera(e)}setThreeCamera(e){throw new Error("This method need be implemented.")}setThreeScene(){throw new Error("This method need be implemented.")}get matrix(){return this.threeCamera.matrixWorld}updateProjectionMatrix(){this.threeCamera.updateProjectionMatrix()}static glslClass(){throw new Error("Generic: this function should be implemented")}static glslMapping(){throw new Error("Generic: this function should be implemented")}shader(e,t=void 0){e.addClass("Camera",this.constructor.glslClass()),void 0===t?e.addUniform("camera","Camera",this):e.addUniform("camera","Camera",this.fakeCameras[t]),e.addChunk(this.constructor.glslMapping())}}var De=r(5682),Ee=r.n(De),Pe=r(5970),ke=r.n(Pe),Ue=r(9222),Le=r.n(Ue);class Be extends Ie{constructor(e){super(e)}setThreeCamera(e){this.threeCamera=new t.PerspectiveCamera(void 0!==e.fov?e.fov:70,window.innerWidth/window.innerHeight,.01,2e3),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}set aspect(e){this.threeCamera.aspect=e}get fov(){return this.threeCamera.fov}set fov(e){this.threeCamera.fov=e}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.SphereGeometry(1e3,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:Ee(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return ke()}static glslMapping(){return Le()}}class Ne extends Be{constructor(e){super(e),this.isStereoOn=!1,this.ipDist=void 0!==e.ipDist?e.ipDist:.03200000151991844;for(const e in[_e,Se])this.fakeCameras[e]={fov:this.fov,minDist:this.minDist,maxDist:this.maxDist,maxSteps:this.maxSteps,safetyDist:this.safetyDist,threshold:this.threshold,position:this.position.clone(),matrix:this.matrix}}get isStereoOff(){return!this.isStereoOn}switchStereo(){this.isStereoOn=!this.isStereoOn}setThreeScene(e){const n=new t.SphereGeometry(50,60,40);n.scale(1,1,-1);const r=new t.ShaderMaterial({uniforms:e[_e].uniforms,vertexShader:Ee(),fragmentShader:e[_e].fragmentShader}),a=new t.ShaderMaterial({uniforms:e[Se].uniforms,vertexShader:Ee(),fragmentShader:e[_e].fragmentShader}),o=new t.Mesh(n,r),s=new t.Mesh(n,a);o.layers.set(1),s.layers.set(2),this.threeScene.add(o,s)}updateFakeCamerasPosition(){if(this.fakeCameras[_e].position.copy(this.position),this.fakeCameras[Se].position.copy(this.position),this.isStereoOn){const e=new i(1,0,0).multiplyScalar(2*this.ipDist).applyMatrix4(this.matrix).negate();this.fakeCameras[_e].position.flow(e)}}get chaseThreeCamera(){if(void 0===this._chaseThreeCamera){const e=new i;this._chaseThreeCamera=function(){const t=(new i).setFromMatrixPosition(this.matrix),n=(new i).subVectors(t,e);this.position.flow(n),this.updateFakeCamerasPosition(),e.copy(t)}}return this._chaseThreeCamera}}var Fe=r(8351),je=r.n(Fe);class ze extends p{constructor(e,t,n={},r={}){super(e,t,n,r),this.threeRenderer.xr.enabled=!0,this.threeRenderer.xr.setReferenceSpaceType("local"),this.camera.threeCamera.layers.enable(1);const a=ye.createButton(this.threeRenderer),o=Ve(this.camera,this.camera.switchStereo);a.addEventListener("click",o,!1),document.body.appendChild(a),this._fragmentBuilders=[new C,new C],this.postProcess=void 0!==n.postProcess&&n.postProcess,this.exposure=void 0!==n.exposure?n.exposure:1}get isVRRenderer(){return!0}get xr(){return this.threeRenderer.xr}buildFragmentShader(){for(const e of[_e,Se])this._fragmentBuilders[e].addChunk(I()),Object.keys(this.globalUniforms).forEach((t=>{const n=this.globalUniforms[t].type,r=this.globalUniforms[t].value;this._fragmentBuilders[e].addUniform(t,n,r)})),this._fragmentBuilders[e].addChunk(this.constructor.shader1),this._fragmentBuilders[e].addChunk(E()),this._fragmentBuilders[e].addChunk(this.constructor.shader2),this._fragmentBuilders[e].addChunk(k()),this._fragmentBuilders[e].addChunk(j()),this.set.shader(this._fragmentBuilders[e]),this.camera.shader(this._fragmentBuilders[e],e),this.scene.shader(this._fragmentBuilders[e]),this._fragmentBuilders[e].addChunk(N()(this)),this._fragmentBuilders[e].addChunk(H()(this)),this._fragmentBuilders[e].addChunk(L()),this.postProcess?(this._fragmentBuilders[e].addUniform("exposure","float",this.exposure),this._fragmentBuilders[e].addChunk(je())):this._fragmentBuilders[e].addChunk(G()),this._fragmentBuilders[e].addChunk(O())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilders)}checkShader(e=_e){console.log(this._fragmentBuilders[e].code)}render(){this.camera.chaseThreeCamera(),this.threeRenderer.render(this.camera.threeScene,this.camera.threeCamera)}}var He=r(6224),Ae=r.n(He),Ge=r(8710),qe=r.n(Ge),Oe=r(4750),We=r.n(Oe);class Ke extends Ie{constructor(e){super(e),this.fov=void 0!==e.fov?e.fov:50}setThreeCamera(){this.threeCamera=new t.OrthographicCamera(-1,1,1,-1,0,1),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const n=new t.PlaneGeometry(2,2),r=new t.ShaderMaterial({uniforms:e.uniforms,vertexShader:Ae(),fragmentShader:e.fragmentShader}),a=new t.Mesh(n,r);this.threeScene.add(a)}static glslClass(){return qe()}static glslMapping(){return We()}}var $e=r(6354),Qe=r.n($e),Ye=r(6684),Ze=r.n(Ye);class Xe extends Be{constructor(e){super(e),this.focalLength=void 0!==e.focalLength?e.focalLength:1,this.aperture=void 0!==e.aperture?e.aperture:0}static glslClass(){return Qe()}static glslMapping(){return Ze()}}class Je{constructor(){}element(){throw new Error("Group: this method should be implemented")}shader(e){throw new Error("Group: this method should be implemented")}}class et extends Ce{constructor(e){super(e),this.fake=!0}identity(){return this}multiply(e){return this}premultiply(e){return this}invert(){return this}toIsometry(){return new n}equals(e){return!0}clone(){return new et}copy(e){return this}}var tt=r(9188),nt=r.n(tt);class rt extends Je{constructor(){super()}element(){return new et(this)}shader(e){e.addChunk(nt())}}var at=r(3148),ot=r.n(at);const st=/bool\s*(\w+)\(Point.*\)/m,it=/float\s*(\w+)\(ExtVector.*\)/m;class lt{constructor(e,n,r,a,o=void 0,s=void 0){let i;if(this.set=e,this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.jsTest=n,this.glslTest=r,this.glslTestName=void 0,i=r.match(st),!i)throw new Error("Teleportation: unable to find the name of the GLSL test");if(this.glslTestName=i[1],this.elt=a,this.inv=void 0!==o?o:a.clone().invert(),this.glslCreepCustom=void 0,this.glslCreep=void 0,this.glslCreepName=void 0,void 0!==s){if(this.glslCreepCustom=!0,this.glslCreep=s,i=s.match(it),!i)throw new Error("Teleportation: unable to find the name of the GLSL creep");this.glslCreepName=i[1]}else this.glslCreepCustom=!1,this.glslCreepName=`creep${this.uuid}`,this.glslCreep=ot()(this)}get name(){return void 0===this._name&&(this._name=`teleportation_${this.uuid}`),this._name}get usesCreepingCustom(){return this.set.usesCreeping&&this.glslCreepCustom}get usesCreepingBinary(){return this.set.creepingType===ft&&!this.glslCreepCustom}shader(e){e.addChunk(this.glslTest),this.set.usesCreeping&&e.addChunk(this.glslCreep),e.addUniform(this.elt.name,"GroupElement",this.elt),e.addUniform(this.elt.name,"GroupElement",this.inv)}}var ct=r(2311),ht=r.n(ct),ut=r(7970),dt=r.n(ut),mt=r(5103),bt=r.n(mt);const pt=0,vt=1,ft=2;class gt{constructor(e=[],t=!1,n=pt){this.teleportations=[],this.neighbors=e,this.usesNearestNeighbors=t,this.creepingType=n}get usesCreeping(){return this.creepingType===vt||this.creepingType===ft}add(e,t,n,r=void 0,a=void 0){return this.teleportations.push(new lt(this,e,t,n,r,a)),this}get group(){return 0!==this.teleportations.length?this.teleportations[0].elt.group:new rt}shader(e){this.group.shader(e),e.addChunk(ht()),e.addChunk(dt());for(const t of this.teleportations)t.shader(e);for(const t of this.neighbors)e.addUniform(t.elt.name,"GroupElement",t.elt),e.addUniform(t.inv.name,"GroupElement",t.inv);e.addChunk(bt()(this))}}class xt{constructor(){this.uuid=t.MathUtils.generateUUID().replaceAll("-","_"),this.id=void 0,this.imports=[]}get className(){return this.constructor.name}get name(){return void 0===this._name&&(this._name=`${Me(this.className)}_${this.uuid}`),this._name}get uniformType(){return""}setId(e){this.id=e.nextId,e.nextId=e.nextId+1}onAdd(e){}addImport(e){for(const e of arguments)this.imports.push(e)}static glslClass(){throw new Error("Generic: this function should be implemented")}glslInstance(){throw new Error("Generic: this function should be implemented")}shader(e){for(const t of this.imports)e.addImport(t);e.addClass(this.constructor.name,this.constructor.glslClass()),""!==this.uniformType&&e.addUniform(this.name,this.uniformType,this),e.addInstance(this.name,this.glslInstance())}}var yt=r(8266),Vt=r.n(yt);class Mt extends xt{constructor(e=void 0){super(),this.isom=void 0!==e?e:new n,this.isomInv=this.isom.clone().invert(),this.parent=void 0,this._absoluteIsom=void 0,this._absoluteIsomInv=void 0}updateAbsoluteIsom(){void 0===this._absoluteIsom&&(this._absoluteIsom=new n,this._absoluteIsomInv=new n),this.isomInv=this.isom.clone().invert(),this._absoluteIsom.copy(this.isom),this._absoluteIsomInv.copy(this.isomInv),void 0!==this.parent&&(this._absoluteIsom.premultiply(this.parent.absoluteIsom),this._absoluteIsomInv.multiply(this.parent.absoluteIsomInv))}updateData(){this.updateAbsoluteIsom()}get absoluteIsom(){return void 0===this._absoluteIsom&&this.updateAbsoluteIsom(),this._absoluteIsom}get absoluteIsomInv(){return void 0===this._absoluteIsomInv&&this.updateAbsoluteIsom(),this._absoluteIsomInv}get isShape(){return!0}get isBasicShape(){throw new Error("Shape: this method should be implemented")}get isAdvancedShape(){return!this.isBasicShape}get isGlobal(){throw new Error("Shape: this method should be implemented")}get isLocal(){return!this.isGlobal}get hasUVMap(){return!1}glslSDF(){throw new Error("Shape: this method should be implemented")}glslGradient(){return Vt()(this)}glslUVMap(){throw new Error("Shape: this method should be implemented")}glslInstance(){let e=this.glslSDF()+"\r\n"+this.glslGradient();return this.hasUVMap&&(e=e+"\r\n"+this.glslUVMap()),e}}class wt extends Mt{constructor(e=void 0){super(e)}get isBasicShape(){return!0}}class _t extends Mt{constructor(e=void 0){super(e)}get isBasicShape(){return!1}}class St extends xt{constructor(e){super(),this.maxDirs=e}get isLight(){return!0}get isGlobal(){throw new Error("Generic: this method should be implemented")}get isLocal(){return!this.isGlobal}glslDirections(){throw new Error("Light: this method should be implemented")}glslInstance(){return this.glslDirections()}}class Tt extends xt{constructor(){super(),this.lights=void 0,this.reflectivity=void 0}get isMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}get isTransparent(){return!1}onAdd(e){this.usesLight&&(this.hasOwnProperty("lights")&&void 0!==this.lights||(this.lights=e.lights))}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class Ct extends xt{constructor(){super()}get isPTMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}onAdd(e){}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class Rt{constructor(){}shader(e){throw new Error("Fog: this method need be implemented")}}var It=r(2664),Dt=r.n(It),Et=r(8778),Pt=r.n(Et);class kt extends Tt{constructor(e){super(),this.color=e}get uniformType(){return"SingleColorMaterial"}get usesNormal(){return!1}static glslClass(){return Dt()}glslRender(){return Pt()(this)}}var Ut=r(2143),Lt=r.n(Ut),Bt=r(9606),Nt=r.n(Bt),Ft=r(5363),jt=r.n(Ft);class zt extends Ct{constructor(e){super(),this.emission=void 0!==e.emission?e.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==e.volumeEmission?e.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==e.opticalDepth?e.opticalDepth:1e3,this.diffuse=void 0!==e.diffuse?e.diffuse:new t.Color(1,1,1),this.specular=void 0!==e.specular?e.specular:new t.Color(1,1,1),this.absorb=void 0!==e.absorb?e.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==e.ior?e.ior:1,this.roughness=void 0!==e.roughness?e.roughness:.2,this.reflectionChance=void 0!==e.reflectionChance?e.reflectionChance:.1,this.refractionChance=void 0!==e.refractionChance?e.refractionChance:0,this.diffuseChance=void 0!==e.diffuseChance?e.diffuseChance:.9;const n=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/n,this.refractionChance=this.refractionChance/n,this.diffuseChance=this.diffuseChance/n,this.addImport(jt())}get uniformType(){return"BasicPTMaterial"}static glslClass(){return Lt()}glslRender(){return Nt()(this)}}class Ht{constructor(e={}){this.lights=[],this.solids=[],this.nextId=0,this.fog=e.fog,this.background=void 0!==e.background?e.background:new kt(new t.Color(0,0,0)),this.ptBackground=void 0!==e.ptBackground?e.ptBackground:new zt({diffuse:new t.Color(0,0,0),specular:new t.Color(0,0,0),absorb:new t.Color(.25,.25,.25)})}_add(e){return e.setId(this),e.onAdd(this),e.isLight&&this.lights.push(e),e.isSolid&&this.solids.push(e),this}add(e){for(const e of arguments)this._add(e);return this}shader(e){3===e.useCase?this.ptBackground.shader(e):this.background.shader(e);for(const t of this.lights)3!==e.useCase&&t.shader(e);for(const t of this.solids)t.shader(e);void 0!==this.fog&&this.fog.shader(e)}}var At=r(7885),Gt=r.n(At),qt=r(5348),Ot=r.n(qt);class Wt extends Rt{constructor(e,t){super(),this.color=e,this.scattering=t}shader(e){e.addClass("ExpFog",Gt()),e.addUniform("fog","ExpFog",this),e.addChunk(Ot())}}const Kt=new gt;var $t=r(3496),Qt=r.n($t),Yt=r(6077),Zt=r.n(Yt);class Xt extends Tt{constructor(){super()}get uniformType(){return""}static glslClass(){return Qt()}glslRender(){return Zt()(this)}}var Jt=r(6045),en=r.n(Jt),tn=r(8149),nn=r.n(tn);class rn extends Tt{constructor(e={}){super(),this.color=void 0!==e.color?e.color:new t.Color(1,1,1),this.ambient=void 0!==e.ambient?e.ambient:.5,this.diffuse=void 0!==e.diffuse?e.diffuse:.4,this.specular=void 0!==e.specular?e.specular:.1;const n=this.ambient+this.diffuse+this.specular;this.ambient=this.ambient/n,this.diffuse=this.diffuse/n,this.specular=this.specular/n,this.shininess=void 0!==e.shininess?e.shininess:10,this._isReflecting=void 0!==e.isReflecting&&e.isReflecting,this.reflectivity=void 0!==e.reflectivity?e.reflectivity:new t.Color(0,0,0),this.lights=e.lights}get uniformType(){return"PhongMaterial"}get usesLight(){return!0}get isReflecting(){return this._isReflecting}static glslClass(){return en()}glslRender(){return nn()(this)}shader(e){for(const t of this.lights)t.shader(e);super.shader(e)}}var an=r(2197),on=r.n(an),sn=r(1215),ln=r.n(sn);class cn extends Tt{constructor(e,t,n,r){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"CheckerboardMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return on()}glslRender(){return ln()(this)}}var hn=r(3801),un=r.n(hn);class dn extends Tt{constructor(e,t,n,r,a){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"GraphPaperMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return un()}glslRender(){return ln()(this)}}var mn=r(7793),bn=r.n(mn),pn=r(9909),vn=r.n(pn);class fn extends Tt{constructor(){super()}get uniformType(){return""}get usesNormal(){return!1}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}static glslClass(){return bn()}glslRender(){return vn()(this)}shader(e){super.shader(e)}}var gn=r(9095),xn=r.n(gn);class yn extends Tt{constructor(e,n={}){super(),this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==n.isTransparent&&n.isTransparent}get uniformType(){return"SimpleTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return xn()}glslRender(){return ln()(this)}}var Vn=r(1220),Mn=r.n(Vn);class wn extends Tt{constructor(e,n=void 0,r={}){super(),this.quaternion=void 0!==n?n:new t.Quaternion,this.sampler=(new t.TextureLoader).load(e),this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get uniformType(){return"RotatedSphericalTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return Mn()}glslRender(){return ln()(this)}}const _n=r.p+"img/426f7657671a2811d4aa.png",Sn=r.p+"img/953837709706027f7dc2.jpg",Tn=r.p+"img/eba62d0cff4836a949b8.png",Cn=r.p+"img/26419cb1ce4138a11aa9.jpg",Rn=r.p+"img/33960f5af615e67309e5.jpg",In=r.p+"img/4b569137334e61081651.jpg";function Dn(e){let n;switch(e){case 0:default:n=_n;break;case 1:n=Sn}return new yn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function En(e){let n;switch(e){case 0:default:n=Tn;break;case 1:n=Cn}return new yn(n,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function Pn(){return new yn(Rn,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}function kn(e){return new yn(In,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}const Un=r.p+"img/eb3dc827520201070f7e.jpg",Ln=r.p+"img/ce3e4a6e1affece0e902.jpg",Bn=r.p+"img/370531b8ba6e5bd6a61e.jpg",Nn=r.p+"img/29989970ee70af555fd4.jpg",Fn=r.p+"img/1a661a5afc65c969818f.jpg",jn=r.p+"img/bb733e02d9f86b8b7433.jpg",zn=r.p+"img/f5196bbc22091948755e.jpg",Hn=r.p+"img/9e3233c13cddac942dc4.jpg",An=r.p+"img/2528cfc76a03ca71fb7f.jpg";function Gn(e,n,r=void 0){let a;switch(e){case"eye":switch(n){case 0:a=Un;break;case 1:a=Ln;break;case 2:a=Bn;break;case 3:a=Nn;break;case 4:a=Fn;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;case"hand":switch(n){case 0:a=jn;break;case 1:a=zn;break;case 2:a=Hn;break;case 3:a=An;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;default:throw new Error("WoodBallMaterial: this type of texture is not implemented.")}return new wn(a,r,{start:new t.Vector2(-Math.PI,0),scale:new t.Vector2(1/(2*Math.PI),-1/Math.PI)})}var qn=r(533),On=r.n(qn);class Wn extends Tt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0!==n.transparent&&n.transparent}get uniformType(){return"VideoTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return On()}glslRender(){return ln()(this)}}var Kn=r(2229),$n=r.n(Kn);class Qn extends Tt{constructor(e,n={}){super(),this.sampler=new t.VideoTexture(e),this.sampler.wrapS=void 0!==n.wrapS?n.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==n.wrapT?n.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==n.start?n.start.clone():new t.Vector2(0,0),this.scale=void 0!==n.scale?n.scale.clone():new t.Vector2(1,1),this.transparent=void 0===n.transparent||n.transparent}get uniformType(){return"VideoAlphaTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return $n()}glslRender(){return ln()(this)}}var Yn=r(4680),Zn=r.n(Yn);class Xn extends Tt{static REFRESH_READY=0;static REFRESH_IN_PROGRESS=1;static REFRESH_COMPLETE=2;constructor(e,n,r={}){super(),this.files=e,this.frameNumber=e.length,this.sampler=new t.Texture,this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:t.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:t.RepeatWrapping,this.sampler.magFilter=t.LinearFilter,this.sampler.minFilter=t.LinearFilter,this.start=void 0!==r.start?r.start.clone():new t.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new t.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent,this.loop=void 0!==r.loop&&r.loop,this.callback=void 0!==r.callback?r.callback:function(){},this.fps=void 0!==r.fps&&r.fps,this.imageStatus=Xn.REFRESH_READY,this.imageLoader=new t.ImageLoader,this.imageLoader.setPath(n),this.currentFrame=0}nextFrameIndex(e){return this.loop?(e+1)%this.frameNumber:Math.min(e+1,this.frameNumber-1)}nextFrame(){if(this.imageStatus===Xn.REFRESH_READY){this.imageStatus=Xn.REFRESH_IN_PROGRESS;const e=this.files[this.currentFrame];this.currentFrame=this.nextFrameIndex(this.currentFrame);const t=this;this.imageLoader.load(e,(function(e){t.sampler.image=e,t.sampler.needsUpdate=!0,t.imageStatus=Xn.REFRESH_COMPLETE}),void 0,(function(){console.log(`Cannot load the file ${e}`)}))}}get uniformType(){return"VideoFrameTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return Zn()}glslRender(){return ln()(this)}}var Jn=r(3081),er=r.n(Jn);class tr extends Tt{constructor(e,n,r,a=void 0){super(),this.dir1=e,this.dir2=n;const o=void 0!==a?a:[.5,1,1,.5];let s=0;const i=[];for(let e=0;e<4;e++)void 0!==o[e]&&(s+=o[e]),i[e]=s;for(let e=0;e<4;e++)i[e]=i[e]/s;this.lengths=new t.Vector4(...i);let l=new t.Color(1,1,1);this.color0=void 0!==r[0]?r[0]:l.clone(),l=this.color0,this.color1=void 0!==r[1]?r[1]:l.clone(),l=this.color1,this.color2=void 0!==r[2]?r[2]:l.clone(),l=this.color2,this.color3=void 0!==r[3]?r[3]:l.clone()}get uniformType(){return"SquaresMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return er()}glslRender(){return ln()(this)}}var nr=r(9835),rr=r.n(nr);class ar extends Tt{constructor(e,n,r=void 0){super(),this.dir=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"StripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return rr()}glslRender(){return ln()(this)}}var or=r(7685),sr=r.n(or);class ir extends Tt{constructor(e,n,r=void 0){super(),this.totalWidth=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new t.Vector4(...s);let i=new t.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:i.clone(),i=this.color0,this.color1=void 0!==n[1]?n[1]:i.clone(),i=this.color1,this.color2=void 0!==n[2]?n[2]:i.clone(),i=this.color2,this.color3=void 0!==n[3]?n[3]:i.clone()}get uniformType(){return"HypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return sr()}glslRender(){return ln()(this)}}var lr=r(1917),cr=r.n(lr);class hr extends Tt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"EquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return cr()}glslRender(){return ln()(this)}}var ur=r(4743),dr=r.n(ur);class mr extends Tt{constructor(e,t,n,r){super(),this.distance=e,this.width=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"EquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return dr()}glslRender(){return ln()(this)}}var br=r(4566),pr=r.n(br);class vr extends Tt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"ImprovedEquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return pr()}glslRender(){return ln()(this)}}var fr=r(1650),gr=r.n(fr);class xr extends Tt{constructor(e,n,r,a,o,s=void 0){super(),this.distance=e,this.halfWidth=n,this.fadingAmplitude=r,this.stripColor=a,this.bgColor=o,this.quaternion=void 0!==s?s:new t.Quaternion}get rotation(){return(new t.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"ImprovedEquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return gr()}glslRender(){return ln()(this)}}var yr=r(5836),Vr=r.n(yr),Mr=r(3838),wr=r.n(Mr),_r=r(472),Sr=r.n(_r),Tr=r(8204),Cr=r.n(Tr),Rr=r(7660),Ir=r.n(Rr);class Dr extends Tt{constructor(e,n={}){super(),this.material=e,this.ambient=void 0!==n.ambient?n.ambient:.5,this.diffuse=void 0!==n.diffuse?n.diffuse:.5,this.specular=void 0!==n.specular?n.specular:.5,this.shininess=void 0!==n.shininess?n.shininess:10,this._isReflecting=void 0!==n.isReflecting&&n.isReflecting,this.reflectivity=void 0!==n.reflectivity?n.reflectivity:new t.Vector3(0,0,0),this.lights=n.lights}get uniformType(){return"PhongWrapMaterial"}static glslClass(){return Vr()}get usesNormal(){return!0}get usesUVMap(){return this.material.usesUVMap}get usesLight(){return!0}get isReflecting(){return this._isReflecting}glslRender(){return this.material.usesNormal?this.material.usesUVMap?Ir()(this):Sr()(this):this.material.usesUVMap?Cr()(this):wr()(this)}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e);for(const t of this.lights)t.shader(e);super.shader(e)}}function Er(e,t={}){return new Dr(e,t)}var Pr=r(3048),kr=r.n(Pr),Ur=r(8474),Lr=r.n(Ur),Br=r(5506),Nr=r.n(Br),Fr=r(3045),jr=r.n(Fr),zr=r(7397),Hr=r.n(zr);class Ar extends Tt{constructor(e,t){super(),this.defaultMat=e,this.highlightMat=t,this.isHighlightOn=!1}get uniformType(){return"HighlightWrapMaterial"}static glslClass(){return kr()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Hr()(this):Nr()(this):this.usesUVMap?jr()(this):Lr()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function Gr(e,t){return new Ar(e,t)}var qr=r(2278),Or=r.n(qr),Wr=r(8906),Kr=r.n(Wr),$r=r(1998),Qr=r.n($r),Yr=r(4261),Zr=r.n(Yr),Xr=r(699),Jr=r.n(Xr);class ea extends Tt{constructor(e,t,n){super(),this.defaultMat=e,this.highlightMat=t,this.cellBoost=n}get uniformType(){return"HighlightLocalWrapMaterial"}static glslClass(){return Or()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Jr()(this):Qr()(this):this.usesUVMap?Zr()(this):Kr()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function ta(e,t,n){return new ea(e,t,n)}var na=r(5698),ra=r.n(na),aa=r(8402),oa=r.n(aa),sa=r(6158),ia=r.n(sa),la=r(2332),ca=r.n(la),ha=r(4146),ua=r.n(ha);class da extends Tt{constructor(e,n,r=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==r?r:5,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=we(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionWrapMaterial"}static glslClass(){return ra()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?ua()(this):ia()(this):this.usesUVMap?ca()(this):oa()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function ma(e,t,n){return new da(e,t,n)}var ba=r(1888),pa=r.n(ba),va=r(5377),fa=r.n(va),ga=r(9441),xa=r.n(ga),ya=r(6766),Va=r.n(ya),Ma=r(9245),wa=r.n(Ma);class _a extends Tt{constructor(e,n,r,a=void 0){super(),this.mat0=e,this.mat1=n,this.duration=void 0!==a?a:5,this.cellBoost=r,this._clock=new t.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=we(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionLocalWrapMaterial"}static glslClass(){return pa()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?wa()(this):xa()(this):this.usesUVMap?Va()(this):fa()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function Sa(e,t,n,r){return new _a(e,t,n,r)}var Ta=r(7198),Ca=r.n(Ta),Ra=r(1202),Ia=r.n(Ra),Da=r(2330),Ea=r.n(Da),Pa=r(588),ka=r.n(Pa),Ua=r(9040),La=r.n(Ua),Ba=r(1365),Na=r.n(Ba);class Fa extends Ct{constructor(e,n){super(),this.material=e,this.emission=void 0!==n.emission?n.emission:new t.Color(0,0,0),this.volumeEmission=void 0!==n.volumeEmission?n.volumeEmission:new t.Color(0,0,0),this.opticalDepth=void 0!==n.opticalDepth?n.opticalDepth:0,this.specular=void 0!==n.specular?n.specular:new t.Color(1,1,1),this.absorb=void 0!==n.absorb?n.absorb:new t.Color(.1,.1,.1),this.ior=void 0!==n.ior?n.ior:1,this.roughness=void 0!==n.roughness?n.roughness:.2,this.reflectionChance=void 0!==n.reflectionChance?n.reflectionChance:.1,this.refractionChance=void 0!==n.refractionChance?n.refractionChance:0,this.diffuseChance=void 0!==n.diffuseChance?n.diffuseChance:.9;const r=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/r,this.refractionChance=this.refractionChance/r,this.diffuseChance=this.diffuseChance/r,this.addImport(jt())}get uniformType(){return"PathTracerWrapMaterial"}static glslClass(){return Ca()}get usesUVMap(){return this.material.usesUVMap}glslRender(){let e="";return e+=Ia()(this),this.material.usesNormal?this.material.usesUVMap?e+=ka()(this):e+=La()(this):this.material.usesUVMap?e+=Na()(this):e+=Ea()(this),e}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e),super.shader(e)}}function ja(e,t={}){return new Fa(e,t)}var za=r(7939),Ha=r.n(za),Aa=r(6142),Ga=r.n(Aa),qa=r(7260),Oa=r.n(qa);class Wa extends _t{constructor(e){super(),this.shape=e,this.shape.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData()}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Ha()(this)}glslGradient(){return Ga()(this)}glslUVMap(){return Oa()(this)}setId(e){this.shape.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),super.onAdd(e)}shader(e){this.shape.shader(e),super.shader(e)}}function Ka(e){return new Wa(e)}var $a=r(2093),Qa=r.n($a),Ya=r(2076),Za=r.n(Ya),Xa=r(3335),Ja=r.n(Xa),eo=r(6428),to=r.n(eo),no=r(6861),ro=r.n(no),ao=r(2905),oo=r.n(ao),so=r(7333),io=r.n(so);const lo=1;class co extends _t{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("IntersectionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.maxType=void 0!==n.maxType?n.maxType:0,this.maxCoeff=0,this.maxType===lo)this.addImport(Qa()),this.maxCoeff=void 0!==n.maxCoeff?n.maxCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"IntersectionShape"}static glslClass(){return io()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.maxType===lo?to()(this):Za()(this)}glslGradient(){return this.maxType===lo?ro()(this):Ja()(this)}glslUVMap(){return oo()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function ho(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new co(e,arguments[r],t));return e}var uo=r(5442),mo=r.n(uo),bo=r(3908),po=r.n(bo),vo=r(7762),fo=r.n(vo),go=r(7500),xo=r.n(go),yo=r(3238),Vo=r.n(yo),Mo=r(519),wo=r.n(Mo),_o=r(8655),So=r.n(_o);const To=1;class Co extends _t{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("UnionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.minType=void 0!==n.minType?n.minType:0,this.minCoeff=0,this.minType===To)this.addImport(mo()),this.minCoeff=void 0!==n.minCoeff?n.minCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"UnionShape"}static glslClass(){return wo()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.minType===To?Vo()(this):po()(this)}glslGradient(){return this.minType===To?So()(this):fo()(this)}glslUVMap(){return xo()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function Ro(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new Co(e,arguments[r],t));return e}var Io=r(3105),Do=r.n(Io),Eo=r(6242),Po=r.n(Eo),ko=r(9338),Uo=r.n(ko);class Lo extends _t{constructor(e,t){if(e.isGlobal!==t.isGlobal)throw new Error("WrapShape: the two shapes should be both local or both global");super(),this.wrap=e,this.shape=t,this.shape.parent=this,this.wrap.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom(),this.wrap.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData(),this.wrap.updateData()}get isWrapShape(){return!0}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Do()(this)}glslGradient(){return Po()(this)}glslUVMap(){return Uo()(this)}setId(e){this.wrap.setId(e),this.shape.setId(e),super.setId(e)}onAdd(e){this.wrap.onAdd(e),this.shape.onAdd(e),super.onAdd(e)}shader(e){this.wrap.shader(e),this.shape.shader(e),super.shader(e)}}function Bo(e,t){return new Lo(e,t)}const No={KeyA:"yawLeft",KeyD:"yawRight",KeyW:"pitchUp",KeyS:"pitchDown",KeyQ:"rollLeft",KeyE:"rollRight",ArrowUp:"forward",ArrowDown:"back",ArrowLeft:"left",ArrowRight:"right",Quote:"up",Slash:"down"};class Fo extends t.EventDispatcher{constructor(e){super(),this.camera=e,this.movementSpeed=.5,this.rollSpeed=.8,this._moveState={up:0,down:0,left:0,right:0,forward:0,back:0,pitchUp:0,pitchDown:0,yawLeft:0,yawRight:0,rollLeft:0,rollRight:0},this._moveVector=new i(0,0,0),this._rotationVector=new i(0,0,0),this._onKeyDown=Ve(this,this.onKeyDown),this._onKeyUp=Ve(this,this.onKeyUp),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}pause(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)}restore(){window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}onKeyDown(e){if(e.code in No){const t=No[e.code];this._moveState[t]=1,this.updateMovementVector(),this.updateRotationVector()}}onKeyUp(e){if(e.code in No){const t=No[e.code];this._moveState[t]=0,this.updateMovementVector(),this.updateRotationVector()}}updateMovementVector(){this._moveVector.x=-this._moveState.left+this._moveState.right,this._moveVector.y=-this._moveState.down+this._moveState.up,this._moveVector.z=-this._moveState.forward+this._moveState.back}updateRotationVector(){this._rotationVector.x=-this._moveState.pitchDown+this._moveState.pitchUp,this._rotationVector.y=-this._moveState.yawRight+this._moveState.yawLeft,this._rotationVector.z=-this._moveState.rollRight+this._moveState.rollLeft}update(e){const n=this._moveVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix);this.camera.position.flow(n);const r=this._rotationVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix),a=new t.Quaternion(r.x,r.y,r.z,1).normalize();this.camera.position.applyQuaternion(a)}}class jo{constructor(e="i"){this.action=void 0,this.key=e;const t=Ve(this,this.onKeyDown);window.addEventListener("keydown",t,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.action&&this.action()}}class zo{constructor(e,t,n){this.controller=e,this.camera=t,this.solid=n,this._isSelecting=!1,this._isSqueezing=!1;const r=Ve(this,this.onSelectStart),a=Ve(this,this.onSelectEnd),o=Ve(this,this.onSqueezeStart),s=Ve(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",r),this.controller.addEventListener("selectend",a),this.controller.addEventListener("squeezestart",o),this.controller.addEventListener("squeezeend",s)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}chase(e){this.solid.isRendered=this._isSelecting;const n=(new i).setFromMatrixPosition(this.controller.matrixWorld);let r=new i;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[_e].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[Se].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),s=this.camera.position.clone().fakeDiffExpMap(o);this.solid.isom.copy(s.globalBoost),this.solid.isom.matrix.multiply(s.facing),this.solid.updateData()}}class Ho{constructor(e="p"){this.actionKeyDown=void 0,this.actionKeyUp=void 0,this.key=e;const t=Ve(this,this.onKeyDown),n=Ve(this,this.onKeyUp);window.addEventListener("keydown",t,!1),window.addEventListener("keyup",n,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.actionKeyDown&&this.actionKeyDown()}onKeyUp(e){e.key===this.key&&void 0!==this.actionKeyUp&&this.actionKeyUp()}}class Ao{constructor(e,n,r,a){this.controller=e,this.camera=n,this.solids=r,this.speed=a,this._status=0,this._nextBullet=0,this._clock=new t.Clock;const o=Ve(this,this.onSelectStart),s=Ve(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){0===this._status&&(this._status=1)}onSelectEnd(){}shoot(e){const t=this.solids[this._nextBullet];t.bulletData={time:this._clock.getElapsedTime(),position:e},t.isRendered=!0,this._nextBullet=(this._nextBullet+1)%this.solids.length}updateBullet(e){const t=this.solids[e];if(t.hasOwnProperty("bulletData")){const e=this._clock.getElapsedTime()-t.bulletData.time,n=t.bulletData.position.clone().flow(new i(0,0,-this.speed*e));t.isom.copy(n.boost),t.updateData()}}updateAllBullets(){for(let e=0;e<this.solids.length;e++)this.updateBullet(e)}update(e){if(1===this._status){const n=(new i).setFromMatrixPosition(this.controller.matrixWorld);let r=new i;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[_e].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[Se].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),s=this.camera.position.clone().fakeDiffExpMap(o);this.shoot(s.globalPosition),this._status=0}this.updateAllBullets()}}class Go{constructor(e="p",t=2,n=0){this.key=e,this.stateNumber=t,this.state=n,this.justChanged=!1;const r=Ve(this,this.onKeyDown);window.addEventListener("keydown",r,!1)}onKeyDown(e){e.key===this.key&&(this.state=(this.state+1)%this.stateNumber,this.justChanged=!0)}}class qo extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this._isSelecting=!1,this._isSqueezing=!1;const n=Ve(this,this.onSelectStart),r=Ve(this,this.onSelectEnd),a=Ve(this,this.onSqueezeStart),o=Ve(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}get update(){if(void 0===this._update){const e=10,n=new i,r=new i;let a=[],o=0,s=!1;this._update=function(l){const c=new i;if(this.controller.getWorldDirection(c),c.normalize().multiplyScalar(1/e),r.add(c),s&&r.sub(a[o]),a[o]=c,s&&this._isSelecting){const e=r.clone().normalize(),a=n.clone().normalize(),o=(new t.Quaternion).setFromUnitVectors(e,a).normalize();this.position.applyQuaternion(o)}n.copy(r),o=(o+1)%e,0===o&&(s=!0)}}return this._update}}class Oo extends t.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this.movementSpeed=.5,this._isSelecting=!1,this._isSqueezing=!1;const n=Ve(this,this.onSelectStart),r=Ve(this,this.onSelectEnd),a=Ve(this,this.onSqueezeStart),o=Ve(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}update(e){if(this._isSelecting){const t=new i;this.controller.getWorldDirection(t),t.normalize().multiplyScalar(-this.movementSpeed*e),this.position.flow(t)}}}class Wo{constructor(e,t,n){this.controller=e,this.camera=t,this.light=n}chase(e){const n=(new i).setFromMatrixPosition(this.controller.matrixWorld);let r=new i;if(this.camera.isStereoOn){const n=e.getCamera(this.camera.threeCamera).cameras,a=(new t.Vector3).setFromMatrixPosition(n[_e].matrixWorld),o=(new t.Vector3).setFromMatrixPosition(n[Se].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=n.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),l=this.camera.position.clone().fakeDiffExpMap(o);this.light.position=(new s).applyIsometry(l.globalBoost)}}class Ko{constructor(e,t,n=!1,r=!1,a=void 0){if(this.position=e,this.controller=t,this._reset=0,this._alignFacing=n,this._snap=r,this._camera=a,this._alignFacing&&void 0===a)throw new Error("VRControlsReset.constructor, the camera is needed when the alignFacing option is on");const o=Ve(this,this.onSelectStart),s=Ve(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){this._reset=1}onSelectEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0}}}class $o{constructor(e,t,n,r=!1,a=!1,o=void 0){if(this.position=e,this.targetPosition=t,this.controller=n,this._reset=0,this._alignFacing=r,this._snap=a,this._camera=o,this._alignFacing&&void 0===o)throw new Error("AdvancedResetVRControls.constructor, the camera is needed when the alignFacing option is on");const s=Ve(this,this.onSqueezeStart),i=Ve(this,this.onSqueezeEnd);this.controller.addEventListener("squeezestart",s),this.controller.addEventListener("squeezeend",i)}onSqueezeStart(){this._reset=1}onSqueezeEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0,this.position.local.boost.copy(this.targetPosition.boost),this.position.local.quaternion.premultiply(this.targetPosition.quaternion)}}}var Qo=r(6947),Yo=r.n(Qo);class Zo extends Y{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return Yo()}}var Xo=r(4024),Jo=r.n(Xo);class es extends Y{constructor(){super()}fragmentShader(){return Jo()}}class ts{constructor(e,t=0,n=0){this.ring=e,this.a=t,this.b=n,this.reduce()}reduce(){return this.a=Math.round(this.a),this.b=Math.round(this.b),this}negate(){return this.a=-this.a,this.b=-this.b,this}multiply(e){const t=this.a,n=this.b;return this.a=t*e.a+this.ring.d*n*e.b,this.b=t*e.b+n*e.a,this.reduce()}add(e){return this.a=this.a+e.a,this.b=this.b+e.b,this.reduce()}sub(e){return this.a=this.a-e.a,this.b=this.b-e.b,this.reduce()}sum(){this.copy(this.ring.zero);for(const e of arguments)this.add(e);return this}product(){this.copy(this.ring.one);for(const e of arguments)this.multiply(e);return this}addProduct(){const e=new ts(this.ring).product(...arguments);return this.add(e),this}subProduct(){const e=new ts(this.ring).product(...arguments);return this.sub(e),this}toNumber(){return this.a+this.b*Math.sqrt(this.ring.d)}equals(e){return this.a===e.a&&this.b===e.b}isZero(){return 0===this.a&&0===this.b}clone(){const e=new ts(this.ring);return e.a=this.a,e.b=this.b,e}copy(e){return this.a=e.a,this.b=e.b,this}toLog(){return`${this.a} + ${this.b} _rD`}}var ns=r(5688),rs=r.n(ns);class as{constructor(e){this.ring=e,this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()]}get isQuadRingMatrix4(){return!0}get a(){const e=this.toArray().map((e=>e.a));return(new t.Matrix4).fromArray(e)}get b(){const e=this.toArray().map((e=>e.b));return(new t.Matrix4).fromArray(e)}getEntry(e,t){return this.elements[4*t+e]}setEntry(e,t,n){return this.elements[4*t+e].copy(n),this}set(e,t,n,r,a,o,s,i,l,c,h,u,d,m,b,p){for(let e=0;e<4;e++)for(let t=0;t<4;t++)this.setEntry(e,t,arguments[4*e+t]);return this}identity(){return this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()],this}multiplyMatrices(e,t){for(let n=0;n<4;n++)for(let r=0;r<4;r++){this.setEntry(n,r,this.ring.zero);for(let a=0;a<4;a++)this.getEntry(n,r).addProduct(e.getEntry(n,a),t.getEntry(a,r))}return this}multiply(e){return this.multiplyMatrices(this.clone(),e)}premultiply(e){return this.multiplyMatrices(e,this.clone())}multiplyScalar(e){for(let t=0;t<16;t++)this.elements[t].multiply(e);return this}transpose(){const e=this.elements;let t=this.ring.element();return t.copy(e[1]),e[1].copy(e[4]),e[4].copy(t),t.copy(e[2]),e[2].copy(e[8]),e[8].copy(t),t.copy(e[6]),e[6].copy(e[9]),e[9].copy(t),t.copy(e[3]),e[3].copy(e[12]),e[12].copy(t),t.copy(e[7]),e[7].copy(e[13]),e[13].copy(t),t.copy(e[11]),e[11].copy(e[14]),e[14].copy(t),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],a=e[3],o=e[4],s=e[5],i=e[6],l=e[7],c=e[8],h=e[9],u=e[10],d=e[11],m=e[12],b=e[13],p=e[14],v=e[15];return e[0]=this.ring.element().addProduct(h,p,l).subProduct(b,u,l).addProduct(b,i,d).subProduct(s,p,d).subProduct(h,i,v).addProduct(s,u,v),e[1]=this.ring.element().addProduct(b,u,a).subProduct(h,p,a).subProduct(b,r,d).addProduct(n,p,d).addProduct(h,r,v).subProduct(n,u,v),e[2]=this.ring.element().addProduct(s,p,a).subProduct(b,i,a).addProduct(b,r,l).subProduct(n,p,l).subProduct(s,r,v).addProduct(n,i,v),e[3]=this.ring.element().addProduct(h,i,a).subProduct(s,u,a).subProduct(h,r,l).addProduct(n,u,l).addProduct(s,r,d).subProduct(n,i,d),e[4]=this.ring.element().addProduct(m,u,l).subProduct(c,p,l).subProduct(m,i,d).addProduct(o,p,d).addProduct(c,i,v).subProduct(o,u,v),e[5]=this.ring.element().addProduct(c,p,a).subProduct(m,u,a).addProduct(m,r,d).subProduct(t,p,d).subProduct(c,r,v).addProduct(t,u,v),e[6]=this.ring.element().addProduct(m,i,a).subProduct(o,p,a).subProduct(m,r,l).addProduct(t,p,l).addProduct(o,r,v).subProduct(t,i,v),e[7]=this.ring.element().addProduct(o,u,a).subProduct(c,i,a).addProduct(c,r,l).subProduct(t,u,l).subProduct(o,r,d).addProduct(t,i,d),e[8]=this.ring.element().addProduct(c,b,l).subProduct(m,h,l).addProduct(m,s,d).subProduct(o,b,d).subProduct(c,s,v).addProduct(o,h,v),e[9]=this.ring.element().addProduct(m,h,a).subProduct(c,b,a).subProduct(m,n,d).addProduct(t,b,d).addProduct(c,n,v).subProduct(t,h,v),e[10]=this.ring.element().addProduct(o,b,a).subProduct(m,s,a).addProduct(m,n,l).subProduct(t,b,l).subProduct(o,n,v).addProduct(t,s,v),e[11]=this.ring.element().addProduct(c,s,a).subProduct(o,h,a).subProduct(c,n,l).addProduct(t,h,l).addProduct(o,n,d).subProduct(t,s,d),e[12]=this.ring.element().addProduct(m,h,i).subProduct(c,b,i).subProduct(m,s,u).addProduct(o,b,u).addProduct(c,s,p).subProduct(o,h,p),e[13]=this.ring.element().addProduct(c,b,r).subProduct(m,h,r).addProduct(m,n,u).subProduct(t,b,u).subProduct(c,n,p).addProduct(t,h,p),e[14]=this.ring.element().addProduct(m,s,r).subProduct(o,b,r).subProduct(m,n,i).addProduct(t,b,i).addProduct(o,n,p).subProduct(t,s,p),e[15]=this.ring.element().addProduct(o,h,r).subProduct(c,s,r).addProduct(c,n,i).subProduct(t,h,i).subProduct(o,n,u).addProduct(t,s,u),this}equals(e){for(let t=0;t<16;t++)if(!this.elements[t].equals(e.elements[t]))return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n].copy(e[n+t]);return this}toArray(e=[],t=0){const n=this.elements;for(let r=0;r<16;r++)e[t+r]=n[r].clone();return e}toMatrix4(){const e=this.toArray().map((e=>e.toNumber()));return(new t.Matrix4).fromArray(e)}clone(){return new as(this.ring).fromArray(this.elements)}copy(e){return this.fromArray(e.elements)}toLog(){return this.toMatrix4().toLog()}}class os{constructor(e){this.d=e}element(e=0,t=0){return new ts(this,e,t)}matrix4(){return new as(this)}get one(){return new ts(this,1)}get zero(){return new ts(this,0)}shader(e){e.addChunk(rs()),e.addConstant("QUAD_RING_D","int",this.d)}}class ss{constructor(){this.elements=[1,0,0,1]}set(e,t,n,r){return this.elements=[e,n,t,r],this}identity(){return this.set(1,0,0,1),this}multplyMatrices(e,t){const[n,r,a,o]=e.elements,[s,i,l,c]=t.elements;return this.elements=[n*s+a*i,r*s+o*i,n*l+a*c,r*l+o*c],this}multiply(e){return this.multplyMatrices(this,e)}premultiply(e){return this.multplyMatrices(e,this)}power(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}}determinant(){const[e,t,n,r]=this.elements;return e*r-n*t}invert(){const[e,t,n,r]=this.elements,a=this.determinant();return this.elements=[r/a,-t/a,-n/a,e/a],this}clone(){const e=new ss;for(let t=0;t<4;t++)e.elements[t]=this.elements[t];return e}copy(e){for(let t=0;t<4;t++)this.elements[t]=e.elements[t];return this}equals(e){for(let t=0;t<4;t++)if(this.elements[t]!==e.elements[t])return!1;return!0}}class is extends Ce{constructor(e){super(e),this.isom=new n}identity(){return this.isom.identity(),this}multiply(e){return this.isom.multiply(e.isom),this}premultiply(e){return this.isom.premultiply(e.isom),this}invert(){return this.isom.invert(),this}toIsometry(){return this.isom.clone()}equals(e){return this.isom.equals(e.isom)}clone(){const e=new is;return e.isom.copy(this.isom),e}copy(e){return this.isom.copy(e.isom),this}}var ls=r(6097),cs=r.n(ls);class hs extends Je{constructor(){super()}element(){return new is(this)}shader(e){e.addChunk(cs())}}const us=new hs,ds=2*Math.PI;const ms=`//\nbool testWp(Point p){\n    return p.fiber > ${.5*ds};\n}\n`;const bs=`//\nbool testWn(Point p){\n    return p.fiber < -${.5*ds};\n}\n`,ps=us.element(),vs=us.element();ps.isom.makeTranslationFromDir(new i(0,0,-ds)),vs.isom.makeTranslationFromDir(new i(0,0,ds));const fs=(new gt).add((function(e){return e.fiber>.5*ds}),ms,ps,vs).add((function(e){return e.fiber<-.5*ds}),bs,vs,ps),gs=new hs,xs=Math.sqrt(2),ys=Math.sqrt(xs+1),Vs=xs*Math.sqrt(xs-1),Ms=2*Math.PI,ws=new t.Vector4(1,0,0,0),_s=new t.Vector4(0,1,0,0),Ss=new t.Vector4(.5*xs,.5*xs,0,0),Ts=new t.Vector4(-.5*xs,.5*xs,0,0);const Cs=`//\nbool testSideHP(Point p){\n    vec4 nh = vec4(1, 0, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nh) > ${Vs};\n}\n`;const Rs=`//\nbool testSideHN(Point p){\n    vec4 nh = vec4(1, 0, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nh) < -${Vs};\n}\n`;const Is=`//\nbool testSideVP(Point p){\n    vec4 nv = vec4(0, 1, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nv) > ${Vs};\n}\n`;const Ds=`//\nbool testSideVN(Point p){\n    vec4 nv = vec4(0, 1, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nv) < -${Vs};\n}\n`;const Es=`//\nbool testSideD1P(Point p){\n    vec4 nd1 = 0.5 * ${xs} * vec4(1, 1, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nd1) > ${Vs};\n}\n`;const Ps=`//\nbool testSideD1N(Point p){\n    vec4 nd1 = 0.5 * ${xs} * vec4(1, 1, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nd1) < -${Vs};\n}\n`;const ks=`//\nbool testSideD2P(Point p){\n    vec4 nd2 = 0.5 * ${xs} * vec4(-1, 1, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nd2) > ${Vs};\n}\n`;const Us=`//\nbool testSideD2N(Point p){\n    vec4 nd2 = 0.5 * ${xs} * vec4(-1, 1, 0, 0);\n    vec4 klein = toKlein(p);\n    return dot(klein, nd2) < -${Vs};\n}\n`;const Ls=`//\nbool testWp(Point p){\n    return p.fiber > ${.5*Ms};\n}\n`;const Bs=`//\nbool testWn(Point p){\n    return p.fiber < -${.5*Ms};\n}\n`,Ns=gs.element(),Fs=gs.element(),js=gs.element(),zs=gs.element(),Hs=gs.element(),As=gs.element(),Gs=gs.element(),qs=gs.element(),Os=gs.element(),Ws=gs.element(),Ks=new s,$s=new s,Qs=new s,Ys=new s;Ks.proj.set(.5*xs+1,.5*xs+1,ys,-ys),Ks.fiber=.5*Math.PI,$s.proj.set(.5*xs+1,.5*xs+1,xs*ys,0),$s.fiber=.5*Math.PI,Qs.proj.set(.5*xs+1,.5*xs+1,-ys,ys),Qs.fiber=.5*Math.PI,Ys.proj.set(.5*xs+1,.5*xs+1,-xs*ys,0),Ys.fiber=.5*Math.PI,Ns.isom.makeTranslation(Ks),Fs.isom.makeInvTranslation(Ks),js.isom.makeTranslation($s),zs.isom.makeInvTranslation($s),Hs.isom.makeTranslation(Qs),As.isom.makeInvTranslation(Qs),Gs.isom.makeTranslation(Ys),qs.isom.makeInvTranslation(Ys),Os.isom.makeTranslationFromDir(new i(0,0,-Ms)),Ws.isom.makeTranslationFromDir(new i(0,0,Ms));const Zs=(new gt).add((function(e){return e.toKlein().dot(ws)>Vs}),Cs,Fs,Ns).add((function(e){return e.toKlein().dot(ws)<-Vs}),Rs,As,Hs).add((function(e){return e.toKlein().dot(_s)>Vs}),Is,Ns,Fs).add((function(e){return e.toKlein().dot(_s)<-Vs}),Ds,Hs,As).add((function(e){return e.toKlein().dot(Ss)>Vs}),Es,zs,js).add((function(e){return e.toKlein().dot(Ss)<-Vs}),Ps,qs,Gs).add((function(e){return e.toKlein().dot(Ts)>Vs}),ks,js,zs).add((function(e){return e.toKlein().dot(Ts)<-Vs}),Us,Gs,qs).add((function(e){return e.fiber>.5*Ms}),Ls,Os,Ws).add((function(e){return e.fiber<-.5*Ms}),Bs,Ws,Os),Xs=new hs,Js=Math.sqrt(2),ei=Math.sqrt(3),ti=2*Math.PI,ni=Js/ei,ri=new t.Vector4(1,1,0,0),ai=new t.Vector4(-1,1,0,0);const oi=`//\n                        bool testSide1P(Point p) {\n                            vec4 n1 = vec4(1, 1, 0, 0);\n                            vec4 klein = toKlein(p);\n                            return dot(klein, n1) > ${ni};\n                        }\n`;const si=`//\n                        bool testSide1N(Point p) {\n                            vec4 n1 = vec4(1, 1, 0, 0);\n                            vec4 klein = toKlein(p);\n                            return dot(klein, n1) < -${ni};\n                        }\n`;const ii=`//\n                        bool testSide2P(Point p) {\n                            vec4 n2 = vec4(-1, 1, 0, 0);\n                            vec4 klein = toKlein(p);\n                            return dot(klein, n2) > ${ni};\n                        }\n`;const li=`//\n                        bool testSide2N(Point p) {\n                            vec4 n2 = vec4(-1, 1, 0, 0);\n                            vec4 klein = toKlein(p);\n                            return dot(klein, n2) < -${ni};\n                        }\n`;const ci=`//\n                    bool testWp(Point p) {\n                        return p.fiber > ${.5*ti};\n                    }\n`;const hi=`//\n                    bool testWn(Point p) {\n                        return p.fiber < -${.5*ti};\n                    }\n`,ui=Xs.element(),di=Xs.element(),mi=Xs.element(),bi=Xs.element(),pi=Xs.element(),vi=Xs.element(),fi=new s,gi=new s;fi.proj.set(.5*ei,.5*ei,.5*Js,0),fi.fiber=.5*Math.PI,gi.proj.set(.5*ei,.5*ei,-.5*Js,0),gi.fiber=.5*Math.PI,ui.isom.makeTranslation(fi),di.isom.makeInvTranslation(fi),mi.isom.makeTranslation(gi),bi.isom.makeInvTranslation(gi),pi.isom.makeTranslation((new s).set(-1,0,0,0,-ti)),vi.isom.makeTranslation((new s).set(-1,0,0,0,ti));const xi=(new gt).add((function(e){return e.toKlein().dot(ai)>ni}),ii,ui,di).add((function(e){return e.toKlein().dot(ri)>ni}),oi,di,ui).add((function(e){return e.toKlein().dot(ai)<-ni}),li,mi,bi).add((function(e){return e.toKlein().dot(ri)<-ni}),si,bi,mi).add((function(e){return e.fiber>.5*ti}),ci,pi,vi).add((function(e){return e.fiber<-.5*ti}),hi,vi,pi);var yi=r(2173),Vi=r.n(yi),Mi=r(7577),wi=r.n(Mi);class _i extends St{constructor(e,t,n){super(1),this.color=e,this.intensity=t,this.direction=n}get isGlobal(){return!0}get uniformType(){return"ConstDirLight"}static glslClass(){return Vi()}glslDirections(){return wi()(this)}}var Si=r(7158),Ti=r.n(Si),Ci=r(2927),Ri=r.n(Ci),Ii=r(3876),Di=r.n(Ii),Ei=r(8442),Pi=r.n(Ei);class ki extends St{constructor(e,t,n=1){super(1),this.color=e,this.intensity=n,this.position=t,this.addImport(Ri(),Ti(),Di())}get isGlobal(){return!0}get uniformType(){return"LocalFakePointLight"}static glslClass(){return Pi()}glslDirections(){return wi()(this)}}var Ui=r(1855),Li=r.n(Ui);class Bi extends Tt{constructor(e,t){super(),this.mainColor=e,this.weight=t}get uniformType(){return"VaryingColorMaterial"}get usesNormal(){return!1}static glslClass(){return Li()}glslRender(){return Pt()(this)}}var Ni=r(7538),Fi=r.n(Ni);class ji extends Tt{constructor(e,t,n,r,a){super(),this.mainColor=e,this.accent1=t,this.accent2=n,this.accent3=r,this.grid=null!=a&&a}get uniformType(){return"MultiColorMaterial"}get usesNormal(){return!1}static glslClass(){return Fi()}glslRender(){return Pt()(this)}}var zi=r(3931),Hi=r.n(zi),Ai=r(3707),Gi=r.n(Ai);class qi extends wt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else if(e.isPoint)r.makeTranslation(e);else{if(!e.isVector)throw new Error("FakeBallShape: the type of location is not implemented");r.makeTranslationFromDir(e)}super(r),this.addImport(Ri()),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new s).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!0}get isFakeBallShape(){return!0}get uniformType(){return"FakeBallShape"}static glslClass(){return Hi()}glslSDF(){return Gi()(this)}}var Oi=r(3348),Wi=r.n(Oi),Ki=r(3053),$i=r.n(Ki),Qi=r(4355),Yi=r.n(Qi);class Zi extends wt{constructor(e,t){const r=new n;if(e.isIsometry)r.copy(e);else if(e.isPoint)r.makeTranslation(e);else{if(!e.isVector)throw new Error("FakeBallShape: the type of location is not implemented");r.makeTranslationFromDir(e)}super(r),this.addImport(Ri(),Wi()),this.radius=t,this._center=void 0}updateData(){super.updateData(),this._center=(new s).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get hasUVMap(){return!0}get isLocalFakeBallShape(){return!0}get uniformType(){return"LocalFakeBallShape"}static glslClass(){return $i()}glslSDF(){return Gi()(this)}glslUVMap(){return Yi()(this)}}var Xi=r(9302),Ji=r.n(Xi);class el extends wt{constructor(e,t,r){const a=new n;if(e.isIsometry)a.copy(e);else if(e.isPoint)a.makeTranslation(e);else{if(!e.isVector)throw new Error("FakeBallShape: the type of location is not implemented");a.makeTranslationFromDir(e)}super(a),this.radius=t,this.wRescale=r,this._center=void 0}updateData(){super.updateData(),this._center=(new s).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isGlobal(){return!1}get isLocalPotatoShape(){return!0}get uniformType(){return"LocalPotatoShape"}static glslClass(){return Ji()}glslSDF(){return Gi()(this)}}var tl=r(7499),nl=r.n(tl);class rl extends xt{constructor(e,t,n=void 0){if(!e.hasUVMap){if(t.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map");if(void 0!==n&&n.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map")}super(),this.shape=e,this.material=t,this.ptMaterial=n,this.isRendered=!0,this.addImport(nl())}get isSolid(){return!0}get isom(){return this.shape.isom}get absoluteIsom(){return this.shape.absoluteIsom}get isGlobal(){return this.shape.isGlobal}get isLocal(){return this.shape.isLocal}get uniformType(){return"Solid"}updateData(){this.shape.updateData()}setId(e){this.shape.setId(e),this.material.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),this.material.onAdd(e),super.onAdd(e)}static glslClass(){return""}glslInstance(){return`\n            bool ${this.name}_isRenderedHack = true;\n        `}shader(e){this.shape.shader(e),3===e.useCase&&void 0!==this.ptMaterial?this.ptMaterial.shader(e):this.material.shader(e),super.shader(e)}}class al extends rl{constructor(e,t,n,r=void 0){super(new qi(e,t),n,r)}}class ol extends rl{constructor(e,t,n,r=void 0){super(new Zi(e,t),n,r)}}class sl extends rl{constructor(e,t,n,r,a=void 0){super(new el(e,t,n),r,a)}}p.prototype.constructor.shader1=d(),p.prototype.constructor.shader2=b()})();var o=a.T0,s=a.FJ,i=a.GU,l=a.XH,c=a.ZH,h=a.K9,u=a.FT,d=a.cK,m=a._x,b=a.kj,p=a.V1,v=a.Vz,f=a.ck,g=a.Iy,x=a.Vf,y=a.TB,V=a.Al,M=a.ix,w=a.jZ,_=a.c$,S=a.OZ,T=a.Ao,C=a.Qj,R=a.mD,I=a.yb,D=a.iJ,E=a.ZA,P=a.Jz,k=a.fR,U=a.kK,L=a.ZX,B=a._f,N=a.Ht,F=a.HZ,j=a.TN,z=a.JV,H=a.Sc,A=a.Nh,G=a.RL,q=a._k,O=a.uR,W=a.gU,K=a.oR,$=a.lt,Q=a._r,Y=a.tl,Z=a.HI,X=a.F5,J=a.Uc,ee=a.Fh,te=a.O5,ne=a.oB,re=a.pJ,ae=a.GW,oe=a.DZ,se=a._K,ie=a.JF,le=a.Lv,ce=a.E9,he=a.Ly,ue=a.jo,de=a.mH,me=a.xd,be=a.pX,pe=a.Dz,ve=a.Th,fe=a.Uj,ge=a.bY,xe=a.cV,ye=a.lR,Ve=a.xs,Me=a.bn,we=a.oC,_e=a.Z1,Se=a.h8,Te=a.Qf,Ce=a.jE,Re=a.k1,Ie=a.ew,De=a.$p,Ee=a.xG,Pe=a.l_,ke=a.pk,Ue=a.yI,Le=a.E6,Be=a.zO,Ne=a.cB,Fe=a.OW,je=a.n3,ze=a.Se,He=a.PQ,Ae=a.$9,Ge=a.ak,qe=a.uZ,Oe=a.Cy,We=a.qM,Ke=a.tA,$e=a.Zk,Qe=a.mV,Ye=a.Gi,Ze=a.jV,Xe=a.j9,Je=a.oc,et=a.mm,tt=a.wS,nt=a.IJ,rt=a.p2,at=a.w0,ot=a.VL,st=a.UR,it=a.dV,lt=a.G0,ct=a.YL,ht=a.re;export{o as AcesFilmPostProcess,s as AdvancedResetVRControls,i as AdvancedShape,l as BOTH,c as BasicPTMaterial,h as BasicRenderer,u as BasicShape,d as CREEPING_FULL,m as CREEPING_OFF,b as CREEPING_STRICT,p as Camera,v as CheckerboardMaterial,f as CombinedPostProcess,g as ComplementShape,x as ConstDirLight,y as DebugMaterial,V as DragVRControls,M as EquidistantHypStripsMaterial,w as EquidistantSphStripsMaterial,_ as ExpFog,S as FakeBall,T as FakeBallShape,C as FlatCamera,R as FlyControls,I as Fog,D as GraphPaperMaterial,E as Group,P as GroupElement,k as HighlightLocalWrapMaterial,U as HighlightWrapMaterial,L as HypStripsMaterial,B as ImprovedEquidistantHypStripsMaterial,N as ImprovedEquidistantSphStripsMaterial,F as InfoControls,j as IntersectionShape,z as Isometry,H as IsotropicChaseVRControls,A as KeyGenericControls,G as LEFT,q as Light,O as LightVRControls,W as LinearToSRGBPostProcess,K as LocalFakeBall,$ as LocalFakeBallShape,Q as LocalFakePointLight,Y as LocalPotato,Z as LocalPotatoShape,X as Material,J as Matrix2,ee as MoveVRControls,te as MultiColorMaterial,ne as NormalMaterial,re as PTMaterial,ae as PathTracerCamera,oe as PathTracerRenderer,se as PathTracerWrapMaterial,ie as PhongMaterial,le as PhongWrapMaterial,ce as Point,he as Position,ue as QuadRing,de as QuadRingElement,me as QuadRingMatrix4,be as RIGHT,pe as RelPosition,ve as Renderer,fe as ResetVRControls,ge as RotatedSphericalTextureMaterial,xe as SMOOTH_MAX_POLY,ye as SMOOTH_MIN_POLY,Ve as Scene,Me as Shape,we as ShootVRControls,_e as SimpleTextureMaterial,Se as SingleColorMaterial,Te as Solid,Ce as SphereCamera,Re as SquaresMaterial,Ie as StripsMaterial,De as SwitchControls,Ee as TeleportationSet,Pe as TransitionLocalWrapMaterial,ke as TransitionWrapMaterial,Ue as UnionShape,Le as VRCamera,Be as VRRenderer,Ne as VaryingColorMaterial,Fe as Vector,je as VideoAlphaTextureMaterial,ze as VideoFrameTextureMaterial,He as VideoTextureMaterial,Ae as WrapShape,Ge as bind,qe as clamp,Oe as complement,We as earthTexture,Ke as fiberLoopSet,$e as genus2Set,Qe as highlightLocalWrap,Ye as highlightWrap,Ze as intersection,Xe as marsTexture,Je as moonTexture,et as orbiTorusSet,tt as pathTracerWrap,nt as phongWrap,rt as safeString,at as sunTexture,ot as transitionLocalWrap,st as transitionWrap,it as trivialSet,lt as union,ct as woodBallMaterial,ht as wrap};