import*as e from"three";var t={9397:(e,t)=>{!function(e){var t=/\S/,n=/\"/g,r=/\n/g,a=/\r/g,o=/\\/g,s=/\u2028/,i=/\u2029/;function l(e){"}"===e.n.substr(e.n.length-1)&&(e.n=e.n.substring(0,e.n.length-1))}function c(e){return e.trim?e.trim():e.replace(/^\s*|\s*$/g,"")}function d(e,t,n){if(t.charAt(n)!=e.charAt(0))return!1;for(var r=1,a=e.length;r<a;r++)if(t.charAt(n+r)!=e.charAt(r))return!1;return!0}e.tags={"#":1,"^":2,"<":3,$:4,"/":5,"!":6,">":7,"=":8,_v:9,"{":10,"&":11,_t:12},e.scan=function(n,r){var a=n.length,o=0,s=null,i=null,u="",h=[],p=!1,m=0,b=0,v="{{",f="}}";function g(){u.length>0&&(h.push({tag:"_t",text:new String(u)}),u="")}function x(n,r){if(g(),n&&function(){for(var n=!0,r=b;r<h.length;r++)if(!(n=e.tags[h[r].tag]<e.tags._v||"_t"==h[r].tag&&null===h[r].text.match(t)))return!1;return n}())for(var a,o=b;o<h.length;o++)h[o].text&&((a=h[o+1])&&">"==a.tag&&(a.indent=h[o].text.toString()),h.splice(o,1));else r||h.push({tag:"\n"});p=!1,b=h.length}function y(e,t){var n="="+f,r=e.indexOf(n,t),a=c(e.substring(e.indexOf("=",t)+1,r)).split(" ");return v=a[0],f=a[a.length-1],r+n.length-1}for(r&&(r=r.split(" "),v=r[0],f=r[1]),m=0;m<a;m++)0==o?d(v,n,m)?(--m,g(),o=1):"\n"==n.charAt(m)?x(p):u+=n.charAt(m):1==o?(m+=v.length-1,"="==(s=(i=e.tags[n.charAt(m+1)])?n.charAt(m+1):"_v")?(m=y(n,m),o=0):(i&&m++,o=2),p=m):d(f,n,m)?(h.push({tag:s,n:c(u),otag:v,ctag:f,i:"/"==s?p-v.length:m+f.length}),u="",m+=f.length-1,o=0,"{"==s&&("}}"==f?m++:l(h[h.length-1]))):u+=n.charAt(m);return x(p,!0),h};var u={_t:!0,"\n":!0,$:!0,"/":!0};function h(t,n,r,a){var o,s=[],i=null,l=null;for(o=r[r.length-1];t.length>0;){if(l=t.shift(),o&&"<"==o.tag&&!(l.tag in u))throw new Error("Illegal content in < super tag.");if(e.tags[l.tag]<=e.tags.$||p(l,a))r.push(l),l.nodes=h(t,l.tag,r,a);else{if("/"==l.tag){if(0===r.length)throw new Error("Closing tag without opener: /"+l.n);if(i=r.pop(),l.n!=i.n&&!m(l.n,i.n,a))throw new Error("Nesting error: "+i.n+" vs. "+l.n);return i.end=l.i,s}"\n"==l.tag&&(l.last=0==t.length||"\n"==t[0].tag)}s.push(l)}if(r.length>0)throw new Error("missing closing tag: "+r.pop().n);return s}function p(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n].o==e.n)return e.tag="#",!0}function m(e,t,n){for(var r=0,a=n.length;r<a;r++)if(n[r].c==e&&n[r].o==t)return!0}function b(e){var t=[];for(var n in e.partials)t.push('"'+f(n)+'":{name:"'+f(e.partials[n].name)+'", '+b(e.partials[n])+"}");return"partials: {"+t.join(",")+"}, subs: "+function(e){var t=[];for(var n in e)t.push('"'+f(n)+'": function(c,p,t,i) {'+e[n]+"}");return"{ "+t.join(",")+" }"}(e.subs)}e.stringify=function(t,n,r){return"{code: function (c,p,i) { "+e.wrapMain(t.code)+" },"+b(t)+"}"};var v=0;function f(e){return e.replace(o,"\\\\").replace(n,'\\"').replace(r,"\\n").replace(a,"\\r").replace(s,"\\u2028").replace(i,"\\u2029")}function g(e){return~e.indexOf(".")?"d":"f"}function x(e,t){var n="<"+(t.prefix||"")+e.n+v++;return t.partials[n]={name:e.n,partials:{}},t.code+='t.b(t.rp("'+f(n)+'",c,p,"'+(e.indent||"")+'"));',n}function y(e,t){t.code+="t.b(t.t(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'}function V(e){return"t.b("+e+");"}e.generate=function(t,n,r){v=0;var a={code:"",subs:{},partials:{}};return e.walk(t,a),r.asString?this.stringify(a,n,r):this.makeTemplate(a,n,r)},e.wrapMain=function(e){return'var t=this;t.b(i=i||"");'+e+"return t.fl();"},e.template=e.Template,e.makeTemplate=function(e,t,n){var r=this.makePartials(e);return r.code=new Function("c","p","i",this.wrapMain(e.code)),new this.template(r,t,this,n)},e.makePartials=function(e){var t,n={subs:{},partials:e.partials,name:e.name};for(t in n.partials)n.partials[t]=this.makePartials(n.partials[t]);for(t in e.subs)n.subs[t]=new Function("c","p","t","i",e.subs[t]);return n},e.codegen={"#":function(t,n){n.code+="if(t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,0,'+t.i+","+t.end+',"'+t.otag+" "+t.ctag+'")){t.rs(c,p,function(c,p,t){',e.walk(t.nodes,n),n.code+="});c.pop();}"},"^":function(t,n){n.code+="if(!t.s(t."+g(t.n)+'("'+f(t.n)+'",c,p,1),c,p,1,0,0,"")){',e.walk(t.nodes,n),n.code+="};"},">":x,"<":function(t,n){var r={partials:{},code:"",subs:{},inPartial:!0};e.walk(t.nodes,r);var a=n.partials[x(t,n)];a.subs=r.subs,a.partials=r.partials},$:function(t,n){var r={subs:{},code:"",partials:n.partials,prefix:t.n};e.walk(t.nodes,r),n.subs[t.n]=r.code,n.inPartial||(n.code+='t.sub("'+f(t.n)+'",c,p,i);')},"\n":function(e,t){t.code+=V('"\\n"'+(e.last?"":" + i"))},_v:function(e,t){t.code+="t.b(t.v(t."+g(e.n)+'("'+f(e.n)+'",c,p,0)));'},_t:function(e,t){t.code+=V('"'+f(e.text)+'"')},"{":y,"&":y},e.walk=function(t,n){for(var r,a=0,o=t.length;a<o;a++)(r=e.codegen[t[a].tag])&&r(t[a],n);return n},e.parse=function(e,t,n){return h(e,0,[],(n=n||{}).sectionTags||[])},e.cache={},e.cacheKey=function(e,t){return[e,!!t.asString,!!t.disableLambda,t.delimiters,!!t.modelGet].join("||")},e.compile=function(t,n){n=n||{};var r=e.cacheKey(t,n),a=this.cache[r];if(a){var o=a.partials;for(var s in o)delete o[s].instance;return a}return a=this.generate(this.parse(this.scan(t,n.delimiters),t,n),t,n),this.cache[r]=a}}(t)},5485:(e,t,n)=>{var r=n(9397);r.Template=n(2882).Template,r.template=r.Template,e.exports=r},2882:(e,t)=>{!function(e){function t(e,t,n){var r;return t&&"object"==typeof t&&(void 0!==t[e]?r=t[e]:n&&t.get&&"function"==typeof t.get&&(r=t.get(e))),r}e.Template=function(e,t,n,r){e=e||{},this.r=e.code||this.r,this.c=n,this.options=r||{},this.text=t||"",this.partials=e.partials||{},this.subs=e.subs||{},this.buf=""},e.Template.prototype={r:function(e,t,n){return""},v:function(e){return e=l(e),i.test(e)?e.replace(n,"&amp;").replace(r,"&lt;").replace(a,"&gt;").replace(o,"&#39;").replace(s,"&quot;"):e},t:l,render:function(e,t,n){return this.ri([e],t||{},n)},ri:function(e,t,n){return this.r(e,t,n)},ep:function(e,t){var n=this.partials[e],r=t[n.name];if(n.instance&&n.base==r)return n.instance;if("string"==typeof r){if(!this.c)throw new Error("No compiler available.");r=this.c.compile(r,this.options)}if(!r)return null;if(this.partials[e].base=r,n.subs){for(key in t.stackText||(t.stackText={}),n.subs)t.stackText[key]||(t.stackText[key]=void 0!==this.activeSub&&t.stackText[this.activeSub]?t.stackText[this.activeSub]:this.text);r=function(e,t,n,r,a,o){function s(){}function i(){}var l;s.prototype=e,i.prototype=e.subs;var c=new s;for(l in c.subs=new i,c.subsText={},c.buf="",r=r||{},c.stackSubs=r,c.subsText=o,t)r[l]||(r[l]=t[l]);for(l in r)c.subs[l]=r[l];for(l in a=a||{},c.stackPartials=a,n)a[l]||(a[l]=n[l]);for(l in a)c.partials[l]=a[l];return c}(r,n.subs,n.partials,this.stackSubs,this.stackPartials,t.stackText)}return this.partials[e].instance=r,r},rp:function(e,t,n,r){var a=this.ep(e,n);return a?a.ri(t,n,r):""},rs:function(e,t,n){var r=e[e.length-1];if(c(r))for(var a=0;a<r.length;a++)e.push(r[a]),n(e,t,this),e.pop();else n(e,t,this)},s:function(e,t,n,r,a,o,s){var i;return(!c(e)||0!==e.length)&&("function"==typeof e&&(e=this.ms(e,t,n,r,a,o,s)),i=!!e,!r&&i&&t&&t.push("object"==typeof e?e:t[t.length-1]),i)},d:function(e,n,r,a){var o,s=e.split("."),i=this.f(s[0],n,r,a),l=this.options.modelGet,d=null;if("."===e&&c(n[n.length-2]))i=n[n.length-1];else for(var u=1;u<s.length;u++)void 0!==(o=t(s[u],i,l))?(d=i,i=o):i="";return!(a&&!i)&&(a||"function"!=typeof i||(n.push(d),i=this.mv(i,n,r),n.pop()),i)},f:function(e,n,r,a){for(var o=!1,s=!1,i=this.options.modelGet,l=n.length-1;l>=0;l--)if(void 0!==(o=t(e,n[l],i))){s=!0;break}return s?(a||"function"!=typeof o||(o=this.mv(o,n,r)),o):!a&&""},ls:function(e,t,n,r,a){var o=this.options.delimiters;return this.options.delimiters=a,this.b(this.ct(l(e.call(t,r)),t,n)),this.options.delimiters=o,!1},ct:function(e,t,n){if(this.options.disableLambda)throw new Error("Lambda features disabled.");return this.c.compile(e,this.options).render(t,n)},b:function(e){this.buf+=e},fl:function(){var e=this.buf;return this.buf="",e},ms:function(e,t,n,r,a,o,s){var i,l=t[t.length-1],c=e.call(l);return"function"==typeof c?!!r||(i=this.activeSub&&this.subsText&&this.subsText[this.activeSub]?this.subsText[this.activeSub]:this.text,this.ls(c,l,n,i.substring(a,o),s)):c},mv:function(e,t,n){var r=t[t.length-1],a=e.call(r);return"function"==typeof a?this.ct(l(a.call(r)),r,n):a},sub:function(e,t,n,r){var a=this.subs[e];a&&(this.activeSub=e,a(t,n,this,r),this.activeSub=!1)}};var n=/&/g,r=/</g,a=/>/g,o=/\'/g,s=/\"/g,i=/[&<>\"\']/;function l(e){return String(null==e?"":e)}var c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}}(t)},9606:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n, r);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, rayType);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n, r);\n}\n\nvec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    return render({{name}}, v, rayType);\n}",r);return e.render.apply(e,arguments)}},9909:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);"),r.b("\n"+n),r.b("    //return vec4(debugColor,1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return vec4(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist, 1);\n    //return vec4(debugColor,1);\n}",r);return e.render.apply(e,arguments)}},8906:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},1998:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,220,289,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,481,540,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},699:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,405,478,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,580,881,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,764,845,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1119,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1289,1570,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1464,1535,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},4261:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,210,275,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,463,518,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightLocalWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn && material.cellBoost == v.vector.cellBoost) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},8474:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        return {{highlightMat.name}}_render(v);\n    }\n    return {{defaultMat.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},5506:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,171,240,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,0,432,491,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v, normal);\n        {{/highlightMat.usesNormal}}\n        {{^highlightMat.usesNormal}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{#defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v, normal);\n    {{/defaultMat.usesNormal}}\n    {{^defaultMat.usesNormal}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesNormal}}\n}\n",r);return e.render.apply(e,arguments)}},7397:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,356,429,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("highlightMat.usesNormal",e,t,1),e,t,0,531,832,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,715,796,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1070,1133,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("defaultMat.name.usesNormal",e,t,1),e,t,0,1240,1521,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("defaultMat.name.usesUVMap",e,t,1),e,t,0,1415,1486,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{^highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n\n        {{#highlightMat.usesNormal}}\n            {{^highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal);\n            {{/highlightMat.usesUVMap}}\n            {{#highlightMat.usesUVMap}}\n                return {{highlightMat.name}}_render(v, normal, uv);\n            {{/highlightMat.usesUVMap}}\n        {{/highlightMat.usesNormal}}\n    }\n\n    {{^defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n    \n    {{#defaultMat.name.usesNormal}}\n        {{^defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal);\n        {{/defaultMat.name.usesUVMap}}\n        {{#defaultMat.name.usesUVMap}}\n            return {{defaultMat.name}}_render(v, normal, uv);\n        {{/defaultMat.name.usesUVMap}}\n    {{/defaultMat.name.usesNormal}}\n}\n\n",r);return e.render.apply(e,arguments)}},3045:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    HighlightWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    if(material.isHighlightOn) {"),r.b("\n"+n),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,0,161,226,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("highlightMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            return "),r.b(r.v(r.d("highlightMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    }"),r.b("\n"),r.b("\n"+n),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,0,414,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("defaultMat.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        return "),r.b(r.v(r.d("defaultMat.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    HighlightWrapMaterial material = {{name}};\n\n    if(material.isHighlightOn) {\n        {{#highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v, uv);\n        {{/highlightMat.usesUVMap}}\n        {{^highlightMat.usesUVMap}}\n            return {{highlightMat.name}}_render(v);\n        {{/highlightMat.usesUVMap}}\n    }\n\n    {{#defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v, uv);\n    {{/defaultMat.usesUVMap}}\n    {{^defaultMat.usesUVMap}}\n        return {{defaultMat.name}}_render(v);\n    {{/defaultMat.usesUVMap}}\n}\n",r);return e.render.apply(e,arguments)}},6077:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    return normalMaterialRender(v, normal);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    return normalMaterialRender(v, normal);\n}",r);return e.render.apply(e,arguments)}},1202:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n,r);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n,r);\n}",r);return e.render.apply(e,arguments)}},2330:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v).rgb;\n}",r);return e.render.apply(e,arguments)}},9040:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, normal).rgb;\n}",r);return e.render.apply(e,arguments)}},588:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;   "),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;   \n    }\n    return {{material.name}}_render(v, normal, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},1365:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("      return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n      return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, uv).rgb;\n}",r);return e.render.apply(e,arguments)}},8149:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,204,519,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongMaterial material = {{name}};\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},3838:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,261,587,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},472:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,269,595,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},7660:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,282,608,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},8204:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv).rgb;"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,275,601,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("    return vec4(color, 1);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, uv).rgb;\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n\n    return vec4(color, 1);\n}",r);return e.render.apply(e,arguments)}},5377:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.b("        color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    color0 = {{mat0.name}}_render(v);\n\n    if(v.vector.cellBoost == material.cellBoost){\n        color1 = {{mat1.name}}_render(v);\n    } else{\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},9441:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,156,212,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,405,469,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("            color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else {"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionLocalWrapMaterial material = {{name}};\n    vec4 color0, color1;\n    {{#mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v, normal);\n        {{/mat1.usesNormal}}\n        {{^mat1.usesNormal}}\n            color1 =  {{mat1.name}}_render(v);\n        {{/mat1.usesNormal}}\n    } else {\n        color1 = color0;\n    }\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},9245:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,296,355,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,429,658,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,567,634,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,834,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,1017,1274,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1171,1246,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesNormal}}\n            {{^mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal);\n            {{/mat1.usesUVMap}}\n            {{#mat1.usesUVMap}}\n                color1 = {{mat1.name}}_render(v, normal, uv);\n            {{/mat1.usesUVMap}}\n        {{/mat1.usesNormal}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},6766:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    vec4 color0, color1;"),r.b("\n"+n),r.b("    TransitionLocalWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,147,198,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    if(v.vector.cellBoost == material.cellBoost){"),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,386,445,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("    } else{"),r.b("\n"+n),r.b("        color1 = color0;"),r.b("\n"+n),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    vec4 color0, color1;\n    TransitionLocalWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    if(v.vector.cellBoost == material.cellBoost){\n        {{#mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n        {{^mat1.usesUVMap}}\n            color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n    } else{\n        color1 = color0;\n    }\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},8402:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.b("    vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    TransitionWrapMaterial material = {{name}};\n\n    vec4 color0 = {{mat0.name}}_render(v);\n    vec4 color1 = {{mat1.name}}_render(v);\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}",r);return e.render.apply(e,arguments)}},6158:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,127,188,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 =  "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,332,393,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 =  "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v, normal);\n    {{/mat0.usesNormal}}\n    {{^mat0.usesNormal}}\n        vec4 color0 =  {{mat0.name}}_render(v);\n    {{/mat0.usesNormal}}\n\n    {{#mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v, normal);\n    {{/mat1.usesNormal}}\n    {{^mat1.usesNormal}}\n        vec4 color1 =  {{mat1.name}}_render(v);\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},4146:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,271,335,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat0.usesNormal",e,t,1),e,t,0,409,648,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,552,624,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,829,893,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("mat1.usesNormal",e,t,1),e,t,0,967,1206,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,1110,1182,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{^mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n    \n    {{#mat0.usesNormal}}\n        {{^mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal);\n        {{/mat0.usesUVMap}}\n        {{#mat0.usesUVMap}}\n            vec4 color0 = {{mat0.name}}_render(v, normal, uv);\n        {{/mat0.usesUVMap}}\n    {{/mat0.usesNormal}}\n\n    {{^mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n    \n    {{#mat1.usesNormal}}\n        {{^mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal);\n        {{/mat1.usesUVMap}}\n        {{#mat1.usesUVMap}}\n            vec4 color1 = {{mat1.name}}_render(v, normal, uv);\n        {{/mat1.usesUVMap}}\n    {{/mat1.usesNormal}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n\n",r);return e.render.apply(e,arguments)}},2332:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    TransitionWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"),r.b("\n"+n),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,0,117,173,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat0.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color0 = "),r.b(r.v(r.d("mat0.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,0,312,368,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop()),r.s(r.d("mat1.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("        vec4 color1 = "),r.b(r.v(r.d("mat1.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.b("\n"+n),r.b("    return (1. - material.ratio) * color0 + material.ratio * color1;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    TransitionWrapMaterial material = {{name}};\n\n    {{#mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v, uv);\n    {{/mat0.usesUVMap}}\n    {{^mat0.usesUVMap}}\n        vec4 color0 = {{mat0.name}}_render(v);\n    {{/mat0.usesUVMap}}\n\n    {{#mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v, uv);\n    {{/mat1.usesUVMap}}\n    {{^mat1.usesUVMap}}\n        vec4 color1 = {{mat1.name}}_render(v);\n    {{/mat1.usesUVMap}}\n\n    return (1. - material.ratio) * color0 + material.ratio * color1;\n}\n",r);return e.render.apply(e,arguments)}},6142:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return negate("),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v));"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the complement of a shape\n */\nRelVector {{name}}_gradient(RelVector v){\n    return negate({{shape.name}}_gradient(v));\n}",r);return e.render.apply(e,arguments)}},7939:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    return - "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the complement of a shape\n */\nfloat {{name}}_sdf(RelVector v){\n    return - {{shape.name}}_sdf(v);\n}",r);return e.render.apply(e,arguments)}},7260:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},6861:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMaxPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMaxPoly(dist1, dist2, grad1, grad2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},3335:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the intersection of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6428:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMaxPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMaxPoly(dist1, dist2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},2076:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return max(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the intersection of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return max(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},2905:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},8655:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMinPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMinPoly(dist1, dist2, grad1, grad2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},7762:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},3238:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMinPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMinPoly(dist1, dist2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},3908:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return min(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return min(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},7500:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6242:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for a wrapping\n */\nRelVector {{name}}_gradient(RelVector v){\n    return {{shape.name}}_gradient(v);\n}",r);return e.render.apply(e,arguments)}},3105:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float wrap = "),r.b(r.v(r.d("wrap.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(wrap > camera.threshold){"),r.b("\n"+n),r.b("        return wrap;"),r.b("\n"+n),r.b("    } else {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for a wrapping\n */\nfloat {{name}}_sdf(RelVector v){\n    float wrap = {{wrap.name}}_sdf(v);\n    if(wrap > camera.threshold){\n        return wrap;\n    } else {\n        return {{shape.name}}_sdf(v);\n    }\n}",r);return e.render.apply(e,arguments)}},9338:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},7577:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("bool "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(RelVector v, int i, out RelVector dir, out float intensity) {"),r.b("\n"+n),r.b("    return directions("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, i, dir, intensity);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"bool {{name}}_directions(RelVector v, int i, out RelVector dir, out float intensity) {\n    return directions({{name}}, v, i, dir, intensity);\n}",r);return e.render.apply(e,arguments)}},8778:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v) {\n    return render({{name}}, v);\n}\n",r);return e.render.apply(e,arguments)}},1215:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec4 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, uv);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec4 {{name}}_render(ExtVector v, vec2 uv) {\n    return render({{name}}, v, uv);\n}\n",r);return e.render.apply(e,arguments)}},2044:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1403,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1386,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representation of v can be updated"),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2169,2585,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2232,2533,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3143,3524,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3165,3506,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered && "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representation of v can be updated\n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered && {{name}}_isRenderedHack){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},7781:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec4 color;"),r.b("\n"+n),r.b("    vec4 reflectivity;"),r.b("\n"+n),r.b("    float opacity;"),r.b("\n"+n),r.b("    float t;"),r.b("\n"),r.b("\n"+n),r.b("    switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,315,5918,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,0,373,2190,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,589,724,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,822,1314,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,1071,1278,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.b("            if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                opacity = 1.;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else {"),r.b("\n"+n),r.b("                opacity = color.a;"),r.b("\n"+n),r.b("            }"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,1525,1604,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                //color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("            if(opacity == 1.) {"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else{"),r.b("\n"+n),r.b("                v.data.stop = false;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;"),r.b("\n"+n),r.b("            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;"),r.b("\n"+n),r.b("            "),r.b(r.v(r.f("name",e,t,0))),r.b("_isRenderedHack = false;"),r.b("\n"+n),r.b("            v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("            v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("            //v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isTransparent",e,t,1),e,t,1,0,0,"")||(r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,0,2294,4409,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.b("                if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                    reflectivity = vec4(0);"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else {"),r.b("\n"+n),r.b("                    reflectivity = vec4("),r.b(r.v(r.d("material.name",e,t,0))),r.b(".reflectivity,1);"),r.b("\n"+n),r.b("                }"),r.b("\n"),r.b("\n"+n),r.b("                normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                // in general the gradient is not necessarily a unit vector"),r.b("\n"+n),r.b("                normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,2944,3091,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,3197,3593,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,3398,3553,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,3649,3734,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                if(length(reflectivity) == 0.) {"),r.b("\n"+n),r.b("                    v.data.stop = true;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                else{"),r.b("\n"+n),r.b("                    v.data.stop = false;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;"),r.b("\n"+n),r.b("                v.vector = geomReflect(v.vector,normal);"),r.b("\n"+n),r.b("                v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("                v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("                v = flow(v, t);"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,4710,4857,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,4963,5495,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,5232,5455,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                        normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                        uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                        color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,5551,5636,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("                v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n)),r.b("\n"+n)),r.b("        break;"),r.b("\n"),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec4 color = "),r.b(r.v(r.d("scene.background.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec4(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec4(0), vec4(1));\n}\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    vec2 uv;\n    vec4 color;\n    vec4 reflectivity;\n    float opacity;\n    float t;\n\n    switch(objId){\n    {{#scene.solids}}\n\n        case {{id}}:\n        {{#material.isTransparent}}\n\n            {{^material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color =  {{material.name}}_render(v);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            {{#material.usesNormal}}\n                {{^material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    color = {{material.name}}_render(v, normal);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, normal, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            if(v.data.iBounce == maxBounces){\n                opacity = 1.;\n            }\n            else {\n                opacity = color.a;\n            }\n\n            {{#scene.fog}}\n                //color = applyFog(color, v.data.lastBounceDist);\n            {{/scene.fog}}\n\n            if(opacity == 1.) {\n                v.data.stop = true;\n            }\n            else{\n                v.data.stop = false;\n            }\n            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * opacity * color;\n            v.data.leftToComputeColor = (1. - opacity) * v.data.leftToComputeColor;\n            {{name}}_isRenderedHack = false;\n            v.data.lastBounceDist = 0.;\n            v.data.iBounce = v.data.iBounce + 1;\n            //t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n            //v = flow(v, t);\n\n        {{/material.isTransparent}}\n\n        {{^material.isTransparent}}\n\n            {{#material.isReflecting}}\n\n                if(v.data.iBounce == maxBounces){\n                    reflectivity = vec4(0);\n                }\n                else {\n                    reflectivity = vec4({{material.name}}.reflectivity,1);\n                }\n\n                normal = {{shape.name}}_gradient(v.vector);\n                // in general the gradient is not necessarily a unit vector\n                normal = geomNormalize(normal);\n\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                if(length(reflectivity) == 0.) {\n                    v.data.stop = true;\n                }\n                else{\n                    v.data.stop = false;\n                }\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec4(1) - reflectivity) * color;\n                v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;\n                v.vector = geomReflect(v.vector,normal);\n                v.data.lastBounceDist = 0.;\n                v.data.iBounce = v.data.iBounce + 1;\n                t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n                v = flow(v, t);\n\n            {{/material.isReflecting}}\n\n            {{^material.isReflecting}}\n                {{^material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        color =  {{material.name}}_render(v);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#material.usesNormal}}\n                    {{^material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        color = {{material.name}}_render(v, normal);\n                    {{/material.usesUVMap}}\n                    {{#material.usesUVMap}}\n                        normal = {{shape.name}}_gradient(v.vector);\n                        uv = {{shape.name}}_uvMap(v.vector);\n                        color = {{material.name}}_render(v, normal, uv);\n                    {{/material.usesUVMap}}\n                {{/material.usesNormal}}\n\n                {{#scene.fog}}\n                    color = applyFog(color, v.data.lastBounceDist);\n                {{/scene.fog}}\n\n                v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n                v.data.leftToComputeColor = vec4(0);\n                v.data.stop = true;\n            {{/material.isReflecting}}\n\n        {{/material.isTransparent}}\n        break;\n\n    {{/scene.solids}}\n    }\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec4 color = {{scene.background.name}}_render(v);\n        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n        v.data.leftToComputeColor = vec4(0);\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},4122:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * We assume that we are inside a solid"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("void nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    ior = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.ior; // index of the "air"'),r.b("\n"+n),r.b("    absorb = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.absorb; // absorb of the "air"'),r.b("\n"+n),r.b("    emission=vec3(0,0,0);//no emission from 'air'"),r.b("\n"+n),r.b("    opticalDepth="),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.opticalDepth; // opticalDepth of the "air"'),r.b("\n"+n),r.b("    isInside = false;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    RelVector v = flow(normal, 2. * camera.threshold);"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,579,1010,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("            dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("            if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                ior = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("                absorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("                emission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("                opticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("                isInside = true;"),r.b("\n"+n),r.b("                return;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("}"),r.fl()},partials:{},subs:{}},'/**\n * We assume that we are inside a solid\n */\nvoid nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){\n    float dist;\n    ior = {{scene.ptBackground.name}}.ior; // index of the "air"\n    absorb = {{scene.ptBackground.name}}.absorb; // absorb of the "air"\n    emission=vec3(0,0,0);//no emission from \'air\'\n    opticalDepth={{scene.ptBackground.name}}.opticalDepth; // opticalDepth of the "air"\n    isInside = false;\n    \n    RelVector v = flow(normal, 2. * camera.threshold);\n    {{#scene.solids}}\n        if({{name}}.isRendered){\n            dist = {{shape.name}}_sdf(v);\n            if(dist < camera.threshold) {\n                ior = {{ptMaterial.name}}.ior;\n                absorb = {{ptMaterial.name}}.absorb;\n                emission = {{ptMaterial.name}}.volumeEmission;\n                opticalDepth = {{ptMaterial.name}}.opticalDepth;\n                isInside = true;\n                return;\n            }\n        }\n    {{/scene.solids}}\n}',r);return e.render.apply(e,arguments)}},6172:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1381,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1364,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representatiion of v can be updated "),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2149,2565,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2212,2513,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3123,3482,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3145,3464,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representatiion of v can be updated \n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},6272:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".absorb, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".volumeEmission, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".opticalDepth, false);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void roulette(inout ExtVector v){"),r.b("\n"+n),r.b("    // as the light left gets smaller, the ray is more likely to get terminated early."),r.b("\n"+n),r.b("    // survivors have their value boosted to make up for fewer samples being in the average."),r.b("\n"+n),r.b("    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));"),r.b("\n"+n),r.b("    if (randomFloat() > p){"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    // add the energy we 'lose' by randomly terminating paths"),r.b("\n"+n),r.b("    v.data.light = v.data.light / p;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    RayType rayType;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec3 color;"),r.b("\n"+n),r.b("    vec3 reflectivity;"),r.b("\n"+n),r.b("    float hackCoeff = 1.;"),r.b("\n"+n),r.b("    float r; /** ratio of IOR */"),r.b("\n"+n),r.b("    float nextIOR; /** IOR of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextAbsorb; /** absorb of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextEmission;/** volumetric emission of the neighbor solid */"),r.b("\n"+n),r.b("    float nextOpticalDepth;/** optical depth of the neighbor solid */"),r.b("\n"+n),r.b("    bool nextIsInside = true;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector diffuseDir;"),r.b("\n"+n),r.b("    RelVector reflectDir;"),r.b("\n"+n),r.b("    RelVector refractDir;"),r.b("\n"),r.b("\n"+n),r.b("    // get a uniformly distributed vector on the sphere"),r.b("\n"+n),r.b("    RelVector random = randomVector(v.vector);"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("    //get volumetric coloring:"),r.b("\n"+n),r.b("    //portion of light is absorbed."),r.b("\n"+n),r.b("    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    //light is emitted along the journey (linear or expoenential pickup)"),r.b("\n"+n),r.b("    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;"),r.b("\n"+n),r.b("    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);"),r.b("\n"),r.b("\n"+n),r.b("    //use these quantities to update pixel and light:"),r.b("\n"+n),r.b("    v.data.light = v.data.light * volAbsorb;"),r.b("\n"+n),r.b("    v.data.pixel = v.data.pixel + v.data.light*volEmit;"),r.b("\n"+n),r.b("    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output"),r.b("\n"+n),r.b("    "),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,2036,5260,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("    "),r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.b("            normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("            normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.b("            "),r.b("\n"+n),r.b("            // get info and reset normal based on which side we are on."),r.b("\n"+n),r.b('            // starting assumption: in the "air"'),r.b("\n"+n),r.b("            r = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".ior / "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("            nextAbsorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("            nextEmission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("            nextOpticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(v.data.isInside){"),r.b("\n"+n),r.b("                //things to change if we are inside a material instead:"),r.b("\n"+n),r.b("                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);"),r.b("\n"+n),r.b("                r = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior / nextIOR;"),r.b("\n"+n),r.b("                normal = negate(normal);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            rayType = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_setRayType(v, normal,r);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color =  "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, rayType);"),r.b("\n"+n)),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,0,3160,3302,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                color = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, uv, rayType);"),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("        // hack to make sure that lights are not too bright"),r.b("\n"+n),r.b("            if(v.data.iBounce == 0){"),r.b("\n"+n),r.b("                hackCoeff = 0.2;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            //apply surface effects"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".emission;"),r.b("\n"+n),r.b("            if(!rayType.refract){"),r.b("\n"+n),r.b("                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);"),r.b("\n"+n),r.b("             }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            // update the ray direction"),r.b("\n"+n),r.b("            // diffuse uses a normal oriented cosine weighted hemisphere sample."),r.b("\n"+n),r.b("            diffuseDir = geomNormalize(add(normal, random));"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.diffuse){"),r.b("\n"+n),r.b("                v.vector = diffuseDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.reflect){"),r.b("\n"+n),r.b("                // perfectly smooth specular uses the reflection ray."),r.b("\n"+n),r.b("                reflectDir = geomReflect(v.vector, normal);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                v.vector = reflectDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.refract){"),r.b("\n"+n),r.b("                    refractDir = geomRefract(v.vector,normal, r);"),r.b("\n"+n),r.b("                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                    v.data.isInside = nextIsInside;"),r.b("\n"+n),r.b("                    v.data.currentAbsorb = nextAbsorb;"),r.b("\n"+n),r.b("                    v.data.currentEmission = nextEmission;"),r.b("\n"+n),r.b("                    v.data.currentOpticalDepth = nextOpticalDepth;"),r.b("\n"+n),r.b("                    v.vector = refractDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("    v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("    // be carefull, v is not normal to the surface"),r.b("\n"+n),r.b("    // if the time we flow is too small, we are still below the camera threshold"),r.b("\n"+n),r.b("    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("    v = flow(v, t);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor.rgb;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec3 bgColor = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".diffuse;"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.light * bgColor;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        roulette(v);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), {{scene.ptBackground.name}}.absorb, {{scene.ptBackground.name}}.volumeEmission, {{scene.ptBackground.name}}.opticalDepth, false);\n}\n\n\n\nvoid roulette(inout ExtVector v){\n    // as the light left gets smaller, the ray is more likely to get terminated early.\n    // survivors have their value boosted to make up for fewer samples being in the average.\n    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));\n    if (randomFloat() > p){\n        v.data.stop = true;\n    }\n    // add the energy we 'lose' by randomly terminating paths\n    v.data.light = v.data.light / p;\n}\n\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    RayType rayType;\n    vec2 uv;\n    vec3 color;\n    vec3 reflectivity;\n    float hackCoeff = 1.;\n    float r; /** ratio of IOR */\n    float nextIOR; /** IOR of the neighbor solid */\n    vec3 nextAbsorb; /** absorb of the neighbor solid */\n    vec3 nextEmission;/** volumetric emission of the neighbor solid */\n    float nextOpticalDepth;/** optical depth of the neighbor solid */\n    bool nextIsInside = true;\n\n    RelVector diffuseDir;\n    RelVector reflectDir;\n    RelVector refractDir;\n\n    // get a uniformly distributed vector on the sphere\n    RelVector random = randomVector(v.vector);\n\n\n\n\n\n    //get volumetric coloring:\n    //portion of light is absorbed.\n    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);\n    \n    //light is emitted along the journey (linear or expoenential pickup)\n    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;\n    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);\n\n    //use these quantities to update pixel and light:\n    v.data.light = v.data.light * volAbsorb;\n    v.data.pixel = v.data.pixel + v.data.light*volEmit;\n    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output\n    \n\n\n\n\n\n\nswitch(objId){\n    {{#scene.solids}}\n    \n        case {{id}}:\n            normal = {{shape.name}}_gradient(v.vector);\n            normal = geomNormalize(normal);\n\n            \n            // get info and reset normal based on which side we are on.\n            // starting assumption: in the \"air\"\n            r = {{scene.ptBackground.name}}.ior / {{ptMaterial.name}}.ior;\n            nextAbsorb = {{ptMaterial.name}}.absorb;\n            nextEmission = {{ptMaterial.name}}.volumeEmission;\n            nextOpticalDepth = {{ptMaterial.name}}.opticalDepth;\n        \n            if(v.data.isInside){\n                //things to change if we are inside a material instead:\n                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);\n                r = {{ptMaterial.name}}.ior / nextIOR;\n                normal = negate(normal);\n            }\n        \n            rayType = {{ptMaterial.name}}_setRayType(v, normal,r);\n        \n            {{^ptMaterial.usesUVMap}}\n                color =  {{ptMaterial.name}}_render(v, normal, rayType);\n            {{/ptMaterial.usesUVMap}}\n            {{#ptMaterial.usesUVMap}}\n                uv = {{shape.name}}_uvMap(v.vector);\n                color = {{ptMaterial.name}}_render(v, normal, uv, rayType);\n            {{/ptMaterial.usesUVMap}}\n        \n        \n        // hack to make sure that lights are not too bright\n            if(v.data.iBounce == 0){\n                hackCoeff = 0.2;\n            }\n        \n            //apply surface effects\n            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * {{ptMaterial.name}}.emission;\n            if(!rayType.refract){\n                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);\n             }\n        \n            // update the ray direction\n            // diffuse uses a normal oriented cosine weighted hemisphere sample.\n            diffuseDir = geomNormalize(add(normal, random));\n        \n            if(rayType.diffuse){\n                v.vector = diffuseDir;\n            }\n        \n            if(rayType.reflect){\n                // perfectly smooth specular uses the reflection ray.\n                reflectDir = geomReflect(v.vector, normal);\n        \n                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                v.vector = reflectDir;\n            }\n        \n            if(rayType.refract){\n                    refractDir = geomRefract(v.vector,normal, r);\n                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                    v.data.isInside = nextIsInside;\n                    v.data.currentAbsorb = nextAbsorb;\n                    v.data.currentEmission = nextEmission;\n                    v.data.currentOpticalDepth = nextOpticalDepth;\n                    v.vector = refractDir;\n            }\n            break;\n    \n    {{/scene.solids}}\n    }\n\n    v.data.lastBounceDist = 0.;\n    v.data.iBounce = v.data.iBounce + 1;\n    // be carefull, v is not normal to the surface\n    // if the time we flow is too small, we are still below the camera threshold\n    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n    v = flow(v, t);\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor.rgb;\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec3 bgColor = {{scene.ptBackground.name}}.diffuse;\n        v.data.pixel = v.data.pixel + v.data.light * bgColor;\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        roulette(v);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},5030:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return gradient("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    return gradient({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},8266:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float newEp = 0.001;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));"),r.b("\n"+n),r.b("    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));"),r.b("\n"),r.b("\n"+n),r.b("    float vgx = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPX) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMX);"),r.b("\n"+n),r.b("    float vgy = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPY) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMY);"),r.b("\n"+n),r.b("    float vgz = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPZ) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMZ);"),r.b("\n"+n),r.b("    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));"),r.b("\n"),r.b("\n"+n),r.b("    n = geomNormalize(n);"),r.b("\n"+n),r.b("    return n;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    float newEp = 0.001;\n\n    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));\n    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));\n    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));\n    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));\n    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));\n    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));\n\n    float vgx = {{name}}_sdf(shiftPX) - {{name}}_sdf(shiftMX);\n    float vgy = {{name}}_sdf(shiftPY) - {{name}}_sdf(shiftMY);\n    float vgz = {{name}}_sdf(shiftPZ) - {{name}}_sdf(shiftMZ);\n    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));\n\n    n = geomNormalize(n);\n    return n;\n}",r);return e.render.apply(e,arguments)}},3707:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v) {"),r.b("\n"+n),r.b("    return sdf("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"float {{name}}_sdf(RelVector v) {\n    return sdf({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},4355:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return uvMap("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return uvMap({{name}}, v);\n}",r);return e.render.apply(e,arguments)}},3148:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Default creeping function (binary search)"),r.b("\n"+n),r.b(" * @param start starting point of the creeping"),r.b("\n"+n),r.b(" * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)"),r.b("\n"+n),r.b(" * @param offset how long we flow after passing the boundary"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(ExtVector v, ExtVector outside,  float offset){"),r.b("\n"+n),r.b("    ExtVector try = outside;"),r.b("\n"+n),r.b("    float sIn = 0.;"),r.b("\n"+n),r.b("    float sOut = try.data.lastFlowDist;"),r.b("\n"+n),r.b("    float s;"),r.b("\n"+n),r.b("    for(int i=0; i < 100; i++){"),r.b("\n"+n),r.b("        if(sOut - sIn < offset){"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("        s = 0.5 * sIn + 0.5 * sOut;"),r.b("\n"+n),r.b("        try = flow(v,s);"),r.b("\n"+n),r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("            sOut = s;"),r.b("\n"+n),r.b("            outside = try;"),r.b("\n"+n),r.b("        } else {"),r.b("\n"+n),r.b("            sIn = s;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return sOut;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Default creeping function (binary search)\n * @param start starting point of the creeping\n * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)\n * @param offset how long we flow after passing the boundary\n */\nfloat {{glslCreepName}}(ExtVector v, ExtVector outside,  float offset){\n    ExtVector try = outside;\n    float sIn = 0.;\n    float sOut = try.data.lastFlowDist;\n    float s;\n    for(int i=0; i < 100; i++){\n        if(sOut - sIn < offset){\n            break;\n        }\n        s = 0.5 * sIn + 0.5 * sOut;\n        try = flow(v,s);\n        if({{glslTestName}}(try.vector.local.pos)){\n            sOut = s;\n            outside = try;\n        } else {\n            sIn = s;\n        }\n    }\n    return sOut;\n}",r);return e.render.apply(e,arguments)}},5103:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* Teleportation."),r.b("\n"+n),r.b("* Check if the local vector is still in the fundamental domain define by the teleportation tests."),r.b("\n"+n),r.b("* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true"),r.b("\n"+n),r.b("* Otherwise, do nothing and set teleported to false"),r.b("\n"+n),r.b("* @param[in] v the relative vector to teleport."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("ExtVector teleport(ExtVector v){"),r.b("\n"+n),r.b("    v.data.isTeleported = false;"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,424,621,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(v.vector.local.pos)){"),r.b("\n"+n),r.b("            v.vector = rewrite(v.vector, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("            v.data.isTeleported = true;"),r.b("\n"+n),r.b("            return v;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    return v;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Does one of the two following transformation:"),r.b("\n"+n),r.b("* flow the vector by the given time, if the vector escape the fundamental domain,"),r.b("\n"+n),r.b("* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain"),r.b("\n"+n),r.b("* (and even a bit further)"),r.b("\n"+n),r.b("*"),r.b("\n"+n),r.b("* @param[inout] v the relative vector to flow / teleport / creep."),r.b("\n"+n),r.b("* @param[in] t the (maximal) time to flow"),r.b("\n"+n),r.b("* @param[in] offset the amount we march passed the boundary"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float creepingDist(ExtVector v, float t, float offset){"),r.b("\n"+n),r.b("    float res = t;"),r.b("\n"+n),r.b("    ExtVector try = flow(v, t);"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,1233,1638,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.f("usesCreepingCustom",e,t,1),e,t,0,1266,1407,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.f("usesCreepingBinary",e,t,1),e,t,0,1463,1609,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, try, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n)})),e.pop()),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"/**\n* Teleportation.\n* Check if the local vector is still in the fundamental domain define by the teleportation tests.\n* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true\n* Otherwise, do nothing and set teleported to false\n* @param[in] v the relative vector to teleport.\n*/\nExtVector teleport(ExtVector v){\n    v.data.isTeleported = false;\n    {{#teleportations}}\n        if({{glslTestName}}(v.vector.local.pos)){\n            v.vector = rewrite(v.vector, {{elt.name}}, {{inv.name}});\n            v.data.isTeleported = true;\n            return v;\n        }\n    {{/teleportations}}\n    return v;\n}\n\n\n/**\n* Does one of the two following transformation:\n* flow the vector by the given time, if the vector escape the fundamental domain,\n* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain\n* (and even a bit further)\n*\n* @param[inout] v the relative vector to flow / teleport / creep.\n* @param[in] t the (maximal) time to flow\n* @param[in] offset the amount we march passed the boundary\n*/\nfloat creepingDist(ExtVector v, float t, float offset){\n    float res = t;\n    ExtVector try = flow(v, t);\n    {{#teleportations}}\n\n        {{#usesCreepingCustom}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, offset));\n            }\n        {{/usesCreepingCustom}}\n\n        {{#usesCreepingBinary}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, try, offset));\n            }\n        {{/usesCreepingBinary}}\n\n    {{/teleportations}}\n    return res;\n}\n\n\n",r);return e.render.apply(e,arguments)}},6097:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                                    \n                                                                                                                        \n\nstruct GroupElement {\n    Isometry isom;                                 \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(IDENTITY);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(multiply(elt1.isom, elt2.isom));\n}\n\n                                              \n                                                 \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return elt.isom;\n}"},9188:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                               \n                                                                                                                        \n\nstruct GroupElement {\n    bool fake;                                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(true);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(true);\n}\n\n                                              \n                                \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return IDENTITY;\n}"},5363:e=>{e.exports="   \n                                                                \n   \nfloat fresnelReflectAmount(RelVector incident, RelVector normal, float r, float reflecAt0, float relfectAt90) {\n                           \n    float r0 = (r - 1.) / (r + 1.);\n    r0 = r0 * r0;\n    float cosX = -geomDot(normal, incident);\n    if (r > 1.)\n    {\n        float sinT2 = r * r * (1. - cosX * cosX);\n                                    \n        if (sinT2 > 1.){\n            return relfectAt90;\n        }\n        cosX = sqrt(1. - sinT2);\n    }\n    float x = 1.- cosX;\n    float ret = clamp(r0 + (1. - r0) * x * x * x * x * x, 0., 1.);\n\n                                                        \n                               \n    return reflecAt0 + (relfectAt90 - reflecAt0) * ret;\n}"},2093:e=>{e.exports="   \n                                  \n   \nfloat smoothMaxPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return max(a, b) + 0.25 * k * h * h;\n}\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMaxPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n    return add(multiplyScalar(1. - 0.5 * h, gradMax), multiplyScalar(0.5 * h, gradMin));\n}\n"},5442:e=>{e.exports="float smoothMinPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return min(a, b) - 0.25 * k * h * h;\n}\n\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMinPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n\n    return add(multiplyScalar(1. - 0.5 * h, gradMin), multiplyScalar(0.5 * h, gradMax));\n}\n"},2143:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct BasicPTMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(BasicPTMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n                                                         \n                                  \n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\nvec3 render(BasicPTMaterial material, ExtVector v, RayType rayType) {\n    if (rayType.reflect){\n        return material.specular;\n    }\n                               \n                                              \n                                         \n       \n    return material.diffuse;\n}\n\n"},2197:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct CheckerboardMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\nvec4 render(CheckerboardMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    if (x1 < 1. && x2 < 1.){\n        return vec4(material.color1, 1);\n    } else if (x1 >= 1. && x2 >= 1.) {\n        return vec4(material.color1, 1);\n    } else {\n        return vec4(material.color2, 1);\n    }\n}\n\n"},7793:e=>{e.exports="\n                                                                                                                        \n                       \n                                                                                                                        \n"},4743:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct EquidistantHypStripsMaterial {\n    float distance;\n    float width;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(EquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float distP = atanh(uv.x);\n    float k = round(distP / material.distance);\n    vec2 q = horizontalTranslate(uv, -k * material.distance);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1917:e=>{e.exports="                                                                                                                        \n                                                  \n                                                                                                                        \n\nstruct EquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n\nvec4 render(EquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n    float theta = uv.x;\n    float phi = uv.y;\n    theta = theta - round(theta / material.distance) * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n                                                                                            \n    if (cosDistSq > material.cosHalfWidthSq) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},3801:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct GraphPaperMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\n\nfloat gridLines(vec2 uv, float size){\n    float brightness = 1./(2.*sqrt(size));\n    float gridPattern = abs(sin(3.14*size*uv.x)*sin(1.*3.14*size*uv.y));\n                                   \n    gridPattern = 1.-clamp(pow(gridPattern,0.05),0.,1.);\n    return gridPattern*brightness;\n}\n\nfloat grid(vec2 uv){\n    float grid1 = gridLines(uv,1.);\n    float grid2 = gridLines(uv,5.);\n    float grid3 = gridLines(uv,10.);\n    float grid4 = gridLines(uv,50.);\n    float gridTotal = grid1+grid2+grid3+grid4;\n    gridTotal *=5.;\n   return gridTotal;\n}\n\nvec4 render(GraphPaperMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    float gridPattern = grid(vec2(x1,x2));\n\n    vec3 col1 = material.color1*(1.-gridPattern);\n    vec3 col2 = material.color2*gridPattern;\n    return vec4(col1+col2,1.);\n\n}\n\n"},2278:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightLocalWrapMaterial {\n    GroupElement cellBoost;\n    bool isHighlightOn;\n};\n"},3048:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct HighlightWrapMaterial {\n    bool isHighlightOn;\n};\n"},7685:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct HypStripsMaterial {\n    float totalWidth;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n};\n\nvec4 render(HypStripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float aux = clamp(uv.x, -1., 1.);\n    float dist = atanh(aux);\n    float x = mod(dist / material.totalWidth, 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}"},4566:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantHypStripsMaterial {\n    float distance;\n    float halfWidth;\n    vec3 stripColor;\n    vec3 bgColor;\n};\n\n  \n                                                                     \n                                                                           \n   \nfloat distToYAxis(vec2 m) {\n    float aux = sqrt(1. - m.y * m.y);\n    return 0.5 * log((aux + m.x) / (aux - m.x));\n}\n\n                                                                                     \n                                                  \n   \nvec2 horizontalTranslate(vec2 m, float t) {\n    float ch = cosh(t);\n    float sh = sinh(t);\n    float x = m.x * ch + sh;\n    float den = m.x * sh + ch;\n    return vec2(x / den, m.y / den);\n}\n\nvec4 render(ImprovedEquidistantHypStripsMaterial material, ExtVector v, vec2 uv) {\n    float t = atanh(uv.x) - material.distance;\n    vec2 m = horizontalTranslate(uv, -t);\n    float distM = abs(distToYAxis(m));\n    float n = floor(log(distM / material.distance) / log(2.));\n\n    float distP = atanh(uv.x);\n    float period = pow(2., -n) * material.distance;\n    float k = round(distP / period);\n    vec2 q = horizontalTranslate(uv, -k * period);\n    float distQ = distToYAxis(q);\n    if (abs(distQ) < material.width) {\n        return vec4(material.stripColor, 1);\n    }\n    else {\n        return vec4(material.bgColor, 1);\n    }\n}"},1650:e=>{e.exports="                                                                                                                        \n                                                                 \n                                                                                                                        \n\nstruct ImprovedEquidistantSphStripsMaterial {\n    float distance;\n    float cosHalfWidthSq;\n    float fadingAmplitude;\n    vec3 stripColor;\n    vec3 bgColor;\n    mat4 rotation;\n};\n\nvec4 render(ImprovedEquidistantSphStripsMaterial material, ExtVector v, vec2 uv) {\n                         \n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n\n\n                                                                                              \n    float ln2 = 0.6931471;                               \n\n    float theta = rotatedUV.x;\n    float phi = rotatedUV.y;\n    float k = round(theta / material.distance);\n    theta = theta - k * material.distance;\n    float aux = sin(phi) * sin(theta);\n    float cosDistSq = 1. - aux * aux;\n\n                                                                                            \n    if (cosDistSq < material.cosHalfWidthSq) {\n                                                               \n        return vec4(material.bgColor, 1);\n    }\n    if (k == 0.) {\n        return vec4(material.stripColor, 1);\n    }\n\n                                                                        \n                                                                             \n    int kInt = int(k);\n    int nInt = kInt & (~kInt + 1);\n    float n = float(nInt);\n                                \n                                                                                        \n    float theta0 = material.distance;\n    float theta1 = n * theta0;\n\n                                                    \n                                   \n                                                  \n           \n\n    float c = 0.66;\n    float sinPh1 = sin(c * theta0) / sin(theta1);\n    float phi1 = asin(clamp(sinPh1, 0., 1.));\n\n    float coeff = ((0.5 * PI - phi1) - abs(0.5 * PI - phi)) / material.fadingAmplitude + 0.5;\n    coeff = clamp(coeff, 0., 1.);\n    vec3 base = coeff * material.stripColor + (1. - coeff) * material.bgColor;\n    return vec4(base, 1);\n\n                         \n                                                                                       \n                                                                           \n                                       \n                                                        \n      \n                                                        \n}"},3496:e=>{e.exports="                                                                                                                        \n                  \n                                            \n                                                     \n                                                                                                                        \n\nvec4 normalMaterialRender(ExtVector v, RelVector normal) {\n    Vector[3] f;\n    Point pos = applyGroupElement(v.vector.cellBoost, v.vector.local.pos);\n    frame(pos, f);\n\n    f[0] = applyGroupElement(v.vector.invCellBoost, f[0]);\n    f[1] = applyGroupElement(v.vector.invCellBoost, f[1]);\n    f[2] = applyGroupElement(v.vector.invCellBoost, f[2]);\n    \n                  \n                            \n    float r =  geomDot(normal.local, f[0]);\n    float g =  geomDot(normal.local, f[1]);\n    float b =  geomDot(normal.local, f[2]);\n    return abs(vec4(r, g, b, 1));\n}"},7198:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct PathTracerWrapMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(PathTracerWrapMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\n"},6045:e=>{e.exports="                                                                                                                        \n                 \n                                                                                                                        \n\nstruct PhongMaterial {\n    vec3 color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, PhongMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * material.color;\n    vec3 ambient = ambientCoeff * ambientLight * material.color;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},5836:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct PhongWrapMaterial {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, vec3 baseColor, PhongWrapMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * baseColor;\n    vec3 ambient = ambientCoeff * ambientLight * baseColor;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},1220:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct RotatedSphericalTextureMaterial {\n    sampler2D sampler;\n    mat4 rotation;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(RotatedSphericalTextureMaterial material, ExtVector v, vec2 uv) {\n    vec4 origDir = vec4(vec2(cos(uv.x), sin(uv.x)) * sin(uv.y), cos(uv.y), 0.);\n    vec4 rotatedDir = material.rotation * origDir;\n    float sinPhi = length(rotatedDir.xy);\n    float cosPhi = rotatedDir.z;\n    float uCoord = atan(rotatedDir.y, rotatedDir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    vec2 rotatedUV = vec2(uCoord, vCoord);\n    vec2 texCoords = (rotatedUV - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},9095:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SimpleTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(SimpleTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},2664:e=>{e.exports="                                                                                                                        \n                        \n                                                                                                                        \n\nstruct SingleColorMaterial {\n    vec3 color;\n};\n\nvec4 render(SingleColorMaterial material, ExtVector v) {\n    return vec4(material.color, 1);\n}"},3081:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SquaresMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(SquaresMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x1 = mod(dot(uv, material.dir1) / dot(material.dir1, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2) / dot(material.dir2, material.dir2), 2.);\n    float c1 = abs(x1 - 1.);\n    float c2 = abs(x2 - 1.);\n    if (c1 < material.lengths.x && c2 < material.lengths.x){\n        color = material.color0;\n    } else if (c1 < material.lengths.y && c2 < material.lengths.y){\n        color = material.color1;\n    } else if (c1 < material.lengths.z && c2 < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n    return vec4(color, 1);\n}\n\n"},9835:e=>{e.exports="                                                                                                                        \n          \n                  \n                                                                                                                        \nstruct StripsMaterial {\n    vec2 dir;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec4 render(StripsMaterial material, ExtVector v, vec2 uv) {\n    vec3 color;\n    float x = mod(dot(uv, material.dir) / dot(material.dir, material.dir), 1.);\n    if (x < material.lengths.x){\n        color = material.color0;\n    } else if (x < material.lengths.y){\n        color = material.color1;\n    } else if (x < material.lengths.z){\n        color = material.color2;\n    } else {\n        color = material.color3;\n    }\n\n    return vec4(color, 1);\n}\n\n"},1888:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionLocalWrapMaterial {\n    GroupElement cellBoost;\n    float ratio;\n};\n"},5698:e=>{e.exports="                                                                                                                        \n          \n                     \n                                                                                                                        \n\nstruct TransitionWrapMaterial {\n    float ratio;\n};\n"},2229:e=>{e.exports="\n\n                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoAlphaTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoAlphaTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    vec2 texCoordsUV = vec2(texCoords.x, 0.5 + 0.5 * texCoords.y);\n    vec2 texCoordsAlpha = vec2(texCoords.x, 0.5 * texCoords.y);\n    vec4 color =  texture(material.sampler, texCoordsUV);\n    float alpha = texture(material.sampler, texCoordsAlpha).x;\n    return vec4(color.rgb, alpha);\n}"},4680:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoFrameTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoFrameTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},533:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct VideoTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec4 render(VideoTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    return texture(material.sampler, texCoords);\n}\n\n\n"},6947:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = exposure * color.rgb;\n    pixelColor = ACESFilm(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},2690:e=>{e.exports="uniform sampler2D tDiffuse;\nuniform float exposure;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 postProcess(vec3 pixelColor){\n\n                      \n    pixelColor *= exposure;\n\n                   \n    pixelColor = ACESFilm(pixelColor);\n    pixelColor = LinearToSRGB(pixelColor);\n\n    return pixelColor;\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 aux = postProcess(color.rgb);\n    gl_FragColor = vec4(min(vec3(1.0), aux), color.a);\n}"},4024:e=>{e.exports="uniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n    (f.x < value) ? 1.0f : 0.0f,\n    (f.y < value) ? 1.0f : 0.0f,\n    (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n    pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n    rgb * 12.92f,\n    LessThan(rgb, 0.0031308f)\n    );\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    vec3 pixelColor = color.rgb;\n    pixelColor = LinearToSRGB(pixelColor);\n    gl_FragColor = vec4(min(vec3(1.0), pixelColor), color.a);\n}"},5348:e=>{e.exports="vec3 applyFog(vec3 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * fog.color;\n}\n\nvec4 applyFog(vec4 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * vec4(fog.color, 1);\n}"},7885:e=>{e.exports="                                                                                                                        \n  \n          \n                                 \n  \n                                                                                                                        \n\nstruct ExpFog {\n    vec3 color;                             \n    float scattering;                                                    \n};\n"},7333:e=>{e.exports="struct IntersectionShape {\n    float maxCoeff;\n};"},519:e=>{e.exports="struct UnionShape {\n    float minCoeff;\n};\n"},4750:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec3 dir = vec3(coords.xy, -1. / tan(0.5 * camera.fovRadians));\n    Vector v = createVector(ORIGIN, dir);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},8710:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fovRadians;                                          \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},6224:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},6684:e=>{e.exports="   \n                                                                                                 \n                                                                                        \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}\n\n   \n                                                                                             \n                                                               \n   \nRelVector mappingFromFlatScreen(vec2 coords) {\n                                                         \n    vec2 jitter = vec2(randomFloat(), randomFloat()) - 0.5;\n\n                                                                            \n    vec2 planeCoords = (coords - 0.5 * resolution + jitter) / (0.5 * resolution.y);\n\n                              \n    float z = - 1. / tan(radians(0.5 * camera.fov));\n\n                                                      \n    vec4 dir = vec4(planeCoords, z, 0);\n\n                                \n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},6354:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n    float focalLength;                    \n    float aperture;                \n};"},9222:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}\n\n                     \n\n  \n                               \n                               \n                         \n                                             \n                                                      \n                              \n \n  "},5970:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},5682:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n\nvarying vec3 screenPosition;\n\n   \n                                      \n                                                                    \n                                                                               \n                                                 \n  \n                                                                \n                                                        \n                                                  \n                                                                                     \n   \nvoid main()\n{\n                                 \n                                                       \n    mat4 rot = modelViewMatrix;\n    rot[3] = vec4(0, 0, 0, 1);\n\n    vec4 aux = rot * vec4(position, 1.0);\n    screenPosition = aux.xyz;\n    gl_Position = projectionMatrix * rot * aux;\n}"},4770:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}"},8415:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float safetyDist;                                                                               \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},190:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n\nVector geomMix(Vector v1, Vector v2, float a){\n    return add(multiplyScalar(1.-a, v1), multiplyScalar(a, v2));\n}\n\n   \n                                           \n                         \n             \n   \nVector negate(Vector v) {\n    return multiplyScalar(-1., v);\n}\n\n\n   \n                                         \n                       \n   \nfloat geomLength(Vector v){\n    return sqrt(geomDot(v, v));\n}\n\n   \n                                                          \n                            \n   \nVector geomNormalize(Vector v){\n    float a = geomLength(v);\n    return multiplyScalar(1./a, v);\n}\n\n   \n                                                     \n   \nfloat cosAngle(Vector v1, Vector v2){\n    float a1 = geomLength(v1);\n    float a2 = geomLength(v2);\n    return geomDot(v1, v2)/ (a1 * a2);\n}\n\n   \n                                                           \n                                   \n                                                                                                        \n                                     \n                                                                   \n                                                                       \n   \nVector geomReflect(Vector v, Vector n){\n    return sub(v, multiplyScalar(2. * geomDot(v, n), n));\n}\n\n\n   \n                                         \n                                                                        \n                                                                                   \n                                              \n   \nVector geomRefract(Vector v, Vector n, float r){\n    float cosTheta1 = -geomDot(n, v);\n    float sinTheta2Sq = r * r * (1. - cosTheta1 * cosTheta1);\n\n    if (sinTheta2Sq > 1.){\n               \n        return zeroVector(v.pos);\n    }\n                                                                 \n    float cosTheta2 = sqrt(1. - sinTheta2Sq);\n    float aux = r * cosTheta1 - cosTheta2;\n    return add(multiplyScalar(r, v), multiplyScalar(aux, n));\n}\n\n   \n                                                                          \n                                           \n   \nIsometry makeTranslation(Vector v) {\n    return makeTranslation(v.pos);\n}\n\n   \n                                                                          \n                                              \n   \nIsometry makeInvTranslation(Vector v) {\n    return makeInvTranslation(v.pos);\n}\n"},4168:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                                                                         \n               \n   \nVector createVector(Point p, vec3 coords, Vector[3] frame){\n    Vector c0 = multiplyScalar(coords[0], frame[0]);\n    Vector c1 = multiplyScalar(coords[1], frame[1]);\n    Vector c2 = multiplyScalar(coords[2], frame[2]);\n    return add(c0, add(c1, c2));\n}\n\n\n\n   \n                                                                                          \n               \n   \nVector createVector(Point p, vec3 coords){\n    Vector[3] f;\n    frame(p, f);\n    return createVector(p, coords, f);\n}\n\n   \n                                                                                          \n               \n   \nVector createVectorOrtho(Point p, vec3 coords){\n    Vector[3] f;\n    orthoFrame(p, f);\n    return createVector(p, coords, f);\n}\n\n\n                                                                                                                        \n  \n                   \n                                                             \n                                                                       \n  \n                                                                                                                        \n\nstruct Position {\n    Isometry boost;\n    mat4 facing;\n};\n\n\n   \n                                        \n                          \n                                           \n   \nVector applyPosition(Position p, Vector v){\n    Vector res = applyFacing(p.facing, v);\n    return applyIsometry(p.boost, res);\n}"},2311:e=>{e.exports="   \n              \n                                \n   \nPoint applyIsometry(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\nPoint applyGroupElement(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\n   \n              \n                                \n   \nVector applyIsometry(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\nVector applyGroupElement(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\n\n"},5315:e=>{e.exports="   \n                          \n   \nvarying vec3 screenPosition;\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    RelVector vector = mapping(screenPosition);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = postProcess(getColor(v));\n}"},6159:e=>{e.exports="vec4 postProcess(vec4 color) {\n    return color;\n}"},2977:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n        }\n    }\n\n                               \n                     \n       \n\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + dist;\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    v = flow(v, camera.safetyDist);\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = raymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return v.data.pixel;\n}"},9461:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec4 pixel;                                                                   \n    vec4 leftToComputeColor;                                                                      \n};"},1767:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                             \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n              \n   \nconst float PI = 3.1415926538;\n\n   \n                      \n   \nvec4 debugColor = vec4(0.5, 0, 0.8, 1);\n\n   \n                                    \n         \n   \nconst int HIT_NOTHING = 0;\n   \n                                    \n         \n   \nconst int HIT_SOLID = 1;\n   \n                                  \n         \n   \nconst int HIT_DEBUG = -1;\n"},7962:e=>{e.exports="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"},8187:e=>{e.exports="   \n                          \n   \nvarying vec3 spherePosition;\n\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    initSeed(gl_FragCoord.xy, frameSeed);\n    RelVector vector = mappingFromFlatScreen(gl_FragCoord.xy);\n    ExtVector v = ExtVector(vector, initVectorData());\n    gl_FragColor = getColor(v);\n}\n"},9638:e=>{e.exports="   \n                                                \n  \n   \nuint seed;\n\n   \n                                                \n                                                                  \n                                                \n                                                                                                         \n   \nvoid initSeed(vec2 coords, uint frameSeed){\n    uvec2 aux = uvec2(coords);\n    seed =  aux.x * uint(1973) + aux.y * uint(925277) + frameSeed * uint(26699) | uint(1);\n}\n\n   \n                           \n               \n                                                                                                     \n   \nuint wangHash() {\n    seed = (seed ^ uint(61)) ^ (seed >> uint(16));\n    seed = seed * uint(9);\n    seed = seed ^ (seed >> 4);\n    seed = seed * uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n   \n                                                  \n   \nfloat randomFloat() {\n    return float(wangHash()) / 4294967296.;\n}\n\n   \n                                                                           \n                                                                                                    \n                                                                                                       \n                                          \n   \nvec3 randomUnitVec3() {\n    float z = randomFloat() * 2. - 1.;\n    float theta = randomFloat() * 2. * PI;\n    float r = sqrt(1. - z * z);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x, y, z);\n}\n\n   \n                                                   \n                                                      \n   \nVector randomVector(Point p) {\n    vec3 dir = randomUnitVec3();\n    return createVectorOrtho(p, dir);\n}\n\n   \n                                                                     \n                                                                                               \n   \nvec2 randomNormal2D(){\n    float u = randomFloat();\n    float v = randomFloat();\n\n    float r = sqrt(abs(2. * log(u)));\n    float x = r * cos(2. * PI * v);\n    float y = r * sin(2. * PI * v);\n\n    return vec2(x, y);\n\n}\n\n   \n                                                      \n   \nfloat randomNormal(float mean, float stdev){\n\n                           \n    float x = randomNormal2D().x;\n\n                                   \n    return stdev * x + mean;\n}\n"},7920:e=>{e.exports="   \n                                                                                      \n  \n   \n\n\n   \n                                                                                   \n                                                                          \n                                                       \n   \nRelVector randomVector(RelVector v) {\n    v.local = randomVector(v.local.pos);\n    return v;\n}"},3499:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n                                                                  \n                                                                                         \n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + abs(dist);\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nbool doesItScatter(inout float dist, float opticalDepth){\n                          \n    if (opticalDepth>100.){\n        return false;\n    }\n    else {\n        float probScatter=1.-exp(-dist/opticalDepth);\n        float flip=randomFloat();\n        if (flip<probScatter){\n                                           \n                                                \n            dist=dist*randomFloat();\n            return true;\n        }\n                                              \n        return false;\n    }\n}\n\n\nvoid scatterRay(inout ExtVector v){\n                                         \n    RelVector w=randomVector(v.vector);\n\n                                                 \n                                                  \n    v.vector=w;\n                                             \n                                                      \n}\n\n\n\nint scatterRaymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n    float d;\n    bool doScatter;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n\n                                          \n            d=abs(dist);\n            doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                                \n            marchingStep = marchingStep + creepingDist(localV, d, camera.threshold);\n            localV = flow(localV0, marchingStep);\n\n\n                                               \n                                                                              \n\n                                                       \n            if (doScatter){\n                scatterRay(localV);\n            }\n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n\n                                      \n        d=abs(dist);\n        doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                            \n        marchingStep = marchingStep + d;\n        globalV = flow(globalV0, marchingStep);\n\n                                                   \n        if (doScatter){\n            scatterRay(globalV);\n        }\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec4 getColor(ExtVector v){\n    int objId;\n    int hit;\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = scatterRaymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return vec4(v.data.pixel,1);\n}"},3888:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n           \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct RayType{\n    bool diffuse;\n    bool reflect;\n    bool refract;\n    float chance;\n};\n\n                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec3 pixel;         \n    vec3 light;         \n    vec3 currentAbsorb;                                                    \n    vec3 currentEmission;                                                             \n    float currentOpticalDepth;                                                              \n    bool isInside;                                        \n};\n\n"},8351:e=>{e.exports="vec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\n                  \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n\n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n              \nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n}\n\nvec4 postProcess(vec4 pixelColor) {\n\n                      \n    pixelColor.xyz *= exposure;\n\n                   \n    pixelColor.xyz = ACESFilm(pixelColor.xyz);\n    pixelColor.xyz = LinearToSRGB(pixelColor.xyz);\n\n    return pixelColor;\n}"},7499:e=>{e.exports="                                                                                                                        \n  \n           \n                               \n  \n                                                                                                                        \n \n struct Solid {\n    bool isRendered;\n };\n"},7970:e=>{e.exports="                                                                                                                        \n  \n                      \n                                                        \n                                                                     \n                        \n                                                                                 \n                                                                                 \n                                                                                   \n                                                                                    \n                                                                       \n                                                                                                                        \n\nstruct RelPosition {\n    Position local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n                                                                                                                        \n  \n                    \n                                  \n                                                                       \n                      \n                                                                                 \n                                                                                 \n                                                                            \n                                                                                    \n                                                                                                                        \n\nstruct RelVector {\n    Vector local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n   \n                                                            \n   \nRelVector reduceError(RelVector v){\n    v.local = reduceError(v.local);\n    return v;\n}\n\n   \n                         \n                            \n                                                      \n   \nRelVector add(RelVector v1, RelVector v2){\n    v1.local = add(v1.local, v2.local);\n    return v1;\n}\n\n   \n                              \n                            \n                                                      \n   \nRelVector sub(RelVector v1, RelVector v2){\n    v1.local = sub(v1.local, v2.local);\n    return v1;\n}\n\n   \n                                   \n                         \n                      \n   \nRelVector multiplyScalar(float s, RelVector v){\n    v.local = multiplyScalar(s, v.local);\n    return v;\n}\n\n   \n                                                                                 \n                     \n                                                        \n   \nfloat geomDot(RelVector v1, RelVector v2) {\n    return geomDot(v1.local, v2.local);\n}\n\n   \n                              \n   \nRelVector geomNormalize(RelVector v){\n    v.local = geomNormalize(v.local);\n    return v;\n}\n\n   \n                                   \n                                                        \n   \nRelVector geomMix(RelVector v1, RelVector v2, float a) {\n    v1.local = geomMix(v1.local, v2.local, a);\n    return v1;\n}\n\n   \n                                            \n   \nRelVector negate(RelVector v){\n    v.local = negate(v.local);\n    return v;\n}\n\n   \n                                                                     \n                                                       \n   \nRelVector geomReflect(RelVector v, RelVector normal){\n    v.local = geomReflect(v.local, normal.local);\n    return v;\n}\n\n\n   \n                                                                     \n                                                       \n   \nRelVector geomRefract(RelVector v, RelVector normal, float n){\n    v.local = geomRefract(v.local, normal.local, n);\n    return v;\n}\n\n   \n                         \n                                            \n                                                                         \n   \nRelVector flow(RelVector v, float t) {\n    v.local = flow(v.local, t);\n    return v;\n}\n\n   \n                                                                                          \n                                                                           \n                                                                          \n                               \n                                                                                              \n   \nRelVector smallShift(RelVector v, vec3 dp){\n    v.local = smallShift(v.local, dp);\n    return v;\n                                                 \n                                                               \n}\n\n\n   \n                                                                                                            \n                           \n                                                   \n                                                                                             \n                                            \n   \n                                                   \n                                                   \n               \n                                                             \n                                                                 \n   \n\n   \n                                                                                                            \n                                                   \n                                                                                             \n   \nRelVector createRelVector(RelVector v, vec3 coords){\n    v.local =  createVector(v.local.pos, coords);\n    return v;\n                                                           \n                                                               \n}\n\n   \n                                                                  \n                          \n                                           \n   \nRelVector applyPosition(RelPosition position, Vector v) {\n    Vector local = applyPosition(position.local, v);\n    return RelVector(local, position.cellBoost, position.invCellBoost);\n}\n\n   \n                                                                                                                    \n   \nRelVector rewrite(RelVector v, GroupElement elt, GroupElement inv){\n    v.local = applyGroupElement(elt, v.local);\n                                     \n                                       \n    v.cellBoost = multiply(v.cellBoost, inv);\n    v.invCellBoost = multiply(elt, v.invCellBoost);\n    return v;\n}\n\n\n                                                                                                                        \n  \n                    \n                                    \n                                                                              \n                  \n                                                      \n                                                                                         \n  \n                                                                                                                        \n\nstruct ExtVector {\n    RelVector vector;\n    VectorData data;\n};\n\n\nExtVector flow(ExtVector v, float t) {\n    v.vector = flow(v.vector, t);\n    v.data.lastFlowDist = t;\n    v.data.lastBounceDist = v.data.lastBounceDist + t;\n    v.data.totalDist  = v.data.totalDist + t;\n    return v;\n}\n\n\n\n"},5350:e=>{e.exports="                                                                                                                        \n        \n                                                        \n                                                   \n                                                                               \n                                                                                                                        \n\n\n\n                                                                                                                        \n  \n                   \n                                            \n  \n                                                                                                                        \nstruct Isometry{\n    mat4 matrix;\n};\n\n   \n                    \n   \nconst Isometry IDENTITY = Isometry(mat4(1.));                          \n\n   \n                                                              \n   \nIsometry reduceError(Isometry isom){\n    return isom;\n}\n\n   \n                                     \n   \nIsometry multiply(Isometry isom1, Isometry isom2) {\n    return Isometry(isom1.matrix * isom2.matrix);\n}\n\n   \n                                            \n   \nIsometry geomInverse(Isometry isom) {\n    return Isometry(inverse(isom.matrix));\n}\n\n                                                                                                                        \n  \n                \n                                        \n  \n                                                                                                                        \nstruct Point{\n    vec4 coords;\n};\n\n\nconst Point ORIGIN = Point(vec4(0, 0, 0, 1));                               \n\n   \n                                                           \n   \nPoint reduceError(Point p){\n    return Point(normalize(p.coords));\n}\n\n   \n                                       \n   \nPoint applyIsometry(Isometry isom, Point p) {\n    vec4 coords = isom.matrix * p.coords;\n    Point res = Point(coords);\n    return reduceError(res);\n}\n\n   \n                                                                     \n                                  \n   \n\nIsometry makeTranslation(Point p) {\n    mat4 matrix = mat4(1.);\n    vec3 u = p.coords.xyz;\n    float c1 = length(u);\n    if (c1 == 0.) {\n        return Isometry(matrix);\n    }\n\n    float c2 = 1. - p.coords.w;\n    u = normalize(u);\n    mat4 m = mat4(\n    0, 0, 0, -u.x,\n    0, 0, 0, -u.y,\n    0, 0, 0, -u.z,\n    u.x, u.y, u.z, 0\n    );\n    matrix = matrix + c1 * m + c2 * m * m;\n    return Isometry(matrix);\n}\n\n   \n                                                                     \n                                     \n   \nIsometry makeInvTranslation(Point p) {\n    Isometry isom = makeTranslation(p);\n    return geomInverse(isom);\n}\n\n                                                                                                                        \n  \n                 \n                                                              \n                                                                                                  \n  \n                                                                                                                        \nstruct Vector{\n    Point pos;                         \n    vec4 dir;                                \n};\n\n   \n                                \n   \nVector zeroVector(Point pos){\n    return Vector(pos, vec4(0));\n}\n\n   \n                                                            \n   \nVector reduceError(Vector v){\n    return Vector(reduceError(v.pos), v.dir);\n}\n\n   \n                         \n                            \n   \nVector add(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir + v2.dir);\n}\n\n   \n                              \n                            \n   \nVector sub(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir - v2.dir);\n}\n\n   \n                                   \n                         \n                      \n   \nVector multiplyScalar(float s, Vector v){\n    return Vector(v.pos, s * v.dir);\n}\n\n   \n                                                                                 \n                     \n   \nfloat geomDot(Vector v1, Vector v2) {\n    return dot(v1.dir, v2.dir);\n}\n\n   \n                                        \n   \nVector applyIsometry(Isometry isom, Vector v) {\n    Point p = applyIsometry(isom, v.pos);\n    return Vector(p, isom.matrix * v.dir);\n}\n\n\n   \n                                                                       \n                                                                                                           \n                                           \n   \nVector applyFacing(mat4 m, Vector v) {\n    return Vector(v.pos, m * v.dir);\n}\n\nvoid initFlow(Vector v){\n}"},7772:e=>{e.exports="   \n                               \n                                                                       \n                                     \n                                                      \n   \nvoid frame(Point p, out Vector[3] f){\n    vec4 dir0 = vec4(p.coords.w, 0, 0, -p.coords.x);\n    vec4 dir1 = vec4(0, p.coords.w, 0, -p.coords.y);\n    vec4 dir2 = vec4(0, 0, p.coords.w, -p.coords.z);\n    dir0 = normalize(dir0);\n    dir1 = normalize(dir1);\n    dir2 = normalize(dir2);\n    f[0] = Vector(p, dir0);\n    f[1] = Vector(p, dir1);\n    f[2] = Vector(p, dir2);\n}\n\n   \n                                           \n                                                                       \n                                                                      \n                                     \n                                                      \n   \nvoid orthoFrame(Point p, out Vector[3] f){\n    float x = p.coords.x;\n    float y = p.coords.y;\n    float z = p.coords.z;\n    float w = p.coords.w;\n\n    float den = 1. + w;\n    vec4 dir0 = (1. / den) * vec4(-x * x + w + 1., -x * y, -x * z, -x * den);\n    vec4 dir1 = (1. / den) * vec4(-x * y, -y * y + w + 1., -y * z, -y * den);\n    vec4 dir2 = (1. / den) * vec4(-x * z, -y * z, -z * z + w + 1., -z * den);\n\n    f[0] = Vector(p, dir0);\n    f[1] = Vector(p, dir1);\n    f[2] = Vector(p, dir2);\n}\n\n\n   \n                                                                                         \n                              \n                                                                                              \n   \nPoint smallShift(Point p, vec3 dp){\n    Vector[3] f;\n    frame(p, f);\n    vec4 coords = p.coords + dp[0] * f[0].dir + dp[1] * f[1].dir + dp[2] * f[2].dir;\n    Point res = Point(coords);\n    return reduceError(res);\n}\n\n\nVector smallShift(Vector v, vec3 dp){\n    Point pos = smallShift(v.pos, dp);\n    return Vector(pos, v.dir);\n}\n\n\n   \n                                  \n                                                 \n   \nVector flow(Vector v, float t){\n    vec4 coords = cos(t) * v.pos.coords + sin(t) * v.dir;\n    Point pos = Point(coords);\n    vec4 dir = -sin(t) * v.pos.coords + cos(t) * v.dir;\n    Vector res = Vector(pos, dir);\n    return reduceError(res);\n}\n"},4905:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                           \n                                                                                                                        \n\nstruct GroupElement {\n    ivec4 icoords;                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(ivec4(0, 0, 0, 1));\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    ivec4 c1 = elt1.icoords;\n    ivec4 c2 = elt2.icoords;\n    ivec4 c = ivec4(\n    c1.x * c2.w + c1.w * c2.x + c1.y * c2.z - c1.z * c2.y,\n    c1.y * c2.w + c1.w * c2.y + c1.z * c2.x - c1.x * c2.z,\n    c1.z * c2.w + c1.w * c2.z + c1.x * c2.y - c1.y * c2.x,\n    c1.w * c2.w - c1.x * c2.x - c1.y * c2.y - c1.z * c2.z\n    );\n    return GroupElement(c);\n}\n\n                                              \n                                                                                                \n   \n\nIsometry toIsometry(GroupElement elt) {\n    vec4 c = vec4(elt.icoords);\n    mat4 matrix =  mat4(\n    c.w, c.z, c.y, c.x,\n    -c.z, c.w, -c.x, c.y,\n    -c.y, c.x, c.w, -c.z,\n    -c.x, -c.y, c.z, c.w\n    );\n    return Isometry(matrix);\n}"},217:e=>{e.exports="   \n                        \n   \nVector direction(Point p, Point q) {\n    float c = dot(p.coords, q.coords);\n    vec4 dir = q.coords - c * p.coords;\n    return geomNormalize(Vector(p, dir));\n}"},3830:e=>{e.exports="   \n                              \n   \nfloat dist(Point p1, Point p2){\n    return abs(acos(dot(p1.coords, p2.coords)));\n}"},1156:e=>{e.exports="   \n                                                                                    \n                                                   \n                                         \n                                 \n   \nfloat lightIntensity(float len){\n    return 1./(len);\n}"},7520:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct ConstDirLight {\n    int id;\n    vec3 color;\n    float intensity;\n    vec4 direction;\n    int maxDirs;\n};\n\nbool directions(ConstDirLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i != 0){\n        return false;\n    }\n    intensity = light.intensity;\n    Vector local = Vector(v.local.pos, light.direction);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}\n"},9182:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct LocalPointLight {\n    int id;\n    Point position;\n    vec3 color;\n    float intensity;\n    int maxDirs;\n};\n\n                                                                                                                        \n          \n                                                  \n                                              \n                                                                                                                \n                                                                                                                        \n\nstruct PointLightComputations{\n    RelVector dir;\n    float dist;\n};\n\nPointLightComputations pointLightComputations;\n\nbool directions(LocalPointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i>1){\n        return false;\n    }\n    if (i==0){\n                                                                         \n        float dist = dist(v.local.pos, light.position);\n        intensity = lightIntensity(dist) * light.intensity;\n        Vector local = direction(v.local.pos, light.position);\n        dir = RelVector(local, v.cellBoost, v.invCellBoost);\n        pointLightComputations = PointLightComputations(dir, dist);\n    }\n    if (i==1){\n        intensity = lightIntensity(2. * PI - pointLightComputations.dist);\n        dir = negate(pointLightComputations.dir);\n    }\n    return true;\n}"},3483:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \n\nstruct PointLight {\n    int id;\n    Point position;\n    vec3 color;\n    float intensity;\n    int maxDirs;\n};\n\n                                                                                                                        \n          \n                                                  \n                                              \n                                                                                                                \n                                                                                                                        \n\nstruct PointLightComputations{\n    RelVector dir;\n    float dist;\n};\n\nPointLightComputations pointLightComputations;\n\nbool directions(PointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i>1){\n        return false;\n    }\n    if (i==0){\n        Point position = applyIsometry(v.invCellBoost, light.position);\n        float dist = dist(v.local.pos, position);\n        intensity = lightIntensity(dist) * light.intensity;\n        Vector local = direction(v.local.pos, position);\n        dir = RelVector(local, v.cellBoost, v.invCellBoost);\n        pointLightComputations = PointLightComputations(dir, dist);\n    }\n    if (i==1){\n        intensity = lightIntensity(2. * PI - pointLightComputations.dist);\n        dir = negate(pointLightComputations.dir);\n    }\n    return true;\n}"},3889:e=>{e.exports="                                                                                                                        \n                       \n                                                                                                                        \n\nstruct MultiColorMaterial {\n    vec3 mainColor;\n    vec3 accent1;\n    vec3 accent2;\n    vec3 accent3;\n    bool grid;\n};\n\nvec4 render(MultiColorMaterial material, ExtVector v) {\n\n    vec3 dir = normalize(v.vector.local.pos.coords.xyz);\n    float height = acos(v.vector.local.pos.coords.w);\n\n    float cosphi = dir.z;\n    float sinphi = length(dir.xy);\n    float phi = atan(sinphi,cosphi);\n    float theta = atan(dir.y,dir.x);\n\n    vec3 color = material.mainColor;\n    color += material.accent1 * dir.x;\n    color += material.accent2 * dir.y;\n    color += material.accent3 * dir.z;\n\n    if(material.grid){\n        float test = sin(70.*phi)*sin(70.*theta)*sin(70.*height);\n        float sgn = sign(test);\n        if (sgn<0.){\n            color *=0.9;\n        }\n    }\n\n    return vec4(color, 1);\n}"},4193:e=>{e.exports="                                                                                                                        \n                         \n                                                                                                                        \n\nstruct VaryingColorMaterial {\n    vec3 mainColor;\n    vec3 weight;\n};\n\nvec4 render(VaryingColorMaterial material, ExtVector v) {\n    vec3 color = material.mainColor + material.weight * v.vector.local.pos.coords.xyz;\n    return vec4(color, 1);\n}"},2473:e=>{e.exports="                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct BallShape {\n    int id;\n    Point center;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\nfloat sdf(BallShape ball, RelVector v) {\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    center = reduceError(center);\n    return dist(v.local.pos, center) - ball.radius;\n}\n\nRelVector gradient(BallShape ball, RelVector v){\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    Vector local = direction(v.local.pos, center);\n    return RelVector(negate(local), v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(BallShape ball, RelVector v){\n    Point pos = applyGroupElement(v.cellBoost, v.local.pos);\n    Vector direction = direction(ball.center, pos);\n    direction = applyIsometry(ball.absoluteIsomInv, direction);\n    vec4 dir = normalize(direction.dir);\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n"},9527:e=>{e.exports="                                                                                                                        \n          \n                                            \n                                                                                                                        \n\nstruct CircleShape {\n    int id;\n    float radius;\n    vec4 c;\n    Isometry absoluteIsomInv;\n    Isometry absoluteIsom;\n};\n\n   \n                           \n   \nfloat sdf(CircleShape circle, RelVector v) {\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    point = applyIsometry(circle.absoluteIsomInv, point);\n    vec4 p = point.coords;\n    float aux = circle.c.x * length(p.xy) + dot(circle.c.zw, p.zw);\n    return acos(aux) - circle.radius;\n}\n\n   \n                 \n   \nRelVector gradient(CircleShape circle, RelVector v){\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    point = applyIsometry(circle.absoluteIsomInv, point);\n    vec4 p = point.coords;\n    float lenXY = length(p.xy);\n    vec4 aux = vec4(circle.c.x * p. x / lenXY, circle.c.y * p.y / lenXY, circle.c.z, circle.c.w);\n    vec4 dir = aux - dot(aux, p) * p;\n    Vector local = Vector(point, dir);\n    local = applyIsometry(circle.absoluteIsom, local);\n    local = applyGroupElement(v.invCellBoost, local);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\n   \n                 \n                                                                        \n   \nvec2 uvMap(CircleShape circle, RelVector v){\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    point = applyIsometry(circle.absoluteIsomInv, point);\n    vec4 p = point.coords;\n    float lenXY = length(p.xy);\n    vec4 proj = vec4(circle.c.x * p.x / lenXY, circle.c.y * p.y / lenXY, circle.c.z, circle.c.w);\n    float uCoord = atan(proj.y, proj.x);\n    vec4 dir2p = p - proj - dot(p-proj, proj) * proj;\n    dir2p = normalize(dir2p);\n    float vCoord = atan(dir2p.w, dir2p.z);\n\n    return vec2(uCoord, vCoord);\n}\n"},8166:e=>{e.exports="                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct CliffordTorusShape {\n    int id;\n    Isometry absoluteIsomInv;\n    Isometry absoluteIsom;\n};\n\n   \n                    \n   \nfloat sdf(CliffordTorusShape torus, RelVector v) {\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    point = applyIsometry(torus.absoluteIsomInv, point);\n    vec4 p = point.coords;\n    float aux = length(p.xy) + length(p.zw);\n    float sign = sign(p.z * p.z + p.w * p.w - 0.5);\n    return sign * acos(aux / sqrt(2.));\n}\n\n   \n                 \n   \nRelVector gradient(CliffordTorusShape torus, RelVector v){\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    point = applyIsometry(torus.absoluteIsomInv, point);\n    vec4 p = point.coords;\n    float lenXY = length(p.xy);\n    float lenZW = length(p.zw);\n    vec4 aux = vec4(p.xy / lenXY, p.zw / lenZW) / sqrt(2.);\n    vec4 dir = aux - dot(aux, p) * p;\n    Vector local = Vector(point, dir);\n    local = applyIsometry(torus.absoluteIsom, local);\n    local = applyGroupElement(v.invCellBoost, local);\n    local = geomNormalize(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\n   \n                 \n   \nvec2 uvMap(CliffordTorusShape torus, RelVector v){\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    point = applyIsometry(torus.absoluteIsomInv, point);\n    vec4 p = point.coords;\n    float uCoord = atan(p.y, p.x);\n    float vCoord = atan(p.w, p.z);\n    return vec2(uCoord, vCoord);\n}\n"},9474:e=>{e.exports="                                                                                                                        \n          \n                                            \n                                                                                                                        \n\nstruct CylinderShape {\n    int id;\n    Vector direction;\n    float radius;\n    vec4 uvTestX;\n    vec4 uvTestY;\n};\n\n   \n                           \n   \nfloat sdf(CylinderShape cyl, RelVector v) {\n    Vector dir = applyGroupElement(v.invCellBoost, cyl.direction);\n    float aux1 = dot(v.local.pos.coords, dir.pos.coords);\n    float aux2 = dot(v.local.pos.coords, dir.dir);\n    return abs(acos(sqrt(aux1 * aux1 + aux2 * aux2))) - cyl.radius;\n}\n\n   \n                                              \n   \nRelVector gradient(CylinderShape cyl, RelVector v){\n    vec4 m = v.local.pos.coords;\n    Vector dir = applyGroupElement(v.invCellBoost, cyl.direction);\n    float aux1 = dot(m, dir.pos.coords);\n    float aux2 = dot(m, dir.dir);\n    float den = sqrt(aux1 * aux1 + aux2 * aux2);\n    vec4 coords = (aux1/den) * dir.pos.coords + (aux2/den) * dir.dir;\n    Point proj = Point(coords);\n    Vector local = direction(v.local.pos, proj);\n    local = negate(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(CylinderShape cyl, RelVector v){\n    vec4 m = v.local.pos.coords;\n    Vector dir = applyGroupElement(v.invCellBoost, cyl.direction);\n    float aux1 = dot(m, dir.pos.coords);\n    float aux2 = dot(m, dir.dir);\n    vec4 proj = aux1 * dir.pos.coords + aux2 * dir.dir;\n    float uCoord = acos(dot(normalize(proj), dir.pos.coords));\n\n                                                                                                                       \n    vec4 aux = m - proj + length(proj) * dir.pos.coords;\n    float vCoord = atan(dot(aux, cyl.uvTestY), dot(aux, cyl.uvTestX));\n\n    return vec2(uCoord, vCoord);\n}\n"},9521:e=>{e.exports="                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct HalfSpaceShape {\n    int id;\n    Vector normal;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                                 \n   \nfloat sdf(HalfSpaceShape halfspace, RelVector v) {\n    Vector normal = applyGroupElement(v.invCellBoost, halfspace.normal);\n    float aux = dot(v.local.pos.coords, normal.dir);\n    return asin(aux);\n}\n\n   \n                                              \n   \nRelVector gradient(HalfSpaceShape halfspace, RelVector v){\n    Vector normal = applyGroupElement(v.invCellBoost, halfspace.normal);\n    Vector local = Vector(v.local.pos, normal.dir);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(HalfSpaceShape halfspace, RelVector v){\n    Point point = applyGroupElement(v.cellBoost, v.local.pos);\n    point = applyIsometry(halfspace.absoluteIsomInv, point);\n    vec3 aux = normalize(point.coords.xyw);\n    float sinPhi = length(aux.xy);\n    float cosPhi = aux.z;\n    float uCoord = atan(aux.y, aux.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n"},9937:e=>{e.exports="                                                                                                                        \n          \n                            \n                                                                                                                        \n\nstruct LocalBallShape {\n    int id;\n    Point center;\n    float radius;\n    Isometry absoluteIsomInv;\n};\n\n   \n                                                 \n   \nfloat sdf(LocalBallShape ball, RelVector v) {\n    return dist(v.local.pos, ball.center) - ball.radius;\n}\n\n   \n                                              \n   \nRelVector gradient(LocalBallShape ball, RelVector v){\n    Vector local = direction(v.local.pos, ball.center);\n    return RelVector(negate(local), v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalBallShape ball, RelVector v){\n    Point pos = v.local.pos;\n    Vector direction = direction(ball.center, pos);\n    direction = applyIsometry(ball.absoluteIsomInv, direction);\n    vec4 dir = normalize(direction.dir);\n    float sinPhi = length(dir.xy);\n    float cosPhi = dir.z;\n    float uCoord = atan(dir.y, dir.x);\n    float vCoord = atan(sinPhi, cosPhi);\n    return vec2(uCoord, vCoord);\n}\n\n"},9807:e=>{e.exports="                                                                                                                        \n          \n                                            \n                                                                                                                        \n\nstruct LocalCylinderShape {\n    int id;\n    Vector direction;\n    float radius;\n    vec4 uvTestX;\n    vec4 uvTestY;\n};\n\n   \n                           \n   \nfloat sdf(LocalCylinderShape cyl, RelVector v) {\n    float aux1 = dot(v.local.pos.coords, cyl.direction.pos.coords);\n    float aux2 = dot(v.local.pos.coords, cyl.direction.dir);\n    return abs(acos(sqrt(aux1 * aux1 + aux2 * aux2))) - cyl.radius;\n}\n\n\n   \n                                              \n   \nRelVector gradient(LocalCylinderShape cyl, RelVector v){\n    vec4 m = v.local.pos.coords;\n    Vector dir = applyGroupElement(v.invCellBoost, cyl.direction);\n    float aux1 = dot(m, dir.pos.coords);\n    float aux2 = dot(m, dir.dir);\n    float den = sqrt(aux1 * aux1 + aux2 * aux2);\n    vec4 coords = (aux1/den) * dir.pos.coords + (aux2/den) * dir.dir;\n    Point proj = Point(coords);\n    Vector local = direction(v.local.pos, proj);\n    local = negate(local);\n    return RelVector(local, v.cellBoost, v.invCellBoost);\n}\n\nvec2 uvMap(LocalCylinderShape cyl, RelVector v){\n    vec4 m = v.local.pos.coords;\n    Vector dir = applyGroupElement(v.invCellBoost, cyl.direction);\n    float aux1 = dot(m, dir.pos.coords);\n    float aux2 = dot(m, dir.dir);\n    vec4 proj = aux1 * dir.pos.coords + aux2 * dir.dir;\n    float uCoord = acos(dot(normalize(proj), dir.pos.coords));\n\n                                                                                                                       \n    vec4 aux = m - proj + length(proj) * dir.pos.coords;\n    float vCoord = atan(dot(aux, cyl.uvTestY), dot(aux, cyl.uvTestX));\n\n    return vec2(uCoord, vCoord);\n}\n"},5688:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                            \n  \n                                                                                                                        \n                                                                                                                        \n\n\n"}},n={};function r(e){var a=n[e];if(void 0!==a)return a.exports;var o=n[e]={exports:{}};return t[e](o,o.exports,r),o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})();var a={};(()=>{r.d(a,{T0:()=>Yo,FJ:()=>qo,GU:()=>Vt,XH:()=>we,ec:()=>Di,Yb:()=>ci,ZH:()=>Lt,K9:()=>A,FT:()=>yt,cK:()=>mt,_x:()=>ht,kj:()=>pt,V1:()=>Te,Vz:()=>on,Cd:()=>Bi,n:()=>Vi,y7:()=>ki,UQ:()=>gi,ck:()=>$,Iy:()=>Aa,Vf:()=>qs,Ab:()=>Ui,g6:()=>bi,TB:()=>mn,Al:()=>jo,ix:()=>dr,jZ:()=>ir,c$:()=>At,Qj:()=>Oe,mD:()=>Bo,yb:()=>Ct,iJ:()=>cn,ZA:()=>$e,Jz:()=>_e,Fr:()=>Ni,RM:()=>_i,fR:()=>Kr,kK:()=>Gr,ZX:()=>ar,_f:()=>pr,Ht:()=>vr,HZ:()=>No,TN:()=>so,JV:()=>t,Sc:()=>Lo,Nh:()=>Fo,RL:()=>Ve,_k:()=>Mt,uR:()=>Ao,gU:()=>Ko,jo:()=>Pi,Q:()=>hi,gq:()=>Li,Gj:()=>Si,L8:()=>Ys,F5:()=>wt,Uc:()=>rs,Fh:()=>Ho,O5:()=>ei,oB:()=>Xt,pJ:()=>_t,GW:()=>Xe,DZ:()=>ve,_K:()=>Ba,JF:()=>en,Lv:()=>Sr,E9:()=>o,ce:()=>Hs,Ly:()=>i,iv:()=>ns,mH:()=>Zo,xd:()=>ts,pX:()=>Me,Dz:()=>Ce,Th:()=>h,Uj:()=>Oo,bY:()=>yn,cV:()=>oo,lR:()=>wo,xs:()=>Ft,bn:()=>xt,oC:()=>Go,Z1:()=>fn,h8:()=>Et,Qf:()=>Ei,jE:()=>Ue,k1:()=>Zn,ew:()=>tr,$p:()=>zo,xG:()=>bt,l_:()=>Va,pk:()=>ca,yI:()=>_o,E6:()=>ke,zO:()=>Le,cB:()=>Ks,OW:()=>s,n3:()=>Wn,Se:()=>Xn,PQ:()=>An,$9:()=>Po,ak:()=>ge,uZ:()=>ye,Cy:()=>Oa,qM:()=>Sn,mV:()=>Zr,Gi:()=>zr,jV:()=>io,j9:()=>In,oc:()=>Rn,wS:()=>Na,IJ:()=>Rr,Ij:()=>Ds,c0:()=>ys,p2:()=>xe,w0:()=>En,VL:()=>Ma,UR:()=>da,dV:()=>Ot,G0:()=>Co,YL:()=>zn,re:()=>Uo});class t{constructor(){this.build(...arguments)}build(){throw new Error("This method need be overloaded.")}get isIsometry(){return!0}identity(){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}multiply(e){throw new Error("This method need be overloaded.")}premultiply(e){throw new Error("This method need be overloaded.")}invert(){return this.matrix.invert(),this}makeTranslation(e){throw new Error("This method need be overloaded.")}makeInvTranslation(e){throw new Error("This method need be overloaded.")}makeTranslationFromDir(e){throw new Error("This method need be overloaded.")}diffExpMap(e){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new t;return e.copy(this),e}}const n=(e=>{var t={};return r.d(t,e),t})({BufferGeometry:()=>e.BufferGeometry,Clock:()=>e.Clock,Color:()=>e.Color,EventDispatcher:()=>e.EventDispatcher,Float32BufferAttribute:()=>e.Float32BufferAttribute,HalfFloatType:()=>e.HalfFloatType,ImageLoader:()=>e.ImageLoader,LinearFilter:()=>e.LinearFilter,MathUtils:()=>e.MathUtils,Matrix3:()=>e.Matrix3,Matrix4:()=>e.Matrix4,Mesh:()=>e.Mesh,NearestFilter:()=>e.NearestFilter,NoBlending:()=>e.NoBlending,OrthographicCamera:()=>e.OrthographicCamera,PerspectiveCamera:()=>e.PerspectiveCamera,PlaneGeometry:()=>e.PlaneGeometry,Quaternion:()=>e.Quaternion,RGBAFormat:()=>e.RGBAFormat,RepeatWrapping:()=>e.RepeatWrapping,Scene:()=>e.Scene,ShaderMaterial:()=>e.ShaderMaterial,SphereGeometry:()=>e.SphereGeometry,Texture:()=>e.Texture,TextureLoader:()=>e.TextureLoader,Uniform:()=>e.Uniform,UniformsUtils:()=>e.UniformsUtils,Vector2:()=>e.Vector2,Vector3:()=>e.Vector3,Vector4:()=>e.Vector4,VideoTexture:()=>e.VideoTexture,WebGLRenderTarget:()=>e.WebGLRenderTarget,WebGLRenderer:()=>e.WebGLRenderer});t.prototype.build=function(){this.matrix=new n.Matrix4},t.prototype.identity=function(){this.matrix.identity()},t.prototype.reduceError=function(){return this},t.prototype.multiply=function(e){return this.matrix.multiply(e.matrix),this},t.prototype.premultiply=function(e){return this.matrix.premultiply(e.matrix),this},t.prototype.invert=function(){return this.matrix.invert(),this},t.prototype.makeTranslation=function(e){this.matrix.identity();const[t,r,a,o]=e.coords.toArray(),s=new n.Vector3(t,r,a),i=s.length();if(0===i)return this;const l=1-o;s.normalize();const c=(new n.Matrix4).set(0,0,0,s.x,0,0,0,s.y,0,0,0,s.z,-s.x,-s.y,-s.z,0),d=c.clone().multiply(c);return c.multiplyScalar(i),this.matrix.add(c),d.multiplyScalar(l),this.matrix.add(d),this},t.prototype.makeInvTranslation=function(e){return this.makeTranslation(e),this.invert(),this},t.prototype.makeTranslationFromDir=function(e){this.matrix.identity();const t=e.length();if(0===t)return this;const r=e.clone().normalize(),a=Math.sin(t),o=1-Math.cos(t),s=(new n.Matrix4).set(0,0,0,r.x,0,0,0,r.y,0,0,0,r.z,-r.x,-r.y,-r.z,0),i=s.clone().multiply(s);return s.multiplyScalar(a),this.matrix.add(s),i.multiplyScalar(o),this.matrix.add(i),this},t.prototype.makeTranslationWithDir=function(e,r){const a=(new t).makeInvTranslation(e),o=(new t).makeTranslation(e),s=r.clone().applyMatrix4(a.matrix),i=new n.Vector3(s.x,s.y,s.z).normalize(),l=new n.Vector3(0,0,1),c=(new n.Quaternion).setFromUnitVectors(l,i),d=(new n.Matrix4).makeRotationFromQuaternion(c);return this.matrix.copy(o.matrix).multiply(d),this},t.prototype.equals=function(e){return this.matrix.equals(e.matrix)},t.prototype.copy=function(e){return this.matrix.copy(e.matrix),this};class o{constructor(...e){this.build(...e)}build(){throw new Error("This method need be overloaded.")}get isPoint(){return!0}set(){throw new Error("This method need be overloaded.")}applyIsometry(e){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}clone(){const e=new o;return e.copy(this),e}}o.prototype.build=function(){this.coords=0===arguments.length?new n.Vector4(0,0,0,1):new n.Vector4(...arguments),this.coords.normalize()},o.prototype.reduceError=function(){return this.coords.normalize(),this},o.prototype.applyIsometry=function(e){return this.coords.applyMatrix4(e.matrix),this.reduceError(),this},o.prototype.equals=function(e){return this.coords.equals(e.coords)},o.prototype.copy=function(e){return this.coords.copy(e.coords),this};class s extends n.Vector3{get isVector(){return!0}applyMatrix4(e){const t=new n.Vector4(this.x,this.y,this.z,0);return t.applyMatrix4(e),this.set(t.x,t.y,t.z),this}applyFacing(e){return this.applyQuaternion(e.quaternion),this}}class i{constructor(){this.boost=new t,this.quaternion=new n.Quaternion}get isPosition(){return!0}get facing(){return(new n.Matrix4).makeRotationFromQuaternion(this.quaternion)}setBoost(e){return this.boost.copy(e),this}setQuaternion(e){return this.quaternion.copy(e),this}reduceErrorBoost(){return this.boost.reduceError(),this}reduceErrorQuaternion(){return this.quaternion.normalize(),this}reduceError(){return this.reduceErrorBoost(),this.reduceErrorQuaternion(),this}get point(){return(new o).applyIsometry(this.boost)}reset(){return this.boost.identity(),this.quaternion.identity(),this}applyIsometry(e){return this.boost.premultiply(e),this}applyQuaternion(e){return this.quaternion.multiply(e),this}multiply(e){return this.boost.multiply(e.boost),this.quaternion.premultiply(e.quaternion),this}premultiply(e){return this.boost.premultiply(e.boost),this.quaternion.multiply(e.quaternion),this}flowFromOrigin(e){throw new Error("This method need be overloaded.")}flow(e){const t=e.clone().applyFacing(this),n=(new i).flowFromOrigin(t);return this.multiply(n),this}fakeDiffExpMap(e){const t=(new s).setFromMatrixPosition(e),r=(new n.Quaternion).setFromRotationMatrix(e);return this.flow(t),this.quaternion.multiply(r),this}equals(e){return this.boost.equals(e.boost)&&this.quaternion.equals(e.quaternion)}copy(e){return this.boost.copy(e.boost),this.quaternion.copy(e.quaternion),this}clone(){const e=new i;return e.copy(this),e}}i.prototype.flowFromOrigin=function(e){return this.boost.makeTranslationFromDir(e),this.quaternion.identity(),this};var l=r(5350),c=r.n(l),d=r(7772),u=r.n(d);class h{static shader1=void 0;static shader2=void 0;constructor(e,t,r={},a={}){this.camera=e,this.scene=t,this.threeRenderer=a.isWebGLRenderer?a:new n.WebGLRenderer(a),this.globalUniforms=void 0!==r.globalUniforms?r.globalUniforms:{},void 0===this.globalUniforms.maxBounces&&(this.globalUniforms.maxBounces={type:"int",value:0}),this.globalUniforms.windowSize={type:"vec2",value:new n.Vector2(window.innerWidth,window.innerHeight)}}get set(){return this.camera.position.set}setPixelRatio(e){this.threeRenderer.setPixelRatio(e)}setSize(e,t,n=!0){this.threeRenderer.setSize(e,t,n)}setClearColor(e,t){this.threeRenderer.setClearColor(e,t)}setAnimationLoop(e){this.threeRenderer.setAnimationLoop(e)}get domElement(){return this.threeRenderer.domElement}build(){throw new Error("Renderer: this method is not implemented")}render(){throw new Error("Renderer: this method is not implemented")}}class p{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const m=new n.OrthographicCamera(-1,1,1,-1,0,1);class b extends n.BufferGeometry{constructor(){super(),this.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2))}}const v=new b;class f{constructor(e){this._mesh=new n.Mesh(v,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,m)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class g extends p{constructor(e,t,r=null,a=null,o=null){super(),this.scene=e,this.camera=t,this.overrideMaterial=r,this.clearColor=a,this.clearAlpha=o,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new n.Color}render(e,t,n){const r=e.autoClear;let a,o;e.autoClear=!1,null!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor)),null!==this.clearAlpha&&(a=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(a),null!==this.overrideMaterial&&(this.scene.overrideMaterial=o),e.autoClear=r}}class x extends p{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof n.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=n.UniformsUtils.clone(e.uniforms),this.material=new n.ShaderMaterial({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new f(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}const y={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class V extends p{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const r=e.getContext(),a=e.state;let o,s;a.buffers.color.setMask(!1),a.buffers.depth.setMask(!1),a.buffers.color.setLocked(!0),a.buffers.depth.setLocked(!0),this.inverse?(o=0,s=1):(o=1,s=0),a.buffers.stencil.setTest(!0),a.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),a.buffers.stencil.setFunc(r.ALWAYS,o,4294967295),a.buffers.stencil.setClear(s),a.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),a.buffers.color.setLocked(!1),a.buffers.depth.setLocked(!1),a.buffers.color.setMask(!0),a.buffers.depth.setMask(!0),a.buffers.stencil.setLocked(!1),a.buffers.stencil.setFunc(r.EQUAL,1,4294967295),a.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),a.buffers.stencil.setLocked(!0)}}class M extends p{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class w{constructor(e,t){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===t){const r=e.getSize(new n.Vector2);this._width=r.width,this._height=r.height,(t=new n.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:n.HalfFloatType})).texture.name="EffectComposer.rt1"}else this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new x(y),this.copyPass.material.blending=n.NoBlending,this.clock=new n.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,r=this.passes.length;t<r;t++){const r=this.passes[t];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==V&&(r instanceof V?n=!0:r instanceof M&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new n.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class _{constructor(e=1){this.useCase=e,this.code="",this.includedImports=[],this.includedClasses=[],this.includedConstants=[],this.includedUniforms=[],this.includedInstances=[],this.uniforms={}}get fragmentShader(){return this.code}addChunk(e){return this.code=this.code+"\r\n\r\n"+e,this}addImport(e){return this.includedImports.includes(e)||(this.includedImports.push(e),this.code=this.code+"\r\n\r\n"+e),this}addClass(e,t){return this.includedClasses.includes(e)||(this.includedClasses.push(e),this.code=this.code+"\r\n\r\n"+t),this}addConstant(e,t,n){return this.includedConstants.includes(e)||(this.includedConstants.push(e),this.code=this.code+"\r\n\r\n"+`const ${t} ${e} = ${n};`),this}addUniform(e,t,n){return this.includedUniforms.includes(e)||(this.includedUniforms.push(e),this.code=this.code+"\r\n\r\n"+`uniform ${t} ${e};`,this.uniforms[e]={type:t,value:n}),this}updateUniform(e,t){return this.uniforms[e].value=t,this}addInstance(e,t){return this.includedInstances.includes(e)||(this.includedInstances.push(e),this.code=this.code+"\r\n\r\n"+t),this}}var C=r(1767),T=r.n(C),S=r(190),R=r.n(S),I=r(4168),E=r.n(I),D=r(2977),P=r.n(D),U=r(2044),k=r.n(U),B=r(9461),N=r.n(B),L=r(7781),F=r.n(L),G=r(6159),z=r.n(G),j=r(5315),H=r.n(j);class A extends h{constructor(e,t,n={},r={}){super(e,t,n,r),this._fragmentBuilder=new _,this.postProcess=void 0!==n.postProcess?n.postProcess:[],this.composer=new w(this.threeRenderer)}get isBasicRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.composer.setSize(e,t)}buildFragmentShader(){this._fragmentBuilder.addChunk(T()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)})),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(R()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(E()),this._fragmentBuilder.addChunk(N()),this.set.shader(this._fragmentBuilder),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(k()(this)),this._fragmentBuilder.addChunk(F()(this)),this._fragmentBuilder.addChunk(P()),this._fragmentBuilder.addChunk(z()),this._fragmentBuilder.addChunk(H())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder);const e=new g(this.camera.threeScene,this.camera.threeCamera);e.clear=!1,this.composer.addPass(e);for(let e=0;e<this.postProcess.length;e++){const t=new x(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}render(){this.composer.render()}}class O extends p{constructor(e,t){super();const r=y;this.map=e,this.opacity=void 0!==t?t:1,this.uniforms=n.UniformsUtils.clone(r.uniforms),this.material=new n.ShaderMaterial({uniforms:this.uniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,depthTest:!1,depthWrite:!1,premultipliedAlpha:!0}),this.needsSwap=!1,this.fsQuad=new f(null)}render(e,t,n){const r=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.uniforms.opacity.value=this.opacity,this.uniforms.tDiffuse.value=this.map,this.material.transparent=this.opacity<1,e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(),this.fsQuad.render(e),e.autoClear=r}dispose(){this.material.dispose(),this.fsQuad.dispose()}}var q=r(7962),W=r.n(q);class Q{constructor(){}uniforms(){return{tDiffuse:{value:null}}}vertexShader(){return W()}fragmentShader(){throw new Error("Shape: this method should be implemented")}fullShader(){return{uniforms:this.uniforms(),vertexShader:this.vertexShader(),fragmentShader:this.fragmentShader()}}}var Y=r(2690),X=r.n(Y);class $ extends Q{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return X()}}var K=r(6172),Z=r.n(K),J=r(3499),ee=r.n(J),te=r(9638),ne=r.n(te),re=r(7920),ae=r.n(re),oe=r(3888),se=r.n(oe),ie=r(6272),le=r.n(ie),ce=r(8187),de=r.n(ce),ue=r(4122),he=r.n(ue);const pe=new n.ShaderMaterial({uniforms:{accTex:new n.Uniform(null),newTex:new n.Uniform(null),iFrame:new n.Uniform(0)},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D accTex;\n        uniform sampler2D newTex;\n        uniform float iFrame;\n        void main() {\n            float den = 1./ (1. + iFrame);\n            gl_FragColor = den * (iFrame *  texture2D(accTex, vUv) + texture2D(newTex, vUv));\n        }"}),me=new f(pe),be={minFilter:n.NearestFilter,magFilter:n.NearestFilter,format:n.RGBAFormat,type:n.HalfFloatType};class ve extends h{constructor(e,t,r={},a={}){super(e,t,r,a),this.globalUniforms.maxBounces.value=void 0!==r.maxBounces?r.maxBounces:50,this.postProcess=void 0!==r.postProcess?r.postProcess:[],0===this.postProcess.length&&this.postProcess.push(new $),this._fragmentBuilder=new _(3),this.sceneTarget=new n.WebGLRenderTarget(window.innerWidth,window.innerHeight,be),this.accReadTarget=new n.WebGLRenderTarget(window.innerWidth,window.innerHeight,be),this.accWriteTarget=new n.WebGLRenderTarget(window.innerWidth,window.innerHeight,be),this.iFrame=0,this.composer=new w(this.threeRenderer)}get isPathTracerRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.sceneTarget.setSize(e,t),this.accReadTarget.setSize(e,t),this.accWriteTarget.setSize(e,t),this.composer.setSize(e,t)}updateFrameSeed(){const e=Math.floor(1e4*Math.random());this._fragmentBuilder.updateUniform("frameSeed",e)}buildFragmentShader(){this._fragmentBuilder.addChunk(T()),Object.keys(this.globalUniforms).forEach((e=>{const t=this.globalUniforms[e].type,n=this.globalUniforms[e].value;this._fragmentBuilder.addUniform(e,t,n)}));const e=new n.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.addUniform("resolution","vec2",e),this._fragmentBuilder.addChunk(this.constructor.shader1),this._fragmentBuilder.addChunk(R()),this._fragmentBuilder.addChunk(this.constructor.shader2),this._fragmentBuilder.addChunk(E()),this._fragmentBuilder.addUniform("frameSeed","uint",Math.floor(1e4*Math.random())),this._fragmentBuilder.addChunk(ne()),this._fragmentBuilder.addChunk(se()),this.set.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(ae()),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(Z()(this)),this._fragmentBuilder.addChunk(he()(this)),this._fragmentBuilder.addChunk(le()(this)),this._fragmentBuilder.addChunk(ee()),this._fragmentBuilder.addChunk(de())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilder),this.composer.addPass(new O(this.accReadTarget.texture));for(let e=0;e<this.postProcess.length;e++){const t=new x(this.postProcess[e].fullShader());t.clear=!1,this.composer.addPass(t)}}checkShader(){console.log(this._fragmentBuilder.code)}renderAccTarget(){this.threeRenderer.setRenderTarget(null),this.composer.render()}render(){let e;this.updateFrameSeed();const t=new n.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.updateUniform("resolution",t),this.threeRenderer.setRenderTarget(this.sceneTarget),this.threeRenderer.render(this.threeScene,this.camera.threeCamera),this.threeRenderer.setRenderTarget(this.accWriteTarget),pe.uniforms.accTex.value=this.accReadTarget.texture,pe.uniforms.newTex.value=this.sceneTarget.texture,pe.uniforms.iFrame.value=this.iFrame,me.render(this.threeRenderer),e=this.accReadTarget,this.accReadTarget=this.accWriteTarget,this.accWriteTarget=e,this.renderAccTarget(),this.iFrame=this.iFrame+1}}class fe{static createButton(e){const t=document.createElement("button");function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",r(t),navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){let n=null;async function r(r){r.addEventListener("end",a),await e.xr.setSession(r),t.textContent="EXIT VR",n=r}function a(){n.removeEventListener("end",a),t.textContent="ENTER VR",n=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR",t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){if(null===n){const e={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};navigator.xr.requestSession("immersive-vr",e).then(r)}else n.end()}}():(n(),t.textContent="VR NOT SUPPORTED"),r&&fe.xrSessionIsGranted&&t.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{fe.xrSessionIsGranted=!0}))}}}function ge(e,t){return function(){return t.apply(e,arguments)}}function xe(e){return e.replace(/\W/g,"_")}function ye(e,t,n){return Math.max(t,Math.min(n,e))}fe.xrSessionIsGranted=!1,fe.registerSessionGrantedListener(),n.Vector3.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}]`},n.Vector4.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},n.Matrix3.prototype.toLog=function(){let e="\r\n";for(let t=0;t<3;t++){for(let n=0;n<3;n++)0!==n&&(e+=",\t"),e+=this.elements[t+3*n];e+="\r\n"}return e},n.Matrix3.prototype.power=function(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}},n.Matrix3.prototype.makeRotation=function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this},n.Matrix4.prototype.toLog=function(){let e="\r\n";for(let t=0;t<4;t++){for(let n=0;n<4;n++)0!==n&&(e+=",\t"),e+=this.elements[t+4*n];e+="\r\n"}return e},n.Matrix4.prototype.add=function(e){return this.set.apply(this,[].map.call(this.elements,(function(t,n){return t+e.elements[n]}))),this},n.Quaternion.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},n.Quaternion.prototype.multiplyScalar=function(e){return this.set(e*this.x,e*this.y,e*this.z,e*this.w),this},n.Quaternion.prototype.add=function(e){return this.set(this.x+e.x,this.y+e.y,this.z+e.z,this.w+e.w),this};const Ve=0,Me=1,we=2;class _e{constructor(e){this.group=e,this.uuid=n.MathUtils.generateUUID().replaceAll("-","_"),this.name=`groupElement_${this.uuid}`}identity(){throw new Error("GroupElement: This method need be overloaded.")}multiply(e){throw new Error("GroupElement: This method need be overloaded.")}premultiply(e){throw new Error("GroupElement: This method need be overloaded.")}invert(){throw new Error("GroupElement: This method need be overloaded.")}toIsometry(){throw new Error("GroupElement: This method need be overloaded.")}equals(e){throw new Error("GroupElement: This method need be overloaded.")}clone(){throw new Error("GroupElement: This method need be overloaded.")}copy(e){throw new Error("GroupElement: This method need be overloaded.")}}class Ce{constructor(e){this.local=new i,this.set=e,this.cellBoost=this.set.group.element(),this.invCellBoost=this.set.group.element()}reduceErrorBoost(){return this.local.reduceErrorBoost(),this}reduceErrorFacing(){return this.local.reduceErrorFacing(),this}reduceErrorLocal(){return this.local.reduceError(),this}reduceError(){return this.reduceErrorLocal(),this}get facing(){return this.local.facing}get localPoint(){return this.local.point}get point(){return this.local.point.applyIsometry(this.cellBoost.toIsometry())}get globalBoost(){return this.cellBoost.toIsometry().multiply(this.local.boost)}get globalPosition(){const e=new i;return e.boost.copy(this.globalBoost),e.quaternion.copy(this.local.quaternion),e}reset(){this.local.reset(),this.cellBoost.identity(),this.invCellBoost.identity()}applyQuaternion(e){return this.local.applyQuaternion(e),this}teleport(){let e,t;for(;;){t=this.localPoint,e=!0;for(const n of this.set.teleportations)if(e=e&&!n.jsTest(t),!e){this.local.applyIsometry(n.elt.toIsometry()),this.cellBoost.multiply(n.inv),this.invCellBoost.premultiply(n.elt);break}if(e)break}return this}flow(e){return this.local.flow(e),this.teleport(),this}fakeDiffExpMap(e){return this.local.fakeDiffExpMap(e),this}equals(e){let t=!0;return t=t&&this.local.equals(e.local),t=t&&this.cellBoost.equals(e.cellBoost),t}copy(e){return this.cellBoost.copy(e.cellBoost),this.invCellBoost.copy(e.invCellBoost),this.local.copy(e.local),this}clone(){const e=new Ce(this.set);return e.copy(this),e}}r(8415),r(4770);class Te{constructor(e){this.threeCamera=void 0,this.threeScene=new n.Scene,this.minDist=void 0!==e.minDist?e.minDist:0,this.maxDist=void 0!==e.maxDist?e.maxDist:50,this.safetyDist=void 0!==e.safetyDist?e.safetyDist:0,this.maxSteps=void 0!==e.maxSteps?e.maxSteps:100,this.threshold=void 0!==e.threshold?e.threshold:1e-4,this.position=new Ce(e.set),this.fakeCameras=[],this.setThreeCamera(e)}setThreeCamera(e){throw new Error("This method need be implemented.")}setThreeScene(){throw new Error("This method need be implemented.")}get matrix(){return this.threeCamera.matrixWorld}updateProjectionMatrix(){this.threeCamera.updateProjectionMatrix()}static glslClass(){throw new Error("Generic: this function should be implemented")}static glslMapping(){throw new Error("Generic: this function should be implemented")}shader(e,t=void 0){e.addClass("Camera",this.constructor.glslClass()),void 0===t?e.addUniform("camera","Camera",this):e.addUniform("camera","Camera",this.fakeCameras[t]),e.addChunk(this.constructor.glslMapping())}}var Se=r(5682),Re=r.n(Se),Ie=r(5970),Ee=r.n(Ie),De=r(9222),Pe=r.n(De);class Ue extends Te{constructor(e){super(e)}setThreeCamera(e){this.threeCamera=new n.PerspectiveCamera(void 0!==e.fov?e.fov:70,window.innerWidth/window.innerHeight,.01,2e3),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}set aspect(e){this.threeCamera.aspect=e}get fov(){return this.threeCamera.fov}set fov(e){this.threeCamera.fov=e}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const t=new n.SphereGeometry(1e3,60,40);t.scale(1,1,-1);const r=new n.ShaderMaterial({uniforms:e.uniforms,vertexShader:Re(),fragmentShader:e.fragmentShader}),a=new n.Mesh(t,r);this.threeScene.add(a)}static glslClass(){return Ee()}static glslMapping(){return Pe()}}class ke extends Ue{constructor(e){super(e),this.isStereoOn=!1,this.ipDist=void 0!==e.ipDist?e.ipDist:.03200000151991844;for(const e in[Ve,Me])this.fakeCameras[e]={fov:this.fov,minDist:this.minDist,maxDist:this.maxDist,maxSteps:this.maxSteps,safetyDist:this.safetyDist,threshold:this.threshold,position:this.position.clone(),matrix:this.matrix}}get isStereoOff(){return!this.isStereoOn}switchStereo(){this.isStereoOn=!this.isStereoOn}setThreeScene(e){const t=new n.SphereGeometry(50,60,40);t.scale(1,1,-1);const r=new n.ShaderMaterial({uniforms:e[Ve].uniforms,vertexShader:Re(),fragmentShader:e[Ve].fragmentShader}),a=new n.ShaderMaterial({uniforms:e[Me].uniforms,vertexShader:Re(),fragmentShader:e[Ve].fragmentShader}),o=new n.Mesh(t,r),s=new n.Mesh(t,a);o.layers.set(1),s.layers.set(2),this.threeScene.add(o,s)}updateFakeCamerasPosition(){if(this.fakeCameras[Ve].position.copy(this.position),this.fakeCameras[Me].position.copy(this.position),this.isStereoOn){const e=new s(1,0,0).multiplyScalar(2*this.ipDist).applyMatrix4(this.matrix).negate();this.fakeCameras[Ve].position.flow(e)}}get chaseThreeCamera(){if(void 0===this._chaseThreeCamera){const e=new s;this._chaseThreeCamera=function(){const t=(new s).setFromMatrixPosition(this.matrix),n=(new s).subVectors(t,e);this.position.flow(n),this.updateFakeCamerasPosition(),e.copy(t)}}return this._chaseThreeCamera}}var Be=r(8351),Ne=r.n(Be);class Le extends h{constructor(e,t,n={},r={}){super(e,t,n,r),this.threeRenderer.xr.enabled=!0,this.threeRenderer.xr.setReferenceSpaceType("local"),this.camera.threeCamera.layers.enable(1);const a=fe.createButton(this.threeRenderer),o=ge(this.camera,this.camera.switchStereo);a.addEventListener("click",o,!1),document.body.appendChild(a),this._fragmentBuilders=[new _,new _],this.postProcess=void 0!==n.postProcess&&n.postProcess,this.exposure=void 0!==n.exposure?n.exposure:1}get isVRRenderer(){return!0}get xr(){return this.threeRenderer.xr}buildFragmentShader(){for(const e of[Ve,Me])this._fragmentBuilders[e].addChunk(T()),Object.keys(this.globalUniforms).forEach((t=>{const n=this.globalUniforms[t].type,r=this.globalUniforms[t].value;this._fragmentBuilders[e].addUniform(t,n,r)})),this._fragmentBuilders[e].addChunk(this.constructor.shader1),this._fragmentBuilders[e].addChunk(R()),this._fragmentBuilders[e].addChunk(this.constructor.shader2),this._fragmentBuilders[e].addChunk(E()),this._fragmentBuilders[e].addChunk(N()),this.set.shader(this._fragmentBuilders[e]),this.camera.shader(this._fragmentBuilders[e],e),this.scene.shader(this._fragmentBuilders[e]),this._fragmentBuilders[e].addChunk(k()(this)),this._fragmentBuilders[e].addChunk(F()(this)),this._fragmentBuilders[e].addChunk(P()),this.postProcess?(this._fragmentBuilders[e].addUniform("exposure","float",this.exposure),this._fragmentBuilders[e].addChunk(Ne())):this._fragmentBuilders[e].addChunk(z()),this._fragmentBuilders[e].addChunk(H())}build(){this.buildFragmentShader(),this.camera.setThreeScene(this._fragmentBuilders)}checkShader(e=Ve){console.log(this._fragmentBuilders[e].code)}render(){this.camera.chaseThreeCamera(),this.threeRenderer.render(this.camera.threeScene,this.camera.threeCamera)}}var Fe=r(6224),Ge=r.n(Fe),ze=r(8710),je=r.n(ze),He=r(4750),Ae=r.n(He);class Oe extends Te{constructor(e){super(e),this.fov=void 0!==e.fov?e.fov:50}setThreeCamera(){this.threeCamera=new n.OrthographicCamera(-1,1,1,-1,0,1),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1)}get fovRadians(){return Math.PI*this.fov/180}setThreeScene(e){const t=new n.PlaneGeometry(2,2),r=new n.ShaderMaterial({uniforms:e.uniforms,vertexShader:Ge(),fragmentShader:e.fragmentShader}),a=new n.Mesh(t,r);this.threeScene.add(a)}static glslClass(){return je()}static glslMapping(){return Ae()}}var qe=r(6354),We=r.n(qe),Qe=r(6684),Ye=r.n(Qe);class Xe extends Ue{constructor(e){super(e),this.focalLength=void 0!==e.focalLength?e.focalLength:1,this.aperture=void 0!==e.aperture?e.aperture:0}static glslClass(){return We()}static glslMapping(){return Ye()}}class $e{constructor(){}element(){throw new Error("Group: this method should be implemented")}shader(e){throw new Error("Group: this method should be implemented")}}class Ke extends _e{constructor(e){super(e),this.fake=!0}identity(){return this}multiply(e){return this}premultiply(e){return this}invert(){return this}toIsometry(){return new t}equals(e){return!0}clone(){return new Ke}copy(e){return this}}var Ze=r(9188),Je=r.n(Ze);class et extends $e{constructor(){super()}element(){return new Ke(this)}shader(e){e.addChunk(Je())}}var tt=r(3148),nt=r.n(tt);const rt=/bool\s*(\w+)\(Point.*\)/m,at=/float\s*(\w+)\(ExtVector.*\)/m;class ot{constructor(e,t,r,a,o=void 0,s=void 0){let i;if(this.set=e,this.uuid=n.MathUtils.generateUUID().replaceAll("-","_"),this.jsTest=t,this.glslTest=r,this.glslTestName=void 0,i=r.match(rt),!i)throw new Error("Teleportation: unable to find the name of the GLSL test");if(this.glslTestName=i[1],this.elt=a,this.inv=void 0!==o?o:a.clone().invert(),this.glslCreepCustom=void 0,this.glslCreep=void 0,this.glslCreepName=void 0,void 0!==s){if(this.glslCreepCustom=!0,this.glslCreep=s,i=s.match(at),!i)throw new Error("Teleportation: unable to find the name of the GLSL creep");this.glslCreepName=i[1]}else this.glslCreepCustom=!1,this.glslCreepName=`creep${this.uuid}`,this.glslCreep=nt()(this)}get name(){return void 0===this._name&&(this._name=`teleportation_${this.uuid}`),this._name}get usesCreepingCustom(){return this.set.usesCreeping&&this.glslCreepCustom}get usesCreepingBinary(){return this.set.creepingType===mt&&!this.glslCreepCustom}shader(e){e.addChunk(this.glslTest),this.set.usesCreeping&&e.addChunk(this.glslCreep),e.addUniform(this.elt.name,"GroupElement",this.elt),e.addUniform(this.elt.name,"GroupElement",this.inv)}}var st=r(2311),it=r.n(st),lt=r(7970),ct=r.n(lt),dt=r(5103),ut=r.n(dt);const ht=0,pt=1,mt=2;class bt{constructor(e=[],t=!1,n=ht){this.teleportations=[],this.neighbors=e,this.usesNearestNeighbors=t,this.creepingType=n}get usesCreeping(){return this.creepingType===pt||this.creepingType===mt}add(e,t,n,r=void 0,a=void 0){return this.teleportations.push(new ot(this,e,t,n,r,a)),this}get group(){return 0!==this.teleportations.length?this.teleportations[0].elt.group:new et}shader(e){this.group.shader(e),e.addChunk(it()),e.addChunk(ct());for(const t of this.teleportations)t.shader(e);for(const t of this.neighbors)e.addUniform(t.elt.name,"GroupElement",t.elt),e.addUniform(t.inv.name,"GroupElement",t.inv);e.addChunk(ut()(this))}}class vt{constructor(){this.uuid=n.MathUtils.generateUUID().replaceAll("-","_"),this.id=void 0,this.imports=[]}get className(){return this.constructor.name}get name(){return void 0===this._name&&(this._name=`${xe(this.className)}_${this.uuid}`),this._name}get uniformType(){return""}setId(e){this.id=e.nextId,e.nextId=e.nextId+1}onAdd(e){}addImport(e){for(const e of arguments)this.imports.push(e)}static glslClass(){throw new Error("Generic: this function should be implemented")}glslInstance(){throw new Error("Generic: this function should be implemented")}shader(e){for(const t of this.imports)e.addImport(t);e.addClass(this.constructor.name,this.constructor.glslClass()),""!==this.uniformType&&e.addUniform(this.name,this.uniformType,this),e.addInstance(this.name,this.glslInstance())}}var ft=r(8266),gt=r.n(ft);class xt extends vt{constructor(e=void 0){super(),this.isom=void 0!==e?e:new t,this.isomInv=this.isom.clone().invert(),this.parent=void 0,this._absoluteIsom=void 0,this._absoluteIsomInv=void 0}updateAbsoluteIsom(){void 0===this._absoluteIsom&&(this._absoluteIsom=new t,this._absoluteIsomInv=new t),this.isomInv=this.isom.clone().invert(),this._absoluteIsom.copy(this.isom),this._absoluteIsomInv.copy(this.isomInv),void 0!==this.parent&&(this._absoluteIsom.premultiply(this.parent.absoluteIsom),this._absoluteIsomInv.multiply(this.parent.absoluteIsomInv))}updateData(){this.updateAbsoluteIsom()}get absoluteIsom(){return void 0===this._absoluteIsom&&this.updateAbsoluteIsom(),this._absoluteIsom}get absoluteIsomInv(){return void 0===this._absoluteIsomInv&&this.updateAbsoluteIsom(),this._absoluteIsomInv}get isShape(){return!0}get isBasicShape(){throw new Error("Shape: this method should be implemented")}get isAdvancedShape(){return!this.isBasicShape}get isGlobal(){throw new Error("Shape: this method should be implemented")}get isLocal(){return!this.isGlobal}get hasUVMap(){return!1}glslSDF(){throw new Error("Shape: this method should be implemented")}glslGradient(){return gt()(this)}glslUVMap(){throw new Error("Shape: this method should be implemented")}glslInstance(){let e=this.glslSDF()+"\r\n"+this.glslGradient();return this.hasUVMap&&(e=e+"\r\n"+this.glslUVMap()),e}}class yt extends xt{constructor(e=void 0){super(e)}get isBasicShape(){return!0}}class Vt extends xt{constructor(e=void 0){super(e)}get isBasicShape(){return!1}}class Mt extends vt{constructor(e){super(),this.maxDirs=e}get isLight(){return!0}get isGlobal(){throw new Error("Generic: this method should be implemented")}get isLocal(){return!this.isGlobal}glslDirections(){throw new Error("Light: this method should be implemented")}glslInstance(){return this.glslDirections()}}class wt extends vt{constructor(){super(),this.lights=void 0,this.reflectivity=void 0}get isMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}get isTransparent(){return!1}onAdd(e){this.usesLight&&(this.hasOwnProperty("lights")&&void 0!==this.lights||(this.lights=e.lights))}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class _t extends vt{constructor(){super()}get isPTMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}onAdd(e){}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}class Ct{constructor(){}shader(e){throw new Error("Fog: this method need be implemented")}}var Tt=r(2664),St=r.n(Tt),Rt=r(8778),It=r.n(Rt);class Et extends wt{constructor(e){super(),this.color=e}get uniformType(){return"SingleColorMaterial"}get usesNormal(){return!1}static glslClass(){return St()}glslRender(){return It()(this)}}var Dt=r(2143),Pt=r.n(Dt),Ut=r(9606),kt=r.n(Ut),Bt=r(5363),Nt=r.n(Bt);class Lt extends _t{constructor(e){super(),this.emission=void 0!==e.emission?e.emission:new n.Color(0,0,0),this.volumeEmission=void 0!==e.volumeEmission?e.volumeEmission:new n.Color(0,0,0),this.opticalDepth=void 0!==e.opticalDepth?e.opticalDepth:1e3,this.diffuse=void 0!==e.diffuse?e.diffuse:new n.Color(1,1,1),this.specular=void 0!==e.specular?e.specular:new n.Color(1,1,1),this.absorb=void 0!==e.absorb?e.absorb:new n.Color(.1,.1,.1),this.ior=void 0!==e.ior?e.ior:1,this.roughness=void 0!==e.roughness?e.roughness:.2,this.reflectionChance=void 0!==e.reflectionChance?e.reflectionChance:.1,this.refractionChance=void 0!==e.refractionChance?e.refractionChance:0,this.diffuseChance=void 0!==e.diffuseChance?e.diffuseChance:.9;const t=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/t,this.refractionChance=this.refractionChance/t,this.diffuseChance=this.diffuseChance/t,this.addImport(Nt())}get uniformType(){return"BasicPTMaterial"}static glslClass(){return Pt()}glslRender(){return kt()(this)}}class Ft{constructor(e={}){this.lights=[],this.solids=[],this.nextId=0,this.fog=e.fog,this.background=void 0!==e.background?e.background:new Et(new n.Color(0,0,0)),this.ptBackground=void 0!==e.ptBackground?e.ptBackground:new Lt({diffuse:new n.Color(0,0,0),specular:new n.Color(0,0,0),absorb:new n.Color(.25,.25,.25)})}_add(e){return e.setId(this),e.onAdd(this),e.isLight&&this.lights.push(e),e.isSolid&&this.solids.push(e),this}add(e){for(const e of arguments)this._add(e);return this}shader(e){3===e.useCase?this.ptBackground.shader(e):this.background.shader(e);for(const t of this.lights)3!==e.useCase&&t.shader(e);for(const t of this.solids)t.shader(e);void 0!==this.fog&&this.fog.shader(e)}}var Gt=r(7885),zt=r.n(Gt),jt=r(5348),Ht=r.n(jt);class At extends Ct{constructor(e,t){super(),this.color=e,this.scattering=t}shader(e){e.addClass("ExpFog",zt()),e.addUniform("fog","ExpFog",this),e.addChunk(Ht())}}const Ot=new bt;var qt=r(3496),Wt=r.n(qt),Qt=r(6077),Yt=r.n(Qt);class Xt extends wt{constructor(){super()}get uniformType(){return""}static glslClass(){return Wt()}glslRender(){return Yt()(this)}}var $t=r(6045),Kt=r.n($t),Zt=r(8149),Jt=r.n(Zt);class en extends wt{constructor(e={}){super(),this.color=void 0!==e.color?e.color:new n.Color(1,1,1),this.ambient=void 0!==e.ambient?e.ambient:.5,this.diffuse=void 0!==e.diffuse?e.diffuse:.4,this.specular=void 0!==e.specular?e.specular:.1;const t=this.ambient+this.diffuse+this.specular;this.ambient=this.ambient/t,this.diffuse=this.diffuse/t,this.specular=this.specular/t,this.shininess=void 0!==e.shininess?e.shininess:10,this._isReflecting=void 0!==e.isReflecting&&e.isReflecting,this.reflectivity=void 0!==e.reflectivity?e.reflectivity:new n.Color(0,0,0),this.lights=e.lights}get uniformType(){return"PhongMaterial"}get usesLight(){return!0}get isReflecting(){return this._isReflecting}static glslClass(){return Kt()}glslRender(){return Jt()(this)}shader(e){for(const t of this.lights)t.shader(e);super.shader(e)}}var tn=r(2197),nn=r.n(tn),rn=r(1215),an=r.n(rn);class on extends wt{constructor(e,t,n,r){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"CheckerboardMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return nn()}glslRender(){return an()(this)}}var sn=r(3801),ln=r.n(sn);class cn extends wt{constructor(e,t,n,r,a){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"GraphPaperMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return ln()}glslRender(){return an()(this)}}var dn=r(7793),un=r.n(dn),hn=r(9909),pn=r.n(hn);class mn extends wt{constructor(){super()}get uniformType(){return""}get usesNormal(){return!1}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}static glslClass(){return un()}glslRender(){return pn()(this)}shader(e){super.shader(e)}}var bn=r(9095),vn=r.n(bn);class fn extends wt{constructor(e,t={}){super(),this.sampler=(new n.TextureLoader).load(e),this.sampler.wrapS=void 0!==t.wrapS?t.wrapS:n.RepeatWrapping,this.sampler.wrapT=void 0!==t.wrapT?t.wrapT:n.RepeatWrapping,this.sampler.magFilter=n.LinearFilter,this.sampler.minFilter=n.LinearFilter,this.start=void 0!==t.start?t.start.clone():new n.Vector2(0,0),this.scale=void 0!==t.scale?t.scale.clone():new n.Vector2(1,1),this._isTransparent=void 0!==t.isTransparent&&t.isTransparent}get uniformType(){return"SimpleTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return vn()}glslRender(){return an()(this)}}var gn=r(1220),xn=r.n(gn);class yn extends wt{constructor(e,t=void 0,r={}){super(),this.quaternion=void 0!==t?t:new n.Quaternion,this.sampler=(new n.TextureLoader).load(e),this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:n.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:n.RepeatWrapping,this.sampler.magFilter=n.LinearFilter,this.sampler.minFilter=n.LinearFilter,this.start=void 0!==r.start?r.start.clone():new n.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new n.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent}get rotation(){return(new n.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get uniformType(){return"RotatedSphericalTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return xn()}glslRender(){return an()(this)}}const Vn=r.p+"img/426f7657671a2811d4aa.png",Mn=r.p+"img/953837709706027f7dc2.jpg",wn=r.p+"img/eba62d0cff4836a949b8.png",_n=r.p+"img/26419cb1ce4138a11aa9.jpg",Cn=r.p+"img/33960f5af615e67309e5.jpg",Tn=r.p+"img/4b569137334e61081651.jpg";function Sn(e){let t;switch(e){case 0:default:t=Vn;break;case 1:t=Mn}return new fn(t,{start:new n.Vector2(-Math.PI,0),scale:new n.Vector2(1/(2*Math.PI),-1/Math.PI)})}function Rn(e){let t;switch(e){case 0:default:t=wn;break;case 1:t=_n}return new fn(t,{start:new n.Vector2(-Math.PI,0),scale:new n.Vector2(1/(2*Math.PI),-1/Math.PI)})}function In(){return new fn(Cn,{start:new n.Vector2(-Math.PI,0),scale:new n.Vector2(1/(2*Math.PI),-1/Math.PI)})}function En(e){return new fn(Tn,{start:new n.Vector2(-Math.PI,0),scale:new n.Vector2(1/(2*Math.PI),-1/Math.PI)})}const Dn=r.p+"img/eb3dc827520201070f7e.jpg",Pn=r.p+"img/ce3e4a6e1affece0e902.jpg",Un=r.p+"img/370531b8ba6e5bd6a61e.jpg",kn=r.p+"img/29989970ee70af555fd4.jpg",Bn=r.p+"img/1a661a5afc65c969818f.jpg",Nn=r.p+"img/bb733e02d9f86b8b7433.jpg",Ln=r.p+"img/f5196bbc22091948755e.jpg",Fn=r.p+"img/9e3233c13cddac942dc4.jpg",Gn=r.p+"img/2528cfc76a03ca71fb7f.jpg";function zn(e,t,r=void 0){let a;switch(e){case"eye":switch(t){case 0:a=Dn;break;case 1:a=Pn;break;case 2:a=Un;break;case 3:a=kn;break;case 4:a=Bn;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;case"hand":switch(t){case 0:a=Nn;break;case 1:a=Ln;break;case 2:a=Fn;break;case 3:a=Gn;break;default:throw new Error("WoodBallMaterial: this texture ID does not exists.")}break;default:throw new Error("WoodBallMaterial: this type of texture is not implemented.")}return new yn(a,r,{start:new n.Vector2(-Math.PI,0),scale:new n.Vector2(1/(2*Math.PI),-1/Math.PI)})}var jn=r(533),Hn=r.n(jn);class An extends wt{constructor(e,t={}){super(),this.sampler=new n.VideoTexture(e),this.sampler.wrapS=void 0!==t.wrapS?t.wrapS:n.RepeatWrapping,this.sampler.wrapT=void 0!==t.wrapT?t.wrapT:n.RepeatWrapping,this.sampler.magFilter=n.LinearFilter,this.sampler.minFilter=n.LinearFilter,this.start=void 0!==t.start?t.start.clone():new n.Vector2(0,0),this.scale=void 0!==t.scale?t.scale.clone():new n.Vector2(1,1),this.transparent=void 0!==t.transparent&&t.transparent}get uniformType(){return"VideoTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return Hn()}glslRender(){return an()(this)}}var On=r(2229),qn=r.n(On);class Wn extends wt{constructor(e,t={}){super(),this.sampler=new n.VideoTexture(e),this.sampler.wrapS=void 0!==t.wrapS?t.wrapS:n.RepeatWrapping,this.sampler.wrapT=void 0!==t.wrapT?t.wrapT:n.RepeatWrapping,this.sampler.magFilter=n.LinearFilter,this.sampler.minFilter=n.LinearFilter,this.start=void 0!==t.start?t.start.clone():new n.Vector2(0,0),this.scale=void 0!==t.scale?t.scale.clone():new n.Vector2(1,1),this.transparent=void 0===t.transparent||t.transparent}get uniformType(){return"VideoAlphaTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this.transparent}static glslClass(){return qn()}glslRender(){return an()(this)}}var Qn=r(4680),Yn=r.n(Qn);class Xn extends wt{static REFRESH_READY=0;static REFRESH_IN_PROGRESS=1;static REFRESH_COMPLETE=2;constructor(e,t,r={}){super(),this.files=e,this.frameNumber=e.length,this.sampler=new n.Texture,this.sampler.wrapS=void 0!==r.wrapS?r.wrapS:n.RepeatWrapping,this.sampler.wrapT=void 0!==r.wrapT?r.wrapT:n.RepeatWrapping,this.sampler.magFilter=n.LinearFilter,this.sampler.minFilter=n.LinearFilter,this.start=void 0!==r.start?r.start.clone():new n.Vector2(0,0),this.scale=void 0!==r.scale?r.scale.clone():new n.Vector2(1,1),this._isTransparent=void 0!==r.isTransparent&&r.isTransparent,this.loop=void 0!==r.loop&&r.loop,this.callback=void 0!==r.callback?r.callback:function(){},this.fps=void 0!==r.fps&&r.fps,this.imageStatus=Xn.REFRESH_READY,this.imageLoader=new n.ImageLoader,this.imageLoader.setPath(t),this.currentFrame=0}nextFrameIndex(e){return this.loop?(e+1)%this.frameNumber:Math.min(e+1,this.frameNumber-1)}nextFrame(){if(this.imageStatus===Xn.REFRESH_READY){this.imageStatus=Xn.REFRESH_IN_PROGRESS;const e=this.files[this.currentFrame];this.currentFrame=this.nextFrameIndex(this.currentFrame);const t=this;this.imageLoader.load(e,(function(e){t.sampler.image=e,t.sampler.needsUpdate=!0,t.imageStatus=Xn.REFRESH_COMPLETE}),void 0,(function(){console.log(`Cannot load the file ${e}`)}))}}get uniformType(){return"VideoFrameTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}get isTransparent(){return this._isTransparent}static glslClass(){return Yn()}glslRender(){return an()(this)}}var $n=r(3081),Kn=r.n($n);class Zn extends wt{constructor(e,t,r,a=void 0){super(),this.dir1=e,this.dir2=t;const o=void 0!==a?a:[.5,1,1,.5];let s=0;const i=[];for(let e=0;e<4;e++)void 0!==o[e]&&(s+=o[e]),i[e]=s;for(let e=0;e<4;e++)i[e]=i[e]/s;this.lengths=new n.Vector4(...i);let l=new n.Color(1,1,1);this.color0=void 0!==r[0]?r[0]:l.clone(),l=this.color0,this.color1=void 0!==r[1]?r[1]:l.clone(),l=this.color1,this.color2=void 0!==r[2]?r[2]:l.clone(),l=this.color2,this.color3=void 0!==r[3]?r[3]:l.clone()}get uniformType(){return"SquaresMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return Kn()}glslRender(){return an()(this)}}var Jn=r(9835),er=r.n(Jn);class tr extends wt{constructor(e,t,r=void 0){super(),this.dir=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new n.Vector4(...s);let i=new n.Color(1,1,1);this.color0=void 0!==t[0]?t[0]:i.clone(),i=this.color0,this.color1=void 0!==t[1]?t[1]:i.clone(),i=this.color1,this.color2=void 0!==t[2]?t[2]:i.clone(),i=this.color2,this.color3=void 0!==t[3]?t[3]:i.clone()}get uniformType(){return"StripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return er()}glslRender(){return an()(this)}}var nr=r(7685),rr=r.n(nr);class ar extends wt{constructor(e,t,r=void 0){super(),this.totalWidth=e;const a=void 0!==r?r:[.5,1,1,.5];let o=0;const s=[];for(let e=0;e<4;e++)void 0!==a[e]&&(o+=a[e]),s[e]=o;for(let e=0;e<4;e++)s[e]=s[e]/o;this.lengths=new n.Vector4(...s);let i=new n.Color(1,1,1);this.color0=void 0!==t[0]?t[0]:i.clone(),i=this.color0,this.color1=void 0!==t[1]?t[1]:i.clone(),i=this.color1,this.color2=void 0!==t[2]?t[2]:i.clone(),i=this.color2,this.color3=void 0!==t[3]?t[3]:i.clone()}get uniformType(){return"HypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return rr()}glslRender(){return an()(this)}}var or=r(1917),sr=r.n(or);class ir extends wt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"EquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return sr()}glslRender(){return an()(this)}}var lr=r(4743),cr=r.n(lr);class dr extends wt{constructor(e,t,n,r){super(),this.distance=e,this.width=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"EquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return cr()}glslRender(){return an()(this)}}var ur=r(4566),hr=r.n(ur);class pr extends wt{constructor(e,t,n,r){super(),this.distance=e,this.halfWidth=t,this.stripColor=n,this.bgColor=r}get uniformType(){return"ImprovedEquidistantHypStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return hr()}glslRender(){return an()(this)}}var mr=r(1650),br=r.n(mr);class vr extends wt{constructor(e,t,r,a,o,s=void 0){super(),this.distance=e,this.halfWidth=t,this.fadingAmplitude=r,this.stripColor=a,this.bgColor=o,this.quaternion=void 0!==s?s:new n.Quaternion}get rotation(){return(new n.Matrix4).makeRotationFromQuaternion(this.quaternion).invert()}get cosHalfWidthSq(){const e=Math.cos(this.halfWidth);return e*e}get uniformType(){return"ImprovedEquidistantSphStripsMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return br()}glslRender(){return an()(this)}}var fr=r(5836),gr=r.n(fr),xr=r(3838),yr=r.n(xr),Vr=r(472),Mr=r.n(Vr),wr=r(8204),_r=r.n(wr),Cr=r(7660),Tr=r.n(Cr);class Sr extends wt{constructor(e,t={}){super(),this.material=e,this.ambient=void 0!==t.ambient?t.ambient:.5,this.diffuse=void 0!==t.diffuse?t.diffuse:.5,this.specular=void 0!==t.specular?t.specular:.5,this.shininess=void 0!==t.shininess?t.shininess:10,this._isReflecting=void 0!==t.isReflecting&&t.isReflecting,this.reflectivity=void 0!==t.reflectivity?t.reflectivity:new n.Vector3(0,0,0),this.lights=t.lights}get uniformType(){return"PhongWrapMaterial"}static glslClass(){return gr()}get usesNormal(){return!0}get usesUVMap(){return this.material.usesUVMap}get usesLight(){return!0}get isReflecting(){return this._isReflecting}glslRender(){return this.material.usesNormal?this.material.usesUVMap?Tr()(this):Mr()(this):this.material.usesUVMap?_r()(this):yr()(this)}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e);for(const t of this.lights)t.shader(e);super.shader(e)}}function Rr(e,t={}){return new Sr(e,t)}var Ir=r(3048),Er=r.n(Ir),Dr=r(8474),Pr=r.n(Dr),Ur=r(5506),kr=r.n(Ur),Br=r(3045),Nr=r.n(Br),Lr=r(7397),Fr=r.n(Lr);class Gr extends wt{constructor(e,t){super(),this.defaultMat=e,this.highlightMat=t,this.isHighlightOn=!1}get uniformType(){return"HighlightWrapMaterial"}static glslClass(){return Er()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?Fr()(this):kr()(this):this.usesUVMap?Nr()(this):Pr()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function zr(e,t){return new Gr(e,t)}var jr=r(2278),Hr=r.n(jr),Ar=r(8906),Or=r.n(Ar),qr=r(1998),Wr=r.n(qr),Qr=r(4261),Yr=r.n(Qr),Xr=r(699),$r=r.n(Xr);class Kr extends wt{constructor(e,t,n){super(),this.defaultMat=e,this.highlightMat=t,this.cellBoost=n}get uniformType(){return"HighlightLocalWrapMaterial"}static glslClass(){return Hr()}get usesNormal(){return!0}get usesUVMap(){return this.defaultMat.usesUVMap||this.highlightMat.usesUVMap}get usesLight(){return this.defaultMat.usesLight||this.highlightMat.usesLight}get isReflecting(){return this.defaultMat.isReflecting||this.highlightMat.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?$r()(this):Wr()(this):this.usesUVMap?Yr()(this):Or()(this)}setId(e){this.defaultMat.setId(e),this.highlightMat.setId(e),super.setId(e)}onAdd(e){this.defaultMat.onAdd(e),this.highlightMat.onAdd(e),super.onAdd(e)}shader(e){this.defaultMat.shader(e),this.highlightMat.shader(e),super.shader(e)}}function Zr(e,t,n){return new Kr(e,t,n)}var Jr=r(5698),ea=r.n(Jr),ta=r(8402),na=r.n(ta),ra=r(6158),aa=r.n(ra),oa=r(2332),sa=r.n(oa),ia=r(4146),la=r.n(ia);class ca extends wt{constructor(e,t,r=void 0){super(),this.mat0=e,this.mat1=t,this.duration=void 0!==r?r:5,this._clock=new n.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=ye(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionWrapMaterial"}static glslClass(){return ea()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?la()(this):aa()(this):this.usesUVMap?sa()(this):na()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function da(e,t,n){return new ca(e,t,n)}var ua=r(1888),ha=r.n(ua),pa=r(5377),ma=r.n(pa),ba=r(9441),va=r.n(ba),fa=r(6766),ga=r.n(fa),xa=r(9245),ya=r.n(xa);class Va extends wt{constructor(e,t,r,a=void 0){super(),this.mat0=e,this.mat1=t,this.duration=void 0!==a?a:5,this.cellBoost=r,this._clock=new n.Clock,this._ratio=0,this._ratioOrigin=0,this._direction=-1}toggle(){this._direction=-this._direction,this._ratioOrigin=this._ratio,this._clock.start()}get ratio(){return this._ratio=ye(this._ratioOrigin+this._direction*(this._clock.getElapsedTime()/this.duration),0,1),this._ratio}get uniformType(){return"TransitionLocalWrapMaterial"}static glslClass(){return ha()}get usesNormal(){return!0}get usesUVMap(){return this.mat0.usesUVMap||this.mat1.usesUVMap}get usesLight(){return this.mat0.usesLight||this.mat1.usesLight}get isReflecting(){return this.mat0.isReflecting||this.mat1.isReflecting}glslRender(){return this.usesNormal?this.usesUVMap?ya()(this):va()(this):this.usesUVMap?ga()(this):ma()(this)}setId(e){this.mat0.setId(e),this.mat1.setId(e),super.setId(e)}onAdd(e){this.mat0.onAdd(e),this.mat1.onAdd(e),super.onAdd(e)}shader(e){this.mat0.shader(e),this.mat1.shader(e),super.shader(e)}}function Ma(e,t,n,r){return new Va(e,t,n,r)}var wa=r(7198),_a=r.n(wa),Ca=r(1202),Ta=r.n(Ca),Sa=r(2330),Ra=r.n(Sa),Ia=r(588),Ea=r.n(Ia),Da=r(9040),Pa=r.n(Da),Ua=r(1365),ka=r.n(Ua);class Ba extends _t{constructor(e,t){super(),this.material=e,this.emission=void 0!==t.emission?t.emission:new n.Color(0,0,0),this.volumeEmission=void 0!==t.volumeEmission?t.volumeEmission:new n.Color(0,0,0),this.opticalDepth=void 0!==t.opticalDepth?t.opticalDepth:0,this.specular=void 0!==t.specular?t.specular:new n.Color(1,1,1),this.absorb=void 0!==t.absorb?t.absorb:new n.Color(.1,.1,.1),this.ior=void 0!==t.ior?t.ior:1,this.roughness=void 0!==t.roughness?t.roughness:.2,this.reflectionChance=void 0!==t.reflectionChance?t.reflectionChance:.1,this.refractionChance=void 0!==t.refractionChance?t.refractionChance:0,this.diffuseChance=void 0!==t.diffuseChance?t.diffuseChance:.9;const r=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/r,this.refractionChance=this.refractionChance/r,this.diffuseChance=this.diffuseChance/r,this.addImport(Nt())}get uniformType(){return"PathTracerWrapMaterial"}static glslClass(){return _a()}get usesUVMap(){return this.material.usesUVMap}glslRender(){let e="";return e+=Ta()(this),this.material.usesNormal?this.material.usesUVMap?e+=Ea()(this):e+=Pa()(this):this.material.usesUVMap?e+=ka()(this):e+=Ra()(this),e}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e),super.shader(e)}}function Na(e,t={}){return new Ba(e,t)}var La=r(7939),Fa=r.n(La),Ga=r(6142),za=r.n(Ga),ja=r(7260),Ha=r.n(ja);class Aa extends Vt{constructor(e){super(),this.shape=e,this.shape.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData()}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Fa()(this)}glslGradient(){return za()(this)}glslUVMap(){return Ha()(this)}setId(e){this.shape.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),super.onAdd(e)}shader(e){this.shape.shader(e),super.shader(e)}}function Oa(e){return new Aa(e)}var qa=r(2093),Wa=r.n(qa),Qa=r(2076),Ya=r.n(Qa),Xa=r(3335),$a=r.n(Xa),Ka=r(6428),Za=r.n(Ka),Ja=r(6861),eo=r.n(Ja),to=r(2905),no=r.n(to),ro=r(7333),ao=r.n(ro);const oo=1;class so extends Vt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("IntersectionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.maxType=void 0!==n.maxType?n.maxType:0,this.maxCoeff=0,this.maxType===oo)this.addImport(Wa()),this.maxCoeff=void 0!==n.maxCoeff?n.maxCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"IntersectionShape"}static glslClass(){return ao()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.maxType===oo?Za()(this):Ya()(this)}glslGradient(){return this.maxType===oo?eo()(this):$a()(this)}glslUVMap(){return no()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function io(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new so(e,arguments[r],t));return e}var lo=r(5442),co=r.n(lo),uo=r(3908),ho=r.n(uo),po=r(7762),mo=r.n(po),bo=r(7500),vo=r.n(bo),fo=r(3238),go=r.n(fo),xo=r(519),yo=r.n(xo),Vo=r(8655),Mo=r.n(Vo);const wo=1;class _o extends Vt{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("UnionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.minType=void 0!==n.minType?n.minType:0,this.minCoeff=0,this.minType===wo)this.addImport(co()),this.minCoeff=void 0!==n.minCoeff?n.minCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"UnionShape"}static glslClass(){return yo()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.minType===wo?go()(this):ho()(this)}glslGradient(){return this.minType===wo?Mo()(this):mo()(this)}glslUVMap(){return vo()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function Co(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new _o(e,arguments[r],t));return e}var To=r(3105),So=r.n(To),Ro=r(6242),Io=r.n(Ro),Eo=r(9338),Do=r.n(Eo);class Po extends Vt{constructor(e,t){if(e.isGlobal!==t.isGlobal)throw new Error("WrapShape: the two shapes should be both local or both global");super(),this.wrap=e,this.shape=t,this.shape.parent=this,this.wrap.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom(),this.wrap.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData(),this.wrap.updateData()}get isWrapShape(){return!0}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return So()(this)}glslGradient(){return Io()(this)}glslUVMap(){return Do()(this)}setId(e){this.wrap.setId(e),this.shape.setId(e),super.setId(e)}onAdd(e){this.wrap.onAdd(e),this.shape.onAdd(e),super.onAdd(e)}shader(e){this.wrap.shader(e),this.shape.shader(e),super.shader(e)}}function Uo(e,t){return new Po(e,t)}const ko={KeyA:"yawLeft",KeyD:"yawRight",KeyW:"pitchUp",KeyS:"pitchDown",KeyQ:"rollLeft",KeyE:"rollRight",ArrowUp:"forward",ArrowDown:"back",ArrowLeft:"left",ArrowRight:"right",Quote:"up",Slash:"down"};class Bo extends n.EventDispatcher{constructor(e){super(),this.camera=e,this.movementSpeed=.5,this.rollSpeed=.8,this._moveState={up:0,down:0,left:0,right:0,forward:0,back:0,pitchUp:0,pitchDown:0,yawLeft:0,yawRight:0,rollLeft:0,rollRight:0},this._moveVector=new s(0,0,0),this._rotationVector=new s(0,0,0),this._onKeyDown=ge(this,this.onKeyDown),this._onKeyUp=ge(this,this.onKeyUp),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}pause(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)}restore(){window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}onKeyDown(e){if(e.code in ko){const t=ko[e.code];this._moveState[t]=1,this.updateMovementVector(),this.updateRotationVector()}}onKeyUp(e){if(e.code in ko){const t=ko[e.code];this._moveState[t]=0,this.updateMovementVector(),this.updateRotationVector()}}updateMovementVector(){this._moveVector.x=-this._moveState.left+this._moveState.right,this._moveVector.y=-this._moveState.down+this._moveState.up,this._moveVector.z=-this._moveState.forward+this._moveState.back}updateRotationVector(){this._rotationVector.x=-this._moveState.pitchDown+this._moveState.pitchUp,this._rotationVector.y=-this._moveState.yawRight+this._moveState.yawLeft,this._rotationVector.z=-this._moveState.rollRight+this._moveState.rollLeft}update(e){const t=this._moveVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix);this.camera.position.flow(t);const r=this._rotationVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix),a=new n.Quaternion(r.x,r.y,r.z,1).normalize();this.camera.position.applyQuaternion(a)}}class No{constructor(e="i"){this.action=void 0,this.key=e;const t=ge(this,this.onKeyDown);window.addEventListener("keydown",t,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.action&&this.action()}}class Lo{constructor(e,t,n){this.controller=e,this.camera=t,this.solid=n,this._isSelecting=!1,this._isSqueezing=!1;const r=ge(this,this.onSelectStart),a=ge(this,this.onSelectEnd),o=ge(this,this.onSqueezeStart),s=ge(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",r),this.controller.addEventListener("selectend",a),this.controller.addEventListener("squeezestart",o),this.controller.addEventListener("squeezeend",s)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}chase(e){this.solid.isRendered=this._isSelecting;const t=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const t=e.getCamera(this.camera.threeCamera).cameras,a=(new n.Vector3).setFromMatrixPosition(t[Ve].matrixWorld),o=(new n.Vector3).setFromMatrixPosition(t[Me].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=t.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.solid.isom.copy(i.globalBoost),this.solid.isom.matrix.multiply(i.facing),this.solid.updateData()}}class Fo{constructor(e="p"){this.actionKeyDown=void 0,this.actionKeyUp=void 0,this.key=e;const t=ge(this,this.onKeyDown),n=ge(this,this.onKeyUp);window.addEventListener("keydown",t,!1),window.addEventListener("keyup",n,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.actionKeyDown&&this.actionKeyDown()}onKeyUp(e){e.key===this.key&&void 0!==this.actionKeyUp&&this.actionKeyUp()}}class Go{constructor(e,t,r,a){this.controller=e,this.camera=t,this.solids=r,this.speed=a,this._status=0,this._nextBullet=0,this._clock=new n.Clock;const o=ge(this,this.onSelectStart),s=ge(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){0===this._status&&(this._status=1)}onSelectEnd(){}shoot(e){const t=this.solids[this._nextBullet];t.bulletData={time:this._clock.getElapsedTime(),position:e},t.isRendered=!0,this._nextBullet=(this._nextBullet+1)%this.solids.length}updateBullet(e){const t=this.solids[e];if(t.hasOwnProperty("bulletData")){const e=this._clock.getElapsedTime()-t.bulletData.time,n=t.bulletData.position.clone().flow(new s(0,0,-this.speed*e));t.isom.copy(n.boost),t.updateData()}}updateAllBullets(){for(let e=0;e<this.solids.length;e++)this.updateBullet(e)}update(e){if(1===this._status){const t=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const t=e.getCamera(this.camera.threeCamera).cameras,a=(new n.Vector3).setFromMatrixPosition(t[Ve].matrixWorld),o=(new n.Vector3).setFromMatrixPosition(t[Me].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=t.clone().sub(r),o=this.controller.matrixWorld.clone().setPosition(a),i=this.camera.position.clone().fakeDiffExpMap(o);this.shoot(i.globalPosition),this._status=0}this.updateAllBullets()}}class zo{constructor(e="p",t=2,n=0){this.key=e,this.stateNumber=t,this.state=n,this.justChanged=!1;const r=ge(this,this.onKeyDown);window.addEventListener("keydown",r,!1)}onKeyDown(e){e.key===this.key&&(this.state=(this.state+1)%this.stateNumber,this.justChanged=!0)}}class jo extends n.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this._isSelecting=!1,this._isSqueezing=!1;const n=ge(this,this.onSelectStart),r=ge(this,this.onSelectEnd),a=ge(this,this.onSqueezeStart),o=ge(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}get update(){if(void 0===this._update){const e=10,t=new s,r=new s;let a=[],o=0,i=!1;this._update=function(l){const c=new s;if(this.controller.getWorldDirection(c),c.normalize().multiplyScalar(1/e),r.add(c),i&&r.sub(a[o]),a[o]=c,i&&this._isSelecting){const e=r.clone().normalize(),a=t.clone().normalize(),o=(new n.Quaternion).setFromUnitVectors(e,a).normalize();this.position.applyQuaternion(o)}t.copy(r),o=(o+1)%e,0===o&&(i=!0)}}return this._update}}class Ho extends n.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this.movementSpeed=.5,this._isSelecting=!1,this._isSqueezing=!1;const n=ge(this,this.onSelectStart),r=ge(this,this.onSelectEnd),a=ge(this,this.onSqueezeStart),o=ge(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",a),this.controller.addEventListener("squeezeend",o)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}update(e){if(this._isSelecting){const t=new s;this.controller.getWorldDirection(t),t.normalize().multiplyScalar(-this.movementSpeed*e),this.position.flow(t)}}}class Ao{constructor(e,t,n){this.controller=e,this.camera=t,this.light=n}chase(e){const t=(new s).setFromMatrixPosition(this.controller.matrixWorld);let r=new s;if(this.camera.isStereoOn){const t=e.getCamera(this.camera.threeCamera).cameras,a=(new n.Vector3).setFromMatrixPosition(t[Ve].matrixWorld),o=(new n.Vector3).setFromMatrixPosition(t[Me].matrixWorld);r.lerpVectors(a,o,.5)}else r.setFromMatrixPosition(this.camera.matrix);const a=t.clone().sub(r),i=this.controller.matrixWorld.clone().setPosition(a),l=this.camera.position.clone().fakeDiffExpMap(i);this.light.position=(new o).applyIsometry(l.globalBoost)}}class Oo{constructor(e,t,n=!1,r=!1,a=void 0){if(this.position=e,this.controller=t,this._reset=0,this._alignFacing=n,this._snap=r,this._camera=a,this._alignFacing&&void 0===a)throw new Error("VRControlsReset.constructor, the camera is needed when the alignFacing option is on");const o=ge(this,this.onSelectStart),s=ge(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){this._reset=1}onSelectEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0}}}class qo{constructor(e,t,n,r=!1,a=!1,o=void 0){if(this.position=e,this.targetPosition=t,this.controller=n,this._reset=0,this._alignFacing=r,this._snap=a,this._camera=o,this._alignFacing&&void 0===o)throw new Error("AdvancedResetVRControls.constructor, the camera is needed when the alignFacing option is on");const s=ge(this,this.onSqueezeStart),i=ge(this,this.onSqueezeEnd);this.controller.addEventListener("squeezestart",s),this.controller.addEventListener("squeezeend",i)}onSqueezeStart(){this._reset=1}onSqueezeEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this._snap&&(this.position.local.quaternion.x=0,this.position.local.quaternion.z=0,this.position.local.quaternion.normalize()),this.position.local.quaternion.invert()}this._reset=0,this.position.local.boost.copy(this.targetPosition.boost),this.position.local.quaternion.premultiply(this.targetPosition.quaternion)}}}var Wo=r(6947),Qo=r.n(Wo);class Yo extends Q{constructor(e){super(),this.exposure=void 0!==e?e:.8}uniforms(){const e=super.uniforms();return e.exposure={value:this.exposure},e}fragmentShader(){return Qo()}}var Xo=r(4024),$o=r.n(Xo);class Ko extends Q{constructor(){super()}fragmentShader(){return $o()}}class Zo{constructor(e,t=0,n=0){this.ring=e,this.a=t,this.b=n,this.reduce()}reduce(){return this.a=Math.round(this.a),this.b=Math.round(this.b),this}negate(){return this.a=-this.a,this.b=-this.b,this}multiply(e){const t=this.a,n=this.b;return this.a=t*e.a+this.ring.d*n*e.b,this.b=t*e.b+n*e.a,this.reduce()}add(e){return this.a=this.a+e.a,this.b=this.b+e.b,this.reduce()}sub(e){return this.a=this.a-e.a,this.b=this.b-e.b,this.reduce()}sum(){this.copy(this.ring.zero);for(const e of arguments)this.add(e);return this}product(){this.copy(this.ring.one);for(const e of arguments)this.multiply(e);return this}addProduct(){const e=new Zo(this.ring).product(...arguments);return this.add(e),this}subProduct(){const e=new Zo(this.ring).product(...arguments);return this.sub(e),this}toNumber(){return this.a+this.b*Math.sqrt(this.ring.d)}equals(e){return this.a===e.a&&this.b===e.b}isZero(){return 0===this.a&&0===this.b}clone(){const e=new Zo(this.ring);return e.a=this.a,e.b=this.b,e}copy(e){return this.a=e.a,this.b=e.b,this}toLog(){return`${this.a} + ${this.b} _rD`}}var Jo=r(5688),es=r.n(Jo);class ts{constructor(e){this.ring=e,this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()]}get isQuadRingMatrix4(){return!0}get a(){const e=this.toArray().map((e=>e.a));return(new n.Matrix4).fromArray(e)}get b(){const e=this.toArray().map((e=>e.b));return(new n.Matrix4).fromArray(e)}getEntry(e,t){return this.elements[4*t+e]}setEntry(e,t,n){return this.elements[4*t+e].copy(n),this}set(e,t,n,r,a,o,s,i,l,c,d,u,h,p,m,b){for(let e=0;e<4;e++)for(let t=0;t<4;t++)this.setEntry(e,t,arguments[4*e+t]);return this}identity(){return this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()],this}multiplyMatrices(e,t){for(let n=0;n<4;n++)for(let r=0;r<4;r++){this.setEntry(n,r,this.ring.zero);for(let a=0;a<4;a++)this.getEntry(n,r).addProduct(e.getEntry(n,a),t.getEntry(a,r))}return this}multiply(e){return this.multiplyMatrices(this.clone(),e)}premultiply(e){return this.multiplyMatrices(e,this.clone())}multiplyScalar(e){for(let t=0;t<16;t++)this.elements[t].multiply(e);return this}transpose(){const e=this.elements;let t=this.ring.element();return t.copy(e[1]),e[1].copy(e[4]),e[4].copy(t),t.copy(e[2]),e[2].copy(e[8]),e[8].copy(t),t.copy(e[6]),e[6].copy(e[9]),e[9].copy(t),t.copy(e[3]),e[3].copy(e[12]),e[12].copy(t),t.copy(e[7]),e[7].copy(e[13]),e[13].copy(t),t.copy(e[11]),e[11].copy(e[14]),e[14].copy(t),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],a=e[3],o=e[4],s=e[5],i=e[6],l=e[7],c=e[8],d=e[9],u=e[10],h=e[11],p=e[12],m=e[13],b=e[14],v=e[15];return e[0]=this.ring.element().addProduct(d,b,l).subProduct(m,u,l).addProduct(m,i,h).subProduct(s,b,h).subProduct(d,i,v).addProduct(s,u,v),e[1]=this.ring.element().addProduct(m,u,a).subProduct(d,b,a).subProduct(m,r,h).addProduct(n,b,h).addProduct(d,r,v).subProduct(n,u,v),e[2]=this.ring.element().addProduct(s,b,a).subProduct(m,i,a).addProduct(m,r,l).subProduct(n,b,l).subProduct(s,r,v).addProduct(n,i,v),e[3]=this.ring.element().addProduct(d,i,a).subProduct(s,u,a).subProduct(d,r,l).addProduct(n,u,l).addProduct(s,r,h).subProduct(n,i,h),e[4]=this.ring.element().addProduct(p,u,l).subProduct(c,b,l).subProduct(p,i,h).addProduct(o,b,h).addProduct(c,i,v).subProduct(o,u,v),e[5]=this.ring.element().addProduct(c,b,a).subProduct(p,u,a).addProduct(p,r,h).subProduct(t,b,h).subProduct(c,r,v).addProduct(t,u,v),e[6]=this.ring.element().addProduct(p,i,a).subProduct(o,b,a).subProduct(p,r,l).addProduct(t,b,l).addProduct(o,r,v).subProduct(t,i,v),e[7]=this.ring.element().addProduct(o,u,a).subProduct(c,i,a).addProduct(c,r,l).subProduct(t,u,l).subProduct(o,r,h).addProduct(t,i,h),e[8]=this.ring.element().addProduct(c,m,l).subProduct(p,d,l).addProduct(p,s,h).subProduct(o,m,h).subProduct(c,s,v).addProduct(o,d,v),e[9]=this.ring.element().addProduct(p,d,a).subProduct(c,m,a).subProduct(p,n,h).addProduct(t,m,h).addProduct(c,n,v).subProduct(t,d,v),e[10]=this.ring.element().addProduct(o,m,a).subProduct(p,s,a).addProduct(p,n,l).subProduct(t,m,l).subProduct(o,n,v).addProduct(t,s,v),e[11]=this.ring.element().addProduct(c,s,a).subProduct(o,d,a).subProduct(c,n,l).addProduct(t,d,l).addProduct(o,n,h).subProduct(t,s,h),e[12]=this.ring.element().addProduct(p,d,i).subProduct(c,m,i).subProduct(p,s,u).addProduct(o,m,u).addProduct(c,s,b).subProduct(o,d,b),e[13]=this.ring.element().addProduct(c,m,r).subProduct(p,d,r).addProduct(p,n,u).subProduct(t,m,u).subProduct(c,n,b).addProduct(t,d,b),e[14]=this.ring.element().addProduct(p,s,r).subProduct(o,m,r).subProduct(p,n,i).addProduct(t,m,i).addProduct(o,n,b).subProduct(t,s,b),e[15]=this.ring.element().addProduct(o,d,r).subProduct(c,s,r).addProduct(c,n,i).subProduct(t,d,i).subProduct(o,n,u).addProduct(t,s,u),this}equals(e){for(let t=0;t<16;t++)if(!this.elements[t].equals(e.elements[t]))return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n].copy(e[n+t]);return this}toArray(e=[],t=0){const n=this.elements;for(let r=0;r<16;r++)e[t+r]=n[r].clone();return e}toMatrix4(){const e=this.toArray().map((e=>e.toNumber()));return(new n.Matrix4).fromArray(e)}clone(){return new ts(this.ring).fromArray(this.elements)}copy(e){return this.fromArray(e.elements)}toLog(){return this.toMatrix4().toLog()}}class ns{constructor(e){this.d=e}element(e=0,t=0){return new Zo(this,e,t)}matrix4(){return new ts(this)}get one(){return new Zo(this,1)}get zero(){return new Zo(this,0)}shader(e){e.addChunk(es()),e.addConstant("QUAD_RING_D","int",this.d)}}class rs{constructor(){this.elements=[1,0,0,1]}set(e,t,n,r){return this.elements=[e,n,t,r],this}identity(){return this.set(1,0,0,1),this}multplyMatrices(e,t){const[n,r,a,o]=e.elements,[s,i,l,c]=t.elements;return this.elements=[n*s+a*i,r*s+o*i,n*l+a*c,r*l+o*c],this}multiply(e){return this.multplyMatrices(this,e)}premultiply(e){return this.multplyMatrices(e,this)}power(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}}determinant(){const[e,t,n,r]=this.elements;return e*r-n*t}invert(){const[e,t,n,r]=this.elements,a=this.determinant();return this.elements=[r/a,-t/a,-n/a,e/a],this}clone(){const e=new rs;for(let t=0;t<4;t++)e.elements[t]=this.elements[t];return e}copy(e){for(let t=0;t<4;t++)this.elements[t]=e.elements[t];return this}equals(e){for(let t=0;t<4;t++)if(this.elements[t]!==e.elements[t])return!1;return!0}}var as=r(4905),os=r.n(as);class ss extends _e{constructor(e,t=0,r=0,a=0,o=1){super(e),this.quaternion=new n.Quaternion(t,r,a,o)}get icoords(){return this.quaternion.toArray()}identity(){return this.quaternion.identity(),this}multiply(e){return this.quaternion.multiply(e.quaternion),this}premultiply(e){return this.quaternion.premultiply(e.quaternion),this}invert(){return this.quaternion.conjugate(),this}toIsometry(){const[e,n,r,a]=this.quaternion.toArray(),o=new t;return o.matrix.set(a,-r,-n,-e,r,a,e,-n,n,-e,a,r,e,n,-r,a),o}equals(e){return this.quaternion.equals(e.quaternion)}clone(){const e=new ss(this.group);return e.quaternion.copy(this.quaternion),e}copy(e){return this.quaternion.copy(e.quaternion),this}}const is=new class extends $e{constructor(){super()}element(){let e=0,t=0,n=0,r=1;return 4===arguments.length&&([e,t,n,r]=arguments),new ss(this,e,t,n,r)}shader(e){e.addChunk(os())}},ls=new n.Vector4(1,0,0,-1),cs=new n.Vector4(-1,0,0,-1),ds=new n.Vector4(0,1,0,-1),us=new n.Vector4(0,-1,0,-1),hs=new n.Vector4(0,0,1,-1),ps=new n.Vector4(0,0,-1,-1);const ms=is.element(1,0,0,0),bs=is.element(-1,0,0,0),vs=is.element(0,1,0,0),fs=is.element(0,-1,0,0),gs=is.element(0,0,-1,0),xs=is.element(0,0,1,0),ys=(new bt).add((function(e){return ls.dot(e.coords)>0}),"//\nbool testXp(Point p){\n    vec4 n = vec4(1, 0, 0, -1);\n    return dot(n, p.coords) > 0.;\n}\n",ms,bs,"//\nfloat creepXp(ExtVector v, float offset){\n    vec4 n = vec4(1, 0, 0, -1);\n    vec4 coords = v.vector.local.pos.coords;\n    vec4 dir = v.vector.local.dir;\n    return -atan(dot(coords, n)/dot(dir, n)) + offset;\n}\n").add((function(e){return cs.dot(e.coords)>0}),"//\nbool testXn(Point p){\n    vec4 n = vec4(-1, 0, 0, -1);\n    return dot(n, p.coords) > 0.;\n}\n",bs,ms,"//\nfloat creepXn(ExtVector v, float offset){\n    vec4 n = vec4(-1, 0, 0, -1);\n    vec4 coords = v.vector.local.pos.coords;\n    vec4 dir = v.vector.local.dir;\n    return -atan(dot(coords, n)/dot(dir, n)) + offset;\n}\n").add((function(e){return ds.dot(e.coords)>0}),"//\nbool testYp(Point p){\n    vec4 n = vec4(0, 1, 0, -1);\n    return dot(n, p.coords) > 0.;\n}\n",vs,fs,"//\nfloat creepYp(ExtVector v, float offset){\n    vec4 n = vec4(0, 1, 0, -1);\n    vec4 coords = v.vector.local.pos.coords;\n    vec4 dir = v.vector.local.dir;\n    return -atan(dot(coords, n)/dot(dir, n)) + offset;\n}\n").add((function(e){return us.dot(e.coords)>0}),"//\nbool testYn(Point p){\n    vec4 n = vec4(0, -1, 0, -1);\n    return dot(n, p.coords) > 0.;\n}\n",fs,vs,"//\nfloat creepYn(ExtVector v, float offset){\n    vec4 n = vec4(0, -1, 0, -1);\n    vec4 coords = v.vector.local.pos.coords;\n    vec4 dir = v.vector.local.dir;\n    return -atan(dot(coords, n)/dot(dir, n)) + offset;\n}\n").add((function(e){return hs.dot(e.coords)>0}),"//\nbool testZp(Point p){\n    vec4 n = vec4(0, 0, 1, -1);\n    return dot(n, p.coords) > 0.;\n}\n",gs,xs,"//\nfloat creepZp(ExtVector v, float offset){\n    vec4 n = vec4(0, 0, 1, -1);\n    vec4 coords = v.vector.local.pos.coords;\n    vec4 dir = v.vector.local.dir;\n    return -atan(dot(coords, n)/dot(dir, n)) + offset;\n}\n").add((function(e){return ps.dot(e.coords)>0}),"//\nbool testZn(Point p){\n    vec4 n = vec4(0, 0, -1, -1);\n    return dot(n, p.coords) > 0.;\n}\n",xs,gs,"//\nfloat creepZn(ExtVector v, float offset){\n    vec4 n = vec4(0, 0, -1, -1);\n    vec4 coords = v.vector.local.pos.coords;\n    vec4 dir = v.vector.local.dir;\n    return -atan(dot(coords, n)/dot(dir, n)) + offset;\n}\n");class Vs extends _e{constructor(e){super(e),this.isom=new t}identity(){return this.isom.identity(),this}multiply(e){return this.isom.multiply(e.isom),this}premultiply(e){return this.isom.premultiply(e.isom),this}invert(){return this.isom.invert(),this}toIsometry(){return this.isom.clone()}equals(e){return this.isom.equals(e.isom)}clone(){const e=new Vs;return e.isom.copy(this.isom),e}copy(e){return this.isom.copy(e.isom),this}}var Ms=r(6097),ws=r.n(Ms);function _s(e){const t=e.coords;return new n.Vector3(t.x/t.w,t.y/t.w,t.z/t.w)}const Cs=Math.PI/10,Ts=Math.PI/5,Ss=.5+.5*Math.sqrt(5),Rs=[new s(0,1,Ss),new s(0,1,-Ss),new s(1,Ss,0),new s(1,-Ss,0),new s(Ss,0,1),new s(-Ss,0,1)],Is=new class extends $e{constructor(){super()}element(){return new Vs(this)}shader(e){e.addChunk(ws())}},Es=new bt;for(let e=0;e<Rs.length;e++){const r=Rs[e].normalize(),a=r.clone().normalize().multiplyScalar(Cs),s=_s((new o).applyIsometry((new t).makeTranslationFromDir(a))),i=s.dot(s),l=new n.Vector4(s.x,s.y,s.z,-i),c=function(e){return e.coords.dot(l)>0},d=new n.Vector4(s.x,s.y,s.z,i),u=function(e){return e.coords.dot(d)<0},h=`//\n    bool test${e}P(Point p){\n        vec4 normal = vec4(${s.x}, ${s.y}, ${s.z}, -${i});\n        return dot(p.coords, normal) > 0.;\n    }\n    `,p=`//\n    bool test${e}N(Point p){\n        vec4 normal = vec4(${s.x}, ${s.y}, ${s.z}, ${i});\n        return dot(p.coords, normal) < 0.;\n    }\n    `,m=r.clone().normalize().multiplyScalar(-2*Cs),b=Is.element();b.isom.makeTranslationFromDir(m),b.isom.matrix.multiply((new n.Matrix4).makeRotationAxis(r,Ts));const v=Is.element();v.isom.copy(b.isom).invert(),Es.add(c,h,b,v),Es.add(u,p,v,b)}const Ds=Es;var Ps=r(3830),Us=r.n(Ps),ks=r(217),Bs=r.n(ks),Ns=r(1156),Ls=r.n(Ns),Fs=r(3483),Gs=r.n(Fs),zs=r(7577),js=r.n(zs);class Hs extends Mt{constructor(e,n,r=1){if(super(2),this.position=void 0,e.isPoint)this.position=e;else{if(!e.isVector)throw new Error("BallShape: this type is not allowed");{const n=(new t).makeTranslationFromDir(e);this.position=(new o).applyIsometry(n)}}this.color=n,this.intensity=r,this.addImport(Us(),Bs(),Ls())}get isGlobal(){return!0}get isLocal(){return!this.isGlobal}get uniformType(){return"PointLight"}static glslClass(){return Gs()}glslDirections(){return js()(this)}}var As=r(7520),Os=r.n(As);class qs extends Mt{constructor(e,t=1,r=void 0){super(1),this.color=e,this.intensity=t,this.direction=void 0!==r?r.clone().normalize():new n.Vector4(0,0,0,1)}get isGlobal(){return!0}get uniformType(){return"ConstDirLight"}static glslClass(){return Os()}glslDirections(){return js()(this)}}var Ws=r(9182),Qs=r.n(Ws);class Ys extends Mt{constructor(e,n,r=1){if(super(2),this.position=void 0,e.isPoint)this.position=e;else{if(!e.isVector)throw new Error("BallShape: this type is not allowed");{const n=(new t).makeTranslationFromDir(e);this.position=(new o).applyIsometry(n)}}this.color=n,this.intensity=r,this.addImport(Us(),Bs(),Ls())}get isGlobal(){return!0}get isLocal(){return!this.isGlobal}get uniformType(){return"LocalPointLight"}static glslClass(){return Qs()}glslDirections(){return js()(this)}}var Xs=r(4193),$s=r.n(Xs);class Ks extends wt{constructor(e,t){super(),this.mainColor=e,this.weight=t}get uniformType(){return"VaryingColorMaterial"}get usesNormal(){return!1}static glslClass(){return $s()}glslRender(){return It()(this)}}var Zs=r(3889),Js=r.n(Zs);class ei extends wt{constructor(e,t,n,r,a){super(),this.mainColor=e,this.accent1=t,this.accent2=n,this.accent3=r,this.grid=null!=a&&a}get uniformType(){return"MultiColorMaterial"}get usesNormal(){return!1}static glslClass(){return Js()}glslRender(){return It()(this)}}var ti=r(2473),ni=r.n(ti),ri=r(3707),ai=r.n(ri),oi=r(5030),si=r.n(oi),ii=r(4355),li=r.n(ii);class ci extends yt{constructor(e,n){const r=new t;if(e.isIsometry)r.copy(e);else if(e.isPoint)r.makeTranslation(e);else{if(!e.isVector)throw new Error("BallShape: this type of location is not allowed");r.makeTranslationFromDir(e)}super(r),this.addImport(Us(),Bs()),this.radius=n,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isBallShape(){return!0}get isGlobal(){return!0}get hasUVMap(){return!0}get uniformType(){return"BallShape"}static glslClass(){return ni()}glslSDF(){return ai()(this)}glslGradient(){return si()(this)}glslUVMap(){return li()(this)}}var di=r(9937),ui=r.n(di);class hi extends yt{constructor(e,n){const r=new t;if(e.isIsometry)r.copy(e);else if(e.isPoint)r.makeTranslation(e);else{if(!e.isVector)throw new Error("BallShape: this type of location is not allowed");r.makeTranslationFromDir(e)}super(r),this.addImport(Us(),Bs()),this.radius=n,this._center=void 0}updateData(){super.updateData(),this._center=(new o).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isLocalBallShape(){return!0}get isGlobal(){return!1}get hasUVMap(){return!0}get uniformType(){return"LocalBallShape"}static glslClass(){return ui()}glslSDF(){return ai()(this)}glslGradient(){return si()(this)}glslUVMap(){return li()(this)}}var pi=r(9474),mi=r.n(pi);class bi extends yt{constructor(e,t){super(e),this.addImport(Bs()),this.radius=t,this._direction=void 0,this._uvTestX=void 0,this._uvTestY=void 0}updateData(){super.updateData(),this._direction={pos:(new o).applyIsometry(this.absoluteIsom),dir:new n.Vector4(0,0,1,0).applyMatrix4(this.absoluteIsom.matrix)},this._uvTestX=new n.Vector4(1,0,0,0).applyMatrix4(this.absoluteIsom.matrix),this._uvTestY=new n.Vector4(0,1,0,0).applyMatrix4(this.absoluteIsom.matrix)}get direction(){return void 0===this._direction&&this.updateData(),this._direction}get uvTestX(){return void 0===this._uvTestX&&this.updateData(),this._uvTestX}get uvTestY(){return void 0===this._uvTestY&&this.updateData(),this._uvTestY}get isCylinderShape(){return!0}get isGlobal(){return!0}get hasUVMap(){return!0}get uniformType(){return"CylinderShape"}static glslClass(){return mi()}glslSDF(){return ai()(this)}glslGradient(){return si()(this)}glslUVMap(){return li()(this)}}var vi=r(8166),fi=r.n(vi);class gi extends yt{constructor(e){const n=new t;if(!e.isIsometry)throw new Error("CliffordTorusShape: this type of location is not allowed");n.copy(e),super(n)}updateData(){super.updateData()}get isCliffordTorusShape(){return!0}get isGlobal(){return!0}get hasUVMap(){return!0}get uniformType(){return"CliffordTorusShape"}static glslClass(){return fi()}glslSDF(){return ai()(this)}glslGradient(){return si()(this)}glslUVMap(){return li()(this)}}var xi=r(9527),yi=r.n(xi);class Vi extends yt{constructor(e,t,r,a){super(e),this.addImport(Bs());const o=t*t+r*r;if(o>1)throw new Error("CircleShape: the circle in not on the sphere");const s=Math.sqrt(1-o);this.c=new n.Vector4(s,s,t,r),this.radius=a,this.updateData()}updateData(){super.updateData()}get isCircleShape(){return!0}get isGlobal(){return!0}get hasUVMap(){return!0}get uniformType(){return"CircleShape"}static glslClass(){return yi()}glslSDF(){return ai()(this)}glslGradient(){return si()(this)}glslUVMap(){return li()(this)}}var Mi=r(9521),wi=r.n(Mi);class _i extends yt{constructor(e){const n=new t;if(!e.isIsometry)throw new Error("HalfSpaceShape: this type of location is not allowed");n.copy(e),super(n),this._normal=void 0}updateData(){super.updateData();const e=(new o).applyIsometry(this.absoluteIsom),t=new n.Vector4(0,0,1,0).applyMatrix4(this.absoluteIsom.matrix);this._normal={pos:e,dir:t}}get normal(){return void 0===this._normal&&this.updateData(),this._normal}get isHalfSpaceShape(){return!0}get isGlobal(){return!0}get hasUVMap(){return!0}get uniformType(){return"HalfSpaceShape"}static glslClass(){return wi()}glslSDF(){return ai()(this)}glslGradient(){return si()(this)}glslUVMap(){return li()(this)}}var Ci=r(9807),Ti=r.n(Ci);class Si extends yt{constructor(e,t){super(e),this.addImport(Bs()),this.radius=t,this._direction=void 0,this._uvTestX=void 0,this._uvTestY=void 0}updateData(){super.updateData(),this._direction={pos:(new o).applyIsometry(this.absoluteIsom),dir:new n.Vector4(0,0,1,0).applyMatrix4(this.absoluteIsom.matrix)},this._uvTestX=new n.Vector4(1,0,0,0).applyMatrix4(this.absoluteIsom.matrix),this._uvTestY=new n.Vector4(0,1,0,0).applyMatrix4(this.absoluteIsom.matrix)}get direction(){return void 0===this._direction&&this.updateData(),this._direction}get uvTestX(){return void 0===this._uvTestX&&this.updateData(),this._uvTestX}get uvTestY(){return void 0===this._uvTestY&&this.updateData(),this._uvTestY}get isGlobal(){return!1}get hasUVMap(){return!0}get uniformType(){return"LocalCylinderShape"}static glslClass(){return Ti()}glslSDF(){return ai()(this)}glslGradient(){return si()(this)}glslUVMap(){return li()(this)}}var Ri=r(7499),Ii=r.n(Ri);class Ei extends vt{constructor(e,t,n=void 0){if(!e.hasUVMap){if(t.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map");if(void 0!==n&&n.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map")}super(),this.shape=e,this.material=t,this.ptMaterial=n,this.isRendered=!0,this.addImport(Ii())}get isSolid(){return!0}get isom(){return this.shape.isom}get absoluteIsom(){return this.shape.absoluteIsom}get isGlobal(){return this.shape.isGlobal}get isLocal(){return this.shape.isLocal}get uniformType(){return"Solid"}updateData(){this.shape.updateData()}setId(e){this.shape.setId(e),this.material.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),this.material.onAdd(e),super.onAdd(e)}static glslClass(){return""}glslInstance(){return`\n            bool ${this.name}_isRenderedHack = true;\n        `}shader(e){this.shape.shader(e),3===e.useCase&&void 0!==this.ptMaterial?this.ptMaterial.shader(e):this.material.shader(e),super.shader(e)}}class Di extends Ei{constructor(e,t,n,r=void 0){super(new ci(e,t),n,r)}}class Pi extends Ei{constructor(e,t,n,r=void 0){super(new hi(e,t),n,r)}}class Ui extends Ei{constructor(e,t,n,r=void 0){super(new bi(e,t),n,r)}}class ki extends Ei{constructor(e,t,n=void 0){super(new gi(e),t,n)}}class Bi extends Ei{constructor(e,t,n,r,a,o=void 0){super(new Vi(e,t,n,r),a,o)}}class Ni extends Ei{constructor(e,t,n=void 0){super(new _i(e),t,n)}}class Li extends Ei{constructor(e,t,n,r=void 0){super(new Si(e,t),n,r)}}h.prototype.constructor.shader1=c(),h.prototype.constructor.shader2=u()})();var o=a.T0,s=a.FJ,i=a.GU,l=a.XH,c=a.ec,d=a.Yb,u=a.ZH,h=a.K9,p=a.FT,m=a.cK,b=a._x,v=a.kj,f=a.V1,g=a.Vz,x=a.Cd,y=a.n,V=a.y7,M=a.UQ,w=a.ck,_=a.Iy,C=a.Vf,T=a.Ab,S=a.g6,R=a.TB,I=a.Al,E=a.ix,D=a.jZ,P=a.c$,U=a.Qj,k=a.mD,B=a.yb,N=a.iJ,L=a.ZA,F=a.Jz,G=a.Fr,z=a.RM,j=a.fR,H=a.kK,A=a.ZX,O=a._f,q=a.Ht,W=a.HZ,Q=a.TN,Y=a.JV,X=a.Sc,$=a.Nh,K=a.RL,Z=a._k,J=a.uR,ee=a.gU,te=a.jo,ne=a.Q,re=a.gq,ae=a.Gj,oe=a.L8,se=a.F5,ie=a.Uc,le=a.Fh,ce=a.O5,de=a.oB,ue=a.pJ,he=a.GW,pe=a.DZ,me=a._K,be=a.JF,ve=a.Lv,fe=a.E9,ge=a.ce,xe=a.Ly,ye=a.iv,Ve=a.mH,Me=a.xd,we=a.pX,_e=a.Dz,Ce=a.Th,Te=a.Uj,Se=a.bY,Re=a.cV,Ie=a.lR,Ee=a.xs,De=a.bn,Pe=a.oC,Ue=a.Z1,ke=a.h8,Be=a.Qf,Ne=a.jE,Le=a.k1,Fe=a.ew,Ge=a.$p,ze=a.xG,je=a.l_,He=a.pk,Ae=a.yI,Oe=a.E6,qe=a.zO,We=a.cB,Qe=a.OW,Ye=a.n3,Xe=a.Se,$e=a.PQ,Ke=a.$9,Ze=a.ak,Je=a.uZ,et=a.Cy,tt=a.qM,nt=a.mV,rt=a.Gi,at=a.jV,ot=a.j9,st=a.oc,it=a.wS,lt=a.IJ,ct=a.Ij,dt=a.c0,ut=a.p2,ht=a.w0,pt=a.VL,mt=a.UR,bt=a.dV,vt=a.G0,ft=a.YL,gt=a.re;export{o as AcesFilmPostProcess,s as AdvancedResetVRControls,i as AdvancedShape,l as BOTH,c as Ball,d as BallShape,u as BasicPTMaterial,h as BasicRenderer,p as BasicShape,m as CREEPING_FULL,b as CREEPING_OFF,v as CREEPING_STRICT,f as Camera,g as CheckerboardMaterial,x as Circle,y as CircleShape,V as CliffordTorus,M as CliffordTorusShape,w as CombinedPostProcess,_ as ComplementShape,C as ConstDirLight,T as Cylinder,S as CylinderShape,R as DebugMaterial,I as DragVRControls,E as EquidistantHypStripsMaterial,D as EquidistantSphStripsMaterial,P as ExpFog,U as FlatCamera,k as FlyControls,B as Fog,N as GraphPaperMaterial,L as Group,F as GroupElement,G as HalfSpace,z as HalfSpaceShape,j as HighlightLocalWrapMaterial,H as HighlightWrapMaterial,A as HypStripsMaterial,O as ImprovedEquidistantHypStripsMaterial,q as ImprovedEquidistantSphStripsMaterial,W as InfoControls,Q as IntersectionShape,Y as Isometry,X as IsotropicChaseVRControls,$ as KeyGenericControls,K as LEFT,Z as Light,J as LightVRControls,ee as LinearToSRGBPostProcess,te as LocalBall,ne as LocalBallShape,re as LocalCylinder,ae as LocalCylinderShape,oe as LocalPointLight,se as Material,ie as Matrix2,le as MoveVRControls,ce as MultiColorMaterial,de as NormalMaterial,ue as PTMaterial,he as PathTracerCamera,pe as PathTracerRenderer,me as PathTracerWrapMaterial,be as PhongMaterial,ve as PhongWrapMaterial,fe as Point,ge as PointLight,xe as Position,ye as QuadRing,Ve as QuadRingElement,Me as QuadRingMatrix4,we as RIGHT,_e as RelPosition,Ce as Renderer,Te as ResetVRControls,Se as RotatedSphericalTextureMaterial,Re as SMOOTH_MAX_POLY,Ie as SMOOTH_MIN_POLY,Ee as Scene,De as Shape,Pe as ShootVRControls,Ue as SimpleTextureMaterial,ke as SingleColorMaterial,Be as Solid,Ne as SphereCamera,Le as SquaresMaterial,Fe as StripsMaterial,Ge as SwitchControls,ze as TeleportationSet,je as TransitionLocalWrapMaterial,He as TransitionWrapMaterial,Ae as UnionShape,Oe as VRCamera,qe as VRRenderer,We as VaryingColorMaterial,Qe as Vector,Ye as VideoAlphaTextureMaterial,Xe as VideoFrameTextureMaterial,$e as VideoTextureMaterial,Ke as WrapShape,Ze as bind,Je as clamp,et as complement,tt as earthTexture,nt as highlightLocalWrap,rt as highlightWrap,at as intersection,ot as marsTexture,st as moonTexture,it as pathTracerWrap,lt as phongWrap,ct as poincareSet,dt as quaternionSet,ut as safeString,ht as sunTexture,pt as transitionLocalWrap,mt as transitionWrap,bt as trivialSet,vt as union,ft as woodBallMaterial,gt as wrap};