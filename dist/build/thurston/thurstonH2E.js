import*as e from"three";import*as t from"webxr-polyfill";import*as n from"dat.gui";import*as r from"stats";var o={9397:(e,t)=>{!function(e){var t=/\S/,n=/\"/g,r=/\n/g,o=/\r/g,s=/\\/g,a=/\u2028/,i=/\u2029/;function l(e){"}"===e.n.substr(e.n.length-1)&&(e.n=e.n.substring(0,e.n.length-1))}function c(e){return e.trim?e.trim():e.replace(/^\s*|\s*$/g,"")}function h(e,t,n){if(t.charAt(n)!=e.charAt(0))return!1;for(var r=1,o=e.length;r<o;r++)if(t.charAt(n+r)!=e.charAt(r))return!1;return!0}e.tags={"#":1,"^":2,"<":3,$:4,"/":5,"!":6,">":7,"=":8,_v:9,"{":10,"&":11,_t:12},e.scan=function(n,r){var o=n.length,s=0,a=null,i=null,d="",u=[],p=!1,m=0,b=0,f="{{",v="}}";function g(){d.length>0&&(u.push({tag:"_t",text:new String(d)}),d="")}function y(n,r){if(g(),n&&function(){for(var n=!0,r=b;r<u.length;r++)if(!(n=e.tags[u[r].tag]<e.tags._v||"_t"==u[r].tag&&null===u[r].text.match(t)))return!1;return n}())for(var o,s=b;s<u.length;s++)u[s].text&&((o=u[s+1])&&">"==o.tag&&(o.indent=u[s].text.toString()),u.splice(s,1));else r||u.push({tag:"\n"});p=!1,b=u.length}function x(e,t){var n="="+v,r=e.indexOf(n,t),o=c(e.substring(e.indexOf("=",t)+1,r)).split(" ");return f=o[0],v=o[o.length-1],r+n.length-1}for(r&&(r=r.split(" "),f=r[0],v=r[1]),m=0;m<o;m++)0==s?h(f,n,m)?(--m,g(),s=1):"\n"==n.charAt(m)?y(p):d+=n.charAt(m):1==s?(m+=f.length-1,"="==(a=(i=e.tags[n.charAt(m+1)])?n.charAt(m+1):"_v")?(m=x(n,m),s=0):(i&&m++,s=2),p=m):h(v,n,m)?(u.push({tag:a,n:c(d),otag:f,ctag:v,i:"/"==a?p-f.length:m+v.length}),d="",m+=v.length-1,s=0,"{"==a&&("}}"==v?m++:l(u[u.length-1]))):d+=n.charAt(m);return y(p,!0),u};var d={_t:!0,"\n":!0,$:!0,"/":!0};function u(t,n,r,o){var s,a=[],i=null,l=null;for(s=r[r.length-1];t.length>0;){if(l=t.shift(),s&&"<"==s.tag&&!(l.tag in d))throw new Error("Illegal content in < super tag.");if(e.tags[l.tag]<=e.tags.$||p(l,o))r.push(l),l.nodes=u(t,l.tag,r,o);else{if("/"==l.tag){if(0===r.length)throw new Error("Closing tag without opener: /"+l.n);if(i=r.pop(),l.n!=i.n&&!m(l.n,i.n,o))throw new Error("Nesting error: "+i.n+" vs. "+l.n);return i.end=l.i,a}"\n"==l.tag&&(l.last=0==t.length||"\n"==t[0].tag)}a.push(l)}if(r.length>0)throw new Error("missing closing tag: "+r.pop().n);return a}function p(e,t){for(var n=0,r=t.length;n<r;n++)if(t[n].o==e.n)return e.tag="#",!0}function m(e,t,n){for(var r=0,o=n.length;r<o;r++)if(n[r].c==e&&n[r].o==t)return!0}function b(e){var t=[];for(var n in e.partials)t.push('"'+v(n)+'":{name:"'+v(e.partials[n].name)+'", '+b(e.partials[n])+"}");return"partials: {"+t.join(",")+"}, subs: "+function(e){var t=[];for(var n in e)t.push('"'+v(n)+'": function(c,p,t,i) {'+e[n]+"}");return"{ "+t.join(",")+" }"}(e.subs)}e.stringify=function(t,n,r){return"{code: function (c,p,i) { "+e.wrapMain(t.code)+" },"+b(t)+"}"};var f=0;function v(e){return e.replace(s,"\\\\").replace(n,'\\"').replace(r,"\\n").replace(o,"\\r").replace(a,"\\u2028").replace(i,"\\u2029")}function g(e){return~e.indexOf(".")?"d":"f"}function y(e,t){var n="<"+(t.prefix||"")+e.n+f++;return t.partials[n]={name:e.n,partials:{}},t.code+='t.b(t.rp("'+v(n)+'",c,p,"'+(e.indent||"")+'"));',n}function x(e,t){t.code+="t.b(t.t(t."+g(e.n)+'("'+v(e.n)+'",c,p,0)));'}function w(e){return"t.b("+e+");"}e.generate=function(t,n,r){f=0;var o={code:"",subs:{},partials:{}};return e.walk(t,o),r.asString?this.stringify(o,n,r):this.makeTemplate(o,n,r)},e.wrapMain=function(e){return'var t=this;t.b(i=i||"");'+e+"return t.fl();"},e.template=e.Template,e.makeTemplate=function(e,t,n){var r=this.makePartials(e);return r.code=new Function("c","p","i",this.wrapMain(e.code)),new this.template(r,t,this,n)},e.makePartials=function(e){var t,n={subs:{},partials:e.partials,name:e.name};for(t in n.partials)n.partials[t]=this.makePartials(n.partials[t]);for(t in e.subs)n.subs[t]=new Function("c","p","t","i",e.subs[t]);return n},e.codegen={"#":function(t,n){n.code+="if(t.s(t."+g(t.n)+'("'+v(t.n)+'",c,p,1),c,p,0,'+t.i+","+t.end+',"'+t.otag+" "+t.ctag+'")){t.rs(c,p,function(c,p,t){',e.walk(t.nodes,n),n.code+="});c.pop();}"},"^":function(t,n){n.code+="if(!t.s(t."+g(t.n)+'("'+v(t.n)+'",c,p,1),c,p,1,0,0,"")){',e.walk(t.nodes,n),n.code+="};"},">":y,"<":function(t,n){var r={partials:{},code:"",subs:{},inPartial:!0};e.walk(t.nodes,r);var o=n.partials[y(t,n)];o.subs=r.subs,o.partials=r.partials},$:function(t,n){var r={subs:{},code:"",partials:n.partials,prefix:t.n};e.walk(t.nodes,r),n.subs[t.n]=r.code,n.inPartial||(n.code+='t.sub("'+v(t.n)+'",c,p,i);')},"\n":function(e,t){t.code+=w('"\\n"'+(e.last?"":" + i"))},_v:function(e,t){t.code+="t.b(t.v(t."+g(e.n)+'("'+v(e.n)+'",c,p,0)));'},_t:function(e,t){t.code+=w('"'+v(e.text)+'"')},"{":x,"&":x},e.walk=function(t,n){for(var r,o=0,s=t.length;o<s;o++)(r=e.codegen[t[o].tag])&&r(t[o],n);return n},e.parse=function(e,t,n){return u(e,0,[],(n=n||{}).sectionTags||[])},e.cache={},e.cacheKey=function(e,t){return[e,!!t.asString,!!t.disableLambda,t.delimiters,!!t.modelGet].join("||")},e.compile=function(t,n){n=n||{};var r=e.cacheKey(t,n),o=this.cache[r];if(o){var s=o.partials;for(var a in s)delete s[a].instance;return o}return o=this.generate(this.parse(this.scan(t,n.delimiters),t,n),t,n),this.cache[r]=o}}(t)},5485:(e,t,n)=>{var r=n(9397);r.Template=n(2882).Template,r.template=r.Template,e.exports=r},2882:(e,t)=>{!function(e){function t(e,t,n){var r;return t&&"object"==typeof t&&(void 0!==t[e]?r=t[e]:n&&t.get&&"function"==typeof t.get&&(r=t.get(e))),r}e.Template=function(e,t,n,r){e=e||{},this.r=e.code||this.r,this.c=n,this.options=r||{},this.text=t||"",this.partials=e.partials||{},this.subs=e.subs||{},this.buf=""},e.Template.prototype={r:function(e,t,n){return""},v:function(e){return e=l(e),i.test(e)?e.replace(n,"&amp;").replace(r,"&lt;").replace(o,"&gt;").replace(s,"&#39;").replace(a,"&quot;"):e},t:l,render:function(e,t,n){return this.ri([e],t||{},n)},ri:function(e,t,n){return this.r(e,t,n)},ep:function(e,t){var n=this.partials[e],r=t[n.name];if(n.instance&&n.base==r)return n.instance;if("string"==typeof r){if(!this.c)throw new Error("No compiler available.");r=this.c.compile(r,this.options)}if(!r)return null;if(this.partials[e].base=r,n.subs){for(key in t.stackText||(t.stackText={}),n.subs)t.stackText[key]||(t.stackText[key]=void 0!==this.activeSub&&t.stackText[this.activeSub]?t.stackText[this.activeSub]:this.text);r=function(e,t,n,r,o,s){function a(){}function i(){}var l;a.prototype=e,i.prototype=e.subs;var c=new a;for(l in c.subs=new i,c.subsText={},c.buf="",r=r||{},c.stackSubs=r,c.subsText=s,t)r[l]||(r[l]=t[l]);for(l in r)c.subs[l]=r[l];for(l in o=o||{},c.stackPartials=o,n)o[l]||(o[l]=n[l]);for(l in o)c.partials[l]=o[l];return c}(r,n.subs,n.partials,this.stackSubs,this.stackPartials,t.stackText)}return this.partials[e].instance=r,r},rp:function(e,t,n,r){var o=this.ep(e,n);return o?o.ri(t,n,r):""},rs:function(e,t,n){var r=e[e.length-1];if(c(r))for(var o=0;o<r.length;o++)e.push(r[o]),n(e,t,this),e.pop();else n(e,t,this)},s:function(e,t,n,r,o,s,a){var i;return(!c(e)||0!==e.length)&&("function"==typeof e&&(e=this.ms(e,t,n,r,o,s,a)),i=!!e,!r&&i&&t&&t.push("object"==typeof e?e:t[t.length-1]),i)},d:function(e,n,r,o){var s,a=e.split("."),i=this.f(a[0],n,r,o),l=this.options.modelGet,h=null;if("."===e&&c(n[n.length-2]))i=n[n.length-1];else for(var d=1;d<a.length;d++)void 0!==(s=t(a[d],i,l))?(h=i,i=s):i="";return!(o&&!i)&&(o||"function"!=typeof i||(n.push(h),i=this.mv(i,n,r),n.pop()),i)},f:function(e,n,r,o){for(var s=!1,a=!1,i=this.options.modelGet,l=n.length-1;l>=0;l--)if(void 0!==(s=t(e,n[l],i))){a=!0;break}return a?(o||"function"!=typeof s||(s=this.mv(s,n,r)),s):!o&&""},ls:function(e,t,n,r,o){var s=this.options.delimiters;return this.options.delimiters=o,this.b(this.ct(l(e.call(t,r)),t,n)),this.options.delimiters=s,!1},ct:function(e,t,n){if(this.options.disableLambda)throw new Error("Lambda features disabled.");return this.c.compile(e,this.options).render(t,n)},b:function(e){this.buf+=e},fl:function(){var e=this.buf;return this.buf="",e},ms:function(e,t,n,r,o,s,a){var i,l=t[t.length-1],c=e.call(l);return"function"==typeof c?!!r||(i=this.activeSub&&this.subsText&&this.subsText[this.activeSub]?this.subsText[this.activeSub]:this.text,this.ls(c,l,n,i.substring(o,s),a)):c},mv:function(e,t,n){var r=t[t.length-1],o=e.call(r);return"function"==typeof o?this.ct(l(o.call(r)),r,n):o},sub:function(e,t,n,r){var o=this.subs[e];o&&(this.activeSub=e,o(t,n,this,r),this.activeSub=!1)}};var n=/&/g,r=/</g,o=/>/g,s=/\'/g,a=/\"/g,i=/[&<>\"\']/;function l(e){return String(null==e?"":e)}var c=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}}(t)},9606:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n, r);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, rayType);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n, r);\n}\n\nvec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    return render({{name}}, v, rayType);\n}",r);return e.render.apply(e,arguments)}},9909:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return vec3(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist);"),r.b("\n"+n),r.b("    //return debugColor;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v) {\n    return vec3(0, float(v.data.iMarch/camera.maxSteps), v.data.totalDist / camera.maxDist);\n    //return debugColor;\n}",r);return e.render.apply(e,arguments)}},6077:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    return normalMaterialRender(v, normal);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal) {\n    return normalMaterialRender(v, normal);\n}",r);return e.render.apply(e,arguments)}},1202:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RayType "),r.b(r.v(r.f("name",e,t,0))),r.b("_setRayType(ExtVector v, RelVector n,float r) {"),r.b("\n"+n),r.b("    return setRayType("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, n,r);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RayType {{name}}_setRayType(ExtVector v, RelVector n,float r) {\n    return setRayType({{name}}, v, n,r);\n}",r);return e.render.apply(e,arguments)}},2330:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v);\n}",r);return e.render.apply(e,arguments)}},9040:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, normal);\n}",r);return e.render.apply(e,arguments)}},588:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;   "),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n        return {{name}}.specular;   \n    }\n    return {{material.name}}_render(v, normal, uv);\n}",r);return e.render.apply(e,arguments)}},1365:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {"),r.b("\n"+n),r.b("    if (rayType.reflect){"),r.b("\n"+n),r.b("      return "),r.b(r.v(r.f("name",e,t,0))),r.b(".specular;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv, RayType rayType) {\n    if (rayType.reflect){\n      return {{name}}.specular;\n    }\n    return {{material.name}}_render(v, uv);\n}",r);return e.render.apply(e,arguments)}},8149:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,204,519,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return color;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongMaterial material = {{name}};\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return color;\n}",r);return e.render.apply(e,arguments)}},3838:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,257,583,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return color;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v);\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return color;\n}",r);return e.render.apply(e,arguments)}},472:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,265,591,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return color;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal);\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return color;\n}",r);return e.render.apply(e,arguments)}},7660:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,278,604,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n\n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, normal, uv);\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n}",r);return e.render.apply(e,arguments)}},8204:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, RelVector normal, vec2 uv) {"),r.b("\n"+n),r.b("    bool check;"),r.b("\n"+n),r.b("    RelVector dir;"),r.b("\n"+n),r.b("    float intensity;"),r.b("\n"+n),r.b("    int k;"),r.b("\n"+n),r.b(" "),r.b("\n"+n),r.b("    PhongWrapMaterial material = "),r.b(r.v(r.f("name",e,t,0))),r.b(";"),r.b("\n"+n),r.b("    vec3 baseColor = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n),r.b("    vec3 color = vec3(0);"),r.b("\n"),r.b("\n"+n),r.s(r.f("lights",e,t,1),e,t,0,271,597,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        k = "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxDirs;"),r.b("\n"+n),r.b("        for(int j=0; j < k; j++){"),r.b("\n"+n),r.b("            check = "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(v.vector, j, dir, intensity);"),r.b("\n"+n),r.b("            if(check) {"),r.b("\n"+n),r.b("                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, "),r.b(r.v(r.f("name",e,t,0))),r.b(".color, intensity);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return color;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, RelVector normal, vec2 uv) {\n    bool check;\n    RelVector dir;\n    float intensity;\n    int k;\n \n    PhongWrapMaterial material = {{name}};\n    vec3 baseColor = {{material.name}}_render(v, uv);\n    vec3 color = vec3(0);\n\n    {{#lights}}\n        k = {{name}}.maxDirs;\n        for(int j=0; j < k; j++){\n            check = {{name}}_directions(v.vector, j, dir, intensity);\n            if(check) {\n                color = color + lightComputation(v.vector.local, normal.local, dir.local, baseColor, material, {{name}}.color, intensity);\n            }\n        }\n    {{/lights}}\n    \n    return color;\n}",r);return e.render.apply(e,arguments)}},6142:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return negate("),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v));"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the complement of a shape\n */\nRelVector {{name}}_gradient(RelVector v){\n    return negate({{shape.name}}_gradient(v));\n}",r);return e.render.apply(e,arguments)}},7939:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the complement of a shape"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    return - "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the complement of a shape\n */\nfloat {{name}}_sdf(RelVector v){\n    return - {{shape.name}}_sdf(v);\n}",r);return e.render.apply(e,arguments)}},7260:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},6861:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMaxPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMaxPoly(dist1, dist2, grad1, grad2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},3335:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the intersection of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6428:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMaxPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".maxCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMaxPoly(dist1, dist2, {{name}}.maxCoeff);\n}",r);return e.render.apply(e,arguments)}},2076:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return max(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the intersection of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return max(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},2905:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},8655:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    RelVector grad1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    RelVector grad2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    return gradientMinPoly(dist1, dist2, grad1, grad2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    RelVector grad1 = {{shape1.name}}_gradient(v);\n    RelVector grad2 = {{shape2.name}}_gradient(v);\n    return gradientMinPoly(dist1, dist2, grad1, grad2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},7762:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 < dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for the union of two shapes\n */\nRelVector {{name}}_gradient(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 < dist2){\n        return {{shape1.name}}_gradient(v);\n    } else{\n        return {{shape2.name}}_gradient(v);\n    }\n}",r);return e.render.apply(e,arguments)}},3238:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return smoothMinPoly(dist1, dist2, "),r.b(r.v(r.f("name",e,t,0))),r.b(".minCoeff);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return smoothMinPoly(dist1, dist2, {{name}}.minCoeff);\n}",r);return e.render.apply(e,arguments)}},3908:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for the union of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    return min(dist1, dist2);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for the union of two shapes\n */\nfloat {{name}}_sdf(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    return min(dist1, dist2);\n}",r);return e.render.apply(e,arguments)}},7500:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * UV Map for the intersection of two shapes"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    float dist1 = "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    float dist2 = "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(dist1 > dist2){"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape1.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    } else{"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape2.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * UV Map for the intersection of two shapes\n */\nvec2 {{name}}_uvMap(RelVector v){\n    float dist1 = {{shape1.name}}_sdf(v);\n    float dist2 = {{shape2.name}}_sdf(v);\n    if(dist1 > dist2){\n        return {{shape1.name}}_uvMap(v);\n    } else{\n        return {{shape2.name}}_uvMap(v);\n    }\n}",r);return e.render.apply(e,arguments)}},6242:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Gradient for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Gradient for a wrapping\n */\nRelVector {{name}}_gradient(RelVector v){\n    return {{shape.name}}_gradient(v);\n}",r);return e.render.apply(e,arguments)}},3105:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * SDF for a wrapping"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v){"),r.b("\n"+n),r.b("    float wrap = "),r.b(r.v(r.d("wrap.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    if(wrap > camera.threshold){"),r.b("\n"+n),r.b("        return wrap;"),r.b("\n"+n),r.b("    } else {"),r.b("\n"+n),r.b("        return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * SDF for a wrapping\n */\nfloat {{name}}_sdf(RelVector v){\n    float wrap = {{wrap.name}}_sdf(v);\n    if(wrap > camera.threshold){\n        return wrap;\n    } else {\n        return {{shape.name}}_sdf(v);\n    }\n}",r);return e.render.apply(e,arguments)}},9338:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec2 "),r.b(r.v(r.f("name",e,t,0))),r.b("_uvMap(RelVector v){"),r.b("\n"+n),r.b("    return "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"vec2 {{name}}_uvMap(RelVector v){\n    return {{shape.name}}_uvMap(v);\n}",r);return e.render.apply(e,arguments)}},8008:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * Default creeping function (binary search)"),r.b("\n"+n),r.b(" * @param start starting point of the creeping"),r.b("\n"+n),r.b(" * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)"),r.b("\n"+n),r.b(" * @param offset how long we flow after passing the boundary"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(ExtVector v, ExtVector outside,  float offset){"),r.b("\n"+n),r.b("    ExtVector try = outside;"),r.b("\n"+n),r.b("    float sIn = 0.;"),r.b("\n"+n),r.b("    float sOut = try.data.lastFlowDist;"),r.b("\n"+n),r.b("    float s;"),r.b("\n"+n),r.b("    for(int i=0; i < 100; i++){"),r.b("\n"+n),r.b("        if(sOut - sIn < offset){"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("        s = 0.5 * sIn + 0.5 * sOut;"),r.b("\n"+n),r.b("        try = flow(v,s);"),r.b("\n"+n),r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("            sOut = s;"),r.b("\n"+n),r.b("            outside = try;"),r.b("\n"+n),r.b("        } else {"),r.b("\n"+n),r.b("            sIn = s;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    return sOut;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/**\n * Default creeping function (binary search)\n * @param start starting point of the creeping\n * @param outside vector out of the boundary (obtained from the previous flow, or the previous creeping)\n * @param offset how long we flow after passing the boundary\n */\nfloat {{glslCreepName}}(ExtVector v, ExtVector outside,  float offset){\n    ExtVector try = outside;\n    float sIn = 0.;\n    float sOut = try.data.lastFlowDist;\n    float s;\n    for(int i=0; i < 100; i++){\n        if(sOut - sIn < offset){\n            break;\n        }\n        s = 0.5 * sIn + 0.5 * sOut;\n        try = flow(v,s);\n        if({{glslTestName}}(try.vector.local.pos)){\n            sOut = s;\n            outside = try;\n        } else {\n            sIn = s;\n        }\n    }\n    return sOut;\n}",r);return e.render.apply(e,arguments)}},968:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b("* Teleportation."),r.b("\n"+n),r.b("* Check if the local vector is still in the fundamental domain define by the teleportation tests."),r.b("\n"+n),r.b("* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true"),r.b("\n"+n),r.b("* Otherwise, do nothing and set teleported to false"),r.b("\n"+n),r.b("* @param[in] v the relative vector to teleport."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("ExtVector teleport(ExtVector v){"),r.b("\n"+n),r.b("    v.data.isTeleported = false;"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,424,621,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(v.vector.local.pos)){"),r.b("\n"+n),r.b("            v.vector = rewrite(v.vector, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("            v.data.isTeleported = true;"),r.b("\n"+n),r.b("            return v;"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("    return v;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Does one of the two following transformation:"),r.b("\n"+n),r.b("* flow the vector by the given time, if the vector escape the fundamental domain,"),r.b("\n"+n),r.b("* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain"),r.b("\n"+n),r.b("* (and even a bit further)"),r.b("\n"+n),r.b("*"),r.b("\n"+n),r.b("* @param[inout] v the relative vector to flow / teleport / creep."),r.b("\n"+n),r.b("* @param[in] t the (maximal) time to flow"),r.b("\n"+n),r.b("* @param[in] offset the amount we march passed the boundary"),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float creepingDist(ExtVector v, float t, float offset){"),r.b("\n"+n),r.b("    float res = t;"),r.b("\n"+n),r.b("    ExtVector try = flow(v, t);"),r.b("\n"+n),r.s(r.f("teleportations",e,t,1),e,t,0,1233,1638,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("\n"+n),r.s(r.f("usesCreepingCustom",e,t,1),e,t,0,1266,1407,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.f("usesCreepingBinary",e,t,1),e,t,0,1463,1609,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("glslTestName",e,t,0))),r.b("(try.vector.local.pos)){"),r.b("\n"+n),r.b("                res = min(res, "),r.b(r.v(r.f("glslCreepName",e,t,0))),r.b("(v, try, offset));"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop()),r.b("\n"+n)})),e.pop()),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.fl()},partials:{},subs:{}},"/**\n* Teleportation.\n* Check if the local vector is still in the fundamental domain define by the teleportation tests.\n* If not, teleport the local vector, update the cellBoost and its inverse accordingly and set teleported to true\n* Otherwise, do nothing and set teleported to false\n* @param[in] v the relative vector to teleport.\n*/\nExtVector teleport(ExtVector v){\n    v.data.isTeleported = false;\n    {{#teleportations}}\n        if({{glslTestName}}(v.vector.local.pos)){\n            v.vector = rewrite(v.vector, {{elt.name}}, {{inv.name}});\n            v.data.isTeleported = true;\n            return v;\n        }\n    {{/teleportations}}\n    return v;\n}\n\n\n/**\n* Does one of the two following transformation:\n* flow the vector by the given time, if the vector escape the fundamental domain,\n* then try to find a smaller time so that the vector is moved closer to the boundary of the fudamental domain\n* (and even a bit further)\n*\n* @param[inout] v the relative vector to flow / teleport / creep.\n* @param[in] t the (maximal) time to flow\n* @param[in] offset the amount we march passed the boundary\n*/\nfloat creepingDist(ExtVector v, float t, float offset){\n    float res = t;\n    ExtVector try = flow(v, t);\n    {{#teleportations}}\n\n        {{#usesCreepingCustom}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, offset));\n            }\n        {{/usesCreepingCustom}}\n\n        {{#usesCreepingBinary}}\n            if({{glslTestName}}(try.vector.local.pos)){\n                res = min(res, {{glslCreepName}}(v, try, offset));\n            }\n        {{/usesCreepingBinary}}\n\n    {{/teleportations}}\n    return res;\n}\n\n\n",r);return e.render.apply(e,arguments)}},7577:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("bool "),r.b(r.v(r.f("name",e,t,0))),r.b("_directions(RelVector v, int i, out RelVector dir, out float intensity) {"),r.b("\n"+n),r.b("    return directions("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, i, dir, intensity);"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"bool {{name}}_directions(RelVector v, int i, out RelVector dir, out float intensity) {\n    return directions({{name}}, v, i, dir, intensity);\n}",r);return e.render.apply(e,arguments)}},8778:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v) {\n    return render({{name}}, v);\n}\n",r);return e.render.apply(e,arguments)}},1215:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("vec3 "),r.b(r.v(r.f("name",e,t,0))),r.b("_render(ExtVector v, vec2 uv) {"),r.b("\n"+n),r.b("    return render("),r.b(r.v(r.f("name",e,t,0))),r.b(", v, uv);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"vec3 {{name}}_render(ExtVector v, vec2 uv) {\n    return render({{name}}, v, uv);\n}\n",r);return e.render.apply(e,arguments)}},2044:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1376,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1359,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representatiion of v can be updated "),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2144,2560,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2207,2508,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3118,3472,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3140,3454,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representatiion of v can be updated \n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(dist < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},7781:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1));"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec3 color;"),r.b("\n"+n),r.b("    vec3 reflectivity;"),r.b("\n"+n),r.b("    float t;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,300,3705,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("    "),r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,0,361,2329,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            "),r.b("\n"+n),r.b("            if(v.data.iBounce == maxBounces){"),r.b("\n"+n),r.b("                reflectivity = vec3(0);"),r.b("\n"+n),r.b("            } "),r.b("\n"+n),r.b("            else {"),r.b("\n"+n),r.b("                reflectivity = "),r.b(r.v(r.d("material.name",e,t,0))),r.b(".reflectivity;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            "),r.b("\n"+n),r.b("            normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("            // in general the gradient is not necessarily a unit vector"),r.b("\n"+n),r.b("            normal = geomNormalize(normal);"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,976,1111,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,1213,1577,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,1398,1541,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,1629,1706,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.b("            if(length(reflectivity) == 0.) {"),r.b("\n"+n),r.b("                v.data.stop = true;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            else{"),r.b("\n"+n),r.b("                v.data.stop = false;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec3(1) - reflectivity) * color;"),r.b("\n"+n),r.b("            v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;"),r.b("\n"+n),r.b("            v.vector = geomReflect(v.vector,normal);"),r.b("\n"+n),r.b("            v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("            v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("            t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("            v = flow(v, t);"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    "),r.b("\n"+n),r.s(r.d("material.isReflecting",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesNormal",e,t,1),e,t,1,0,0,"")||(r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    color =  "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,2610,2745,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, uv);"),r.b("\n"+n)})),e.pop())),r.b("    "),r.b("\n"+n),r.s(r.d("material.usesNormal",e,t,1),e,t,0,2847,3339,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.d("material.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal);"),r.b("\n"+n)),r.s(r.d("material.usesUVMap",e,t,1),e,t,0,3096,3303,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                    normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("                    uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                    color = "),r.b(r.v(r.d("material.name",e,t,0))),r.b("_render(v, normal, uv);"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("\n"+n),r.s(r.d("scene.fog",e,t,1),e,t,0,3391,3468,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                color = applyFog(color, v.data.lastBounceDist);"),r.b("\n"+n)})),e.pop()),r.b("            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("            v.data.leftToComputeColor = vec3(0);"),r.b("\n"+n),r.b("            v.data.stop = true;"),r.b("\n"+n)),r.b("    "),r.b("\n"+n),r.b("        break;"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec3(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec3 color = "),r.b(r.v(r.d("scene.background.name",e,t,0))),r.b("_render(v);"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;"),r.b("\n"+n),r.b("        v.data.leftToComputeColor = vec3(0);"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1));\n}\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    vec2 uv;\n    vec3 color;\n    vec3 reflectivity;\n    float t;\n    \n    switch(objId){\n    {{#scene.solids}}\n    \n        case {{id}}:\n        {{#material.isReflecting}}\n            \n            if(v.data.iBounce == maxBounces){\n                reflectivity = vec3(0);\n            } \n            else {\n                reflectivity = {{material.name}}.reflectivity;\n            }\n            \n            normal = {{shape.name}}_gradient(v.vector);\n            // in general the gradient is not necessarily a unit vector\n            normal = geomNormalize(normal);\n    \n            {{^material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color =  {{material.name}}_render(v);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n    \n            {{#material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color = {{material.name}}_render(v, normal);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, normal, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            {{#scene.fog}}\n                color = applyFog(color, v.data.lastBounceDist);\n            {{/scene.fog}}\n\n            if(length(reflectivity) == 0.) {\n                v.data.stop = true;\n            }\n            else{\n                v.data.stop = false;\n            }\n            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * (vec3(1) - reflectivity) * color;\n            v.data.leftToComputeColor = v.data.leftToComputeColor *  reflectivity;\n            v.vector = geomReflect(v.vector,normal);\n            v.data.lastBounceDist = 0.;\n            v.data.iBounce = v.data.iBounce + 1;\n            t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n            v = flow(v, t);\n    \n        {{/material.isReflecting}}\n    \n        {{^material.isReflecting}}\n            {{^material.usesNormal}}\n                {{^material.usesUVMap}}\n                    color =  {{material.name}}_render(v);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n    \n            {{#material.usesNormal}}\n                {{^material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    color = {{material.name}}_render(v, normal);\n                {{/material.usesUVMap}}\n                {{#material.usesUVMap}}\n                    normal = {{shape.name}}_gradient(v.vector);\n                    uv = {{shape.name}}_uvMap(v.vector);\n                    color = {{material.name}}_render(v, normal, uv);\n                {{/material.usesUVMap}}\n            {{/material.usesNormal}}\n\n            {{#scene.fog}}\n                color = applyFog(color, v.data.lastBounceDist);\n            {{/scene.fog}}\n            v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n            v.data.leftToComputeColor = vec3(0);\n            v.data.stop = true;\n        {{/material.isReflecting}}\n    \n        break;\n    \n    {{/scene.solids}}\n    }\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor;\n        v.data.leftToComputeColor = vec3(0);\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec3 color = {{scene.background.name}}_render(v);\n        v.data.pixel = v.data.pixel + v.data.leftToComputeColor * color;\n        v.data.leftToComputeColor = vec3(0);\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},4122:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/**"),r.b("\n"+n),r.b(" * We assume that we are inside a solid"),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("void nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    ior = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.ior; // index of the "air"'),r.b("\n"+n),r.b("    absorb = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.absorb; // absorb of the "air"'),r.b("\n"+n),r.b("    emission=vec3(0,0,0);//no emission from 'air'"),r.b("\n"+n),r.b("    opticalDepth="),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b('.opticalDepth; // opticalDepth of the "air"'),r.b("\n"+n),r.b("    isInside = false;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    RelVector v = flow(normal, 2. * camera.threshold);"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,579,1010,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("            dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("            if(dist < camera.threshold) {"),r.b("\n"+n),r.b("                ior = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("                absorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("                emission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("                opticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("                isInside = true;"),r.b("\n"+n),r.b("                return;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        }"),r.b("\n"+n)})),e.pop()),r.b("}"),r.fl()},partials:{},subs:{}},'/**\n * We assume that we are inside a solid\n */\nvoid nextObjectProperties(RelVector normal, out float ior, out vec3 absorb,out vec3 emission,out float opticalDepth, out bool isInside){\n    float dist;\n    ior = {{scene.ptBackground.name}}.ior; // index of the "air"\n    absorb = {{scene.ptBackground.name}}.absorb; // absorb of the "air"\n    emission=vec3(0,0,0);//no emission from \'air\'\n    opticalDepth={{scene.ptBackground.name}}.opticalDepth; // opticalDepth of the "air"\n    isInside = false;\n    \n    RelVector v = flow(normal, 2. * camera.threshold);\n    {{#scene.solids}}\n        if({{name}}.isRendered){\n            dist = {{shape.name}}_sdf(v);\n            if(dist < camera.threshold) {\n                ior = {{ptMaterial.name}}.ior;\n                absorb = {{ptMaterial.name}}.absorb;\n                emission = {{ptMaterial.name}}.volumeEmission;\n                opticalDepth = {{ptMaterial.name}}.opticalDepth;\n                isInside = true;\n                return;\n            }\n        }\n    {{/scene.solids}}\n}',r);return e.render.apply(e,arguments)}},6172:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("/***********************************************************************************************************************"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" * "),r.b("\n"+n),r.b(" * Defines the scene SDF and scene Material computations used during the ray-marching and lightening."),r.b("\n"+n),r.b(" *"),r.b("\n"+n),r.b(" ***********************************************************************************************************************"),r.b("\n"+n),r.b(" **********************************************************************************************************************/"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float _localSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,1024,1381,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isLocal",e,t,1),e,t,0,1045,1364,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b("* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene"),r.b("\n"+n),r.b("* When nearest neighbor is on, the representatiion of v can be updated "),r.b("\n"+n),r.b("* so that the local vector is in a neighbor of the fundamental domain."),r.b("\n"+n),r.b("* This is used to compute correctly the normal / uv map of a local object."),r.b("\n"+n),r.b("* @param[in] v the direction to follows"),r.b("\n"+n),r.b("* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b("* @param[out] objId the ID of the solid we hit."),r.b("\n"+n),r.b("*/"),r.b("\n"+n),r.b("float localSceneSDF(inout RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    float res, dist;"),r.b("\n"+n),r.b("    dist = _localSceneSDF(v, hit, objId);"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        return dist;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    res = dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,0,2149,2565,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("        RelVector aux = v;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("set.neighbors",e,t,1),e,t,0,2212,2513,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                aux = rewrite(v, "),r.b(r.v(r.d("elt.name",e,t,0))),r.b(", "),r.b(r.v(r.d("inv.name",e,t,0))),r.b(");"),r.b("\n"+n),r.b("                dist = _localSceneSDF(aux, hit, objId);"),r.b("\n"+n),r.b("                if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("                    v = aux;"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("                "),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        return res;"),r.b("\n"+n)})),e.pop()),r.b("\n"+n),r.s(r.d("set.usesNearestNeighbors",e,t,1),e,t,1,0,0,"")||(r.b("        return res;"),r.b("\n"+n)),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("/**"),r.b("\n"+n),r.b(" * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene"),r.b("\n"+n),r.b(" * @param[in] v the direction to follows"),r.b("\n"+n),r.b(" * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)"),r.b("\n"+n),r.b(" * @param[out] objID the ID of the solid we hit."),r.b("\n"+n),r.b(" */"),r.b("\n"+n),r.b("float globalSceneSDF(RelVector v, out int hit, out int objId){"),r.b("\n"+n),r.b("    hit = HIT_NOTHING;"),r.b("\n"+n),r.b("    float res = camera.maxDist;"),r.b("\n"+n),r.b("    float dist;"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,3123,3482,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.s(r.f("isGlobal",e,t,1),e,t,0,3145,3464,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("            if("),r.b(r.v(r.f("name",e,t,0))),r.b(".isRendered){"),r.b("\n"+n),r.b("                dist = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_sdf(v);"),r.b("\n"+n),r.b("                if(abs(dist) < camera.threshold) {"),r.b("\n"+n),r.b("                    hit = HIT_SOLID;"),r.b("\n"+n),r.b("                    objId = "),r.b(r.v(r.f("id",e,t,0))),r.b(";"),r.b("\n"+n),r.b("                    return dist;"),r.b("\n"+n),r.b("                }"),r.b("\n"+n),r.b("                res = min(res, dist);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n)})),e.pop())})),e.pop()),r.b("    "),r.b("\n"+n),r.b("    return res;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"/***********************************************************************************************************************\n ***********************************************************************************************************************\n * \n * Defines the scene SDF and scene Material computations used during the ray-marching and lightening.\n *\n ***********************************************************************************************************************\n **********************************************************************************************************************/\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objId the ID of the solid we hit.\n */\nfloat _localSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n\n    {{#scene.solids}}\n        {{#isLocal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isLocal}}\n    {{/scene.solids}}\n    \n    return res;\n}\n\n/**\n* Distance along the geodesic directed by \\`v\\` to the closest object in the local scene\n* When nearest neighbor is on, the representatiion of v can be updated \n* so that the local vector is in a neighbor of the fundamental domain.\n* This is used to compute correctly the normal / uv map of a local object.\n* @param[in] v the direction to follows\n* @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n* @param[out] objId the ID of the solid we hit.\n*/\nfloat localSceneSDF(inout RelVector v, out int hit, out int objId){\n    float res, dist;\n    dist = _localSceneSDF(v, hit, objId);\n    if(hit == HIT_SOLID) {\n        return dist;\n    }\n    res = dist;\n    \n    {{#set.usesNearestNeighbors}}\n        RelVector aux = v;\n        \n        {{#set.neighbors}}\n                aux = rewrite(v, {{elt.name}}, {{inv.name}});\n                dist = _localSceneSDF(aux, hit, objId);\n                if(hit == HIT_SOLID) {\n                    v = aux;\n                    return dist;\n                }\n                res = min(res, dist);\n                \n        {{/set.neighbors}}\n        \n        return res;\n    {{/set.usesNearestNeighbors}}\n\n    {{^set.usesNearestNeighbors}}\n        return res;\n    {{/set.usesNearestNeighbors}}\n}\n\n\n/**\n * Distance along the geodesic directed by \\`v\\` to the closest object in the global scene\n * @param[in] v the direction to follows\n * @param[out] hit say if we hit an object (1), nothing (0) or if there is a bug (-1)\n * @param[out] objID the ID of the solid we hit.\n */\nfloat globalSceneSDF(RelVector v, out int hit, out int objId){\n    hit = HIT_NOTHING;\n    float res = camera.maxDist;\n    float dist;\n    \n    {{#scene.solids}}\n        {{#isGlobal}}\n            if({{name}}.isRendered){\n                dist = {{shape.name}}_sdf(v);\n                if(abs(dist) < camera.threshold) {\n                    hit = HIT_SOLID;\n                    objId = {{id}};\n                    return dist;\n                }\n                res = min(res, dist);\n            }\n        {{/isGlobal}}\n    {{/scene.solids}}\n    \n    return res;\n}",r);return e.render.apply(e,arguments)}},6272:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("VectorData initVectorData(){"),r.b("\n"+n),r.b("    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".absorb, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".volumeEmission, "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".opticalDepth, false);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void roulette(inout ExtVector v){"),r.b("\n"+n),r.b("    // as the light left gets smaller, the ray is more likely to get terminated early."),r.b("\n"+n),r.b("    // survivors have their value boosted to make up for fewer samples being in the average."),r.b("\n"+n),r.b("    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));"),r.b("\n"+n),r.b("    if (randomFloat() > p){"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    // add the energy we 'lose' by randomly terminating paths"),r.b("\n"+n),r.b("    v.data.light = v.data.light / p;"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorDataFromSolid(inout ExtVector v, int objId){"),r.b("\n"+n),r.b("    RelVector normal;"),r.b("\n"+n),r.b("    RayType rayType;"),r.b("\n"+n),r.b("    vec2 uv;"),r.b("\n"+n),r.b("    vec3 color;"),r.b("\n"+n),r.b("    vec3 reflectivity;"),r.b("\n"+n),r.b("    float hackCoeff = 1.;"),r.b("\n"+n),r.b("    float r; /** ratio of IOR */"),r.b("\n"+n),r.b("    float nextIOR; /** IOR of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextAbsorb; /** absorb of the neighbor solid */"),r.b("\n"+n),r.b("    vec3 nextEmission;/** volumetric emission of the neighbor solid */"),r.b("\n"+n),r.b("    float nextOpticalDepth;/** optical depth of the neighbor solid */"),r.b("\n"+n),r.b("    bool nextIsInside = true;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector diffuseDir;"),r.b("\n"+n),r.b("    RelVector reflectDir;"),r.b("\n"+n),r.b("    RelVector refractDir;"),r.b("\n"),r.b("\n"+n),r.b("    // get a uniformly distributed vector on the sphere"),r.b("\n"+n),r.b("    RelVector random = randomVector(v.vector);"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("    //get volumetric coloring:"),r.b("\n"+n),r.b("    //portion of light is absorbed."),r.b("\n"+n),r.b("    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);"),r.b("\n"+n),r.b("    "),r.b("\n"+n),r.b("    //light is emitted along the journey (linear or expoenential pickup)"),r.b("\n"+n),r.b("    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;"),r.b("\n"+n),r.b("    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);"),r.b("\n"),r.b("\n"+n),r.b("    //use these quantities to update pixel and light:"),r.b("\n"+n),r.b("    v.data.light = v.data.light * volAbsorb;"),r.b("\n"+n),r.b("    v.data.pixel = v.data.pixel + v.data.light*volEmit;"),r.b("\n"+n),r.b("    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output"),r.b("\n"+n),r.b("    "),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"),r.b("\n"+n),r.b("switch(objId){"),r.b("\n"+n),r.s(r.d("scene.solids",e,t,1),e,t,0,2036,5260,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("    "),r.b("\n"+n),r.b("        case "),r.b(r.v(r.f("id",e,t,0))),r.b(":"),r.b("\n"+n),r.b("            normal = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_gradient(v.vector);"),r.b("\n"+n),r.b("            normal = geomNormalize(normal);"),r.b("\n"),r.b("\n"+n),r.b("            "),r.b("\n"+n),r.b("            // get info and reset normal based on which side we are on."),r.b("\n"+n),r.b('            // starting assumption: in the "air"'),r.b("\n"+n),r.b("            r = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".ior / "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior;"),r.b("\n"+n),r.b("            nextAbsorb = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".absorb;"),r.b("\n"+n),r.b("            nextEmission = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".volumeEmission;"),r.b("\n"+n),r.b("            nextOpticalDepth = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".opticalDepth;"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(v.data.isInside){"),r.b("\n"+n),r.b("                //things to change if we are inside a material instead:"),r.b("\n"+n),r.b("                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);"),r.b("\n"+n),r.b("                r = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".ior / nextIOR;"),r.b("\n"+n),r.b("                normal = negate(normal);"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            rayType = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_setRayType(v, normal,r);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,1,0,0,"")||(r.b("                color =  "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, rayType);"),r.b("\n"+n)),r.s(r.d("ptMaterial.usesUVMap",e,t,1),e,t,0,3160,3302,"{{ }}")&&(r.rs(e,t,(function(e,t,r){r.b("                uv = "),r.b(r.v(r.d("shape.name",e,t,0))),r.b("_uvMap(v.vector);"),r.b("\n"+n),r.b("                color = "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b("_render(v, normal, uv, rayType);"),r.b("\n"+n)})),e.pop()),r.b("        "),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("        // hack to make sure that lights are not too bright"),r.b("\n"+n),r.b("            if(v.data.iBounce == 0){"),r.b("\n"+n),r.b("                hackCoeff = 0.2;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            //apply surface effects"),r.b("\n"+n),r.b("            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".emission;"),r.b("\n"+n),r.b("            if(!rayType.refract){"),r.b("\n"+n),r.b("                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);"),r.b("\n"+n),r.b("             }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            // update the ray direction"),r.b("\n"+n),r.b("            // diffuse uses a normal oriented cosine weighted hemisphere sample."),r.b("\n"+n),r.b("            diffuseDir = geomNormalize(add(normal, random));"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.diffuse){"),r.b("\n"+n),r.b("                v.vector = diffuseDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.reflect){"),r.b("\n"+n),r.b("                // perfectly smooth specular uses the reflection ray."),r.b("\n"+n),r.b("                reflectDir = geomReflect(v.vector, normal);"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                v.vector = reflectDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("        "),r.b("\n"+n),r.b("            if(rayType.refract){"),r.b("\n"+n),r.b("                    refractDir = geomRefract(v.vector,normal, r);"),r.b("\n"+n),r.b("                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared"),r.b("\n"+n),r.b("                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness * "),r.b(r.v(r.d("ptMaterial.name",e,t,0))),r.b(".roughness));"),r.b("\n"+n),r.b("                    v.data.isInside = nextIsInside;"),r.b("\n"+n),r.b("                    v.data.currentAbsorb = nextAbsorb;"),r.b("\n"+n),r.b("                    v.data.currentEmission = nextEmission;"),r.b("\n"+n),r.b("                    v.data.currentOpticalDepth = nextOpticalDepth;"),r.b("\n"+n),r.b("                    v.vector = refractDir;"),r.b("\n"+n),r.b("            }"),r.b("\n"+n),r.b("            break;"),r.b("\n"+n),r.b("    "),r.b("\n"+n)})),e.pop()),r.b("    }"),r.b("\n"),r.b("\n"+n),r.b("    v.data.lastBounceDist = 0.;"),r.b("\n"+n),r.b("    v.data.iBounce = v.data.iBounce + 1;"),r.b("\n"+n),r.b("    // be carefull, v is not normal to the surface"),r.b("\n"+n),r.b("    // if the time we flow is too small, we are still below the camera threshold"),r.b("\n"+n),r.b("    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));"),r.b("\n"+n),r.b("    v = flow(v, t);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.b("\n"+n),r.b("void updateVectorData(inout ExtVector v, int hit, int objId){"),r.b("\n"+n),r.b("    if (hit == HIT_DEBUG) {"),r.b("\n"+n),r.b("        v.data.pixel = debugColor;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if (hit == HIT_NOTHING) {"),r.b("\n"+n),r.b("        vec3 bgColor = "),r.b(r.v(r.d("scene.ptBackground.name",e,t,0))),r.b(".diffuse;"),r.b("\n"+n),r.b("        v.data.pixel = v.data.pixel + v.data.light * bgColor;"),r.b("\n"+n),r.b("        v.data.stop = true;"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("    if(hit == HIT_SOLID) {"),r.b("\n"+n),r.b("        updateVectorDataFromSolid(v, objId);"),r.b("\n"+n),r.b("        roulette(v);"),r.b("\n"+n),r.b("        return;"),r.b("\n"+n),r.b("    }"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"VectorData initVectorData(){\n    return VectorData(0., 0., 0., false, 0, 0, false, vec3(0), vec3(1), {{scene.ptBackground.name}}.absorb, {{scene.ptBackground.name}}.volumeEmission, {{scene.ptBackground.name}}.opticalDepth, false);\n}\n\n\n\nvoid roulette(inout ExtVector v){\n    // as the light left gets smaller, the ray is more likely to get terminated early.\n    // survivors have their value boosted to make up for fewer samples being in the average.\n    float p = max(v.data.light.r, max(v.data.light.g, v.data.light.b));\n    if (randomFloat() > p){\n        v.data.stop = true;\n    }\n    // add the energy we 'lose' by randomly terminating paths\n    v.data.light = v.data.light / p;\n}\n\n\n\nvoid updateVectorDataFromSolid(inout ExtVector v, int objId){\n    RelVector normal;\n    RayType rayType;\n    vec2 uv;\n    vec3 color;\n    vec3 reflectivity;\n    float hackCoeff = 1.;\n    float r; /** ratio of IOR */\n    float nextIOR; /** IOR of the neighbor solid */\n    vec3 nextAbsorb; /** absorb of the neighbor solid */\n    vec3 nextEmission;/** volumetric emission of the neighbor solid */\n    float nextOpticalDepth;/** optical depth of the neighbor solid */\n    bool nextIsInside = true;\n\n    RelVector diffuseDir;\n    RelVector reflectDir;\n    RelVector refractDir;\n\n    // get a uniformly distributed vector on the sphere\n    RelVector random = randomVector(v.vector);\n\n\n\n\n\n    //get volumetric coloring:\n    //portion of light is absorbed.\n    vec3 volAbsorb = exp((-v.data.currentAbsorb) * v.data.lastBounceDist);\n    \n    //light is emitted along the journey (linear or expoenential pickup)\n    vec3 volEmit = v.data.currentEmission * v.data.lastBounceDist;\n    //vec3 volEmit = exp(v.data.currentEmission * v.data.lastBounceDist)-vec3(1);\n\n    //use these quantities to update pixel and light:\n    v.data.light = v.data.light * volAbsorb;\n    v.data.pixel = v.data.pixel + v.data.light*volEmit;\n    v.data.light = v.data.light + volEmit;//the absorbtion doesn't distort the light output\n    \n\n\n\n\n\n\nswitch(objId){\n    {{#scene.solids}}\n    \n        case {{id}}:\n            normal = {{shape.name}}_gradient(v.vector);\n            normal = geomNormalize(normal);\n\n            \n            // get info and reset normal based on which side we are on.\n            // starting assumption: in the \"air\"\n            r = {{scene.ptBackground.name}}.ior / {{ptMaterial.name}}.ior;\n            nextAbsorb = {{ptMaterial.name}}.absorb;\n            nextEmission = {{ptMaterial.name}}.volumeEmission;\n            nextOpticalDepth = {{ptMaterial.name}}.opticalDepth;\n        \n            if(v.data.isInside){\n                //things to change if we are inside a material instead:\n                nextObjectProperties(normal, nextIOR, nextAbsorb,nextEmission, nextOpticalDepth,nextIsInside);\n                r = {{ptMaterial.name}}.ior / nextIOR;\n                normal = negate(normal);\n            }\n        \n            rayType = {{ptMaterial.name}}_setRayType(v, normal,r);\n        \n            {{^ptMaterial.usesUVMap}}\n                color =  {{ptMaterial.name}}_render(v, normal, rayType);\n            {{/ptMaterial.usesUVMap}}\n            {{#ptMaterial.usesUVMap}}\n                uv = {{shape.name}}_uvMap(v.vector);\n                color = {{ptMaterial.name}}_render(v, normal, uv, rayType);\n            {{/ptMaterial.usesUVMap}}\n        \n        \n        // hack to make sure that lights are not too bright\n            if(v.data.iBounce == 0){\n                hackCoeff = 0.2;\n            }\n        \n            //apply surface effects\n            v.data.pixel = v.data.pixel + hackCoeff * v.data.light * {{ptMaterial.name}}.emission;\n            if(!rayType.refract){\n                v.data.light = v.data.light * color / max(rayType.chance, 0.0001);\n             }\n        \n            // update the ray direction\n            // diffuse uses a normal oriented cosine weighted hemisphere sample.\n            diffuseDir = geomNormalize(add(normal, random));\n        \n            if(rayType.diffuse){\n                v.vector = diffuseDir;\n            }\n        \n            if(rayType.reflect){\n                // perfectly smooth specular uses the reflection ray.\n                reflectDir = geomReflect(v.vector, normal);\n        \n                // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n               // reflectDir = geomNormalize(geomMix(reflectDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                v.vector = reflectDir;\n            }\n        \n            if(rayType.refract){\n                    refractDir = geomRefract(v.vector,normal, r);\n                    // rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n                    refractDir = geomNormalize(geomMix(refractDir, diffuseDir, {{ptMaterial.name}}.roughness * {{ptMaterial.name}}.roughness));\n                    v.data.isInside = nextIsInside;\n                    v.data.currentAbsorb = nextAbsorb;\n                    v.data.currentEmission = nextEmission;\n                    v.data.currentOpticalDepth = nextOpticalDepth;\n                    v.vector = refractDir;\n            }\n            break;\n    \n    {{/scene.solids}}\n    }\n\n    v.data.lastBounceDist = 0.;\n    v.data.iBounce = v.data.iBounce + 1;\n    // be carefull, v is not normal to the surface\n    // if the time we flow is too small, we are still below the camera threshold\n    float t = 20. * camera.threshold / abs(geomDot(v.vector, normal));\n    v = flow(v, t);\n}\n\nvoid updateVectorData(inout ExtVector v, int hit, int objId){\n    if (hit == HIT_DEBUG) {\n        v.data.pixel = debugColor;\n        v.data.stop = true;\n        return;\n    }\n    if (hit == HIT_NOTHING) {\n        vec3 bgColor = {{scene.ptBackground.name}}.diffuse;\n        v.data.pixel = v.data.pixel + v.data.light * bgColor;\n        v.data.stop = true;\n        return;\n    }\n    if(hit == HIT_SOLID) {\n        updateVectorDataFromSolid(v, objId);\n        roulette(v);\n        return;\n    }\n}",r);return e.render.apply(e,arguments)}},5030:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    return gradient("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    return gradient({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},8266:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("RelVector "),r.b(r.v(r.f("name",e,t,0))),r.b("_gradient(RelVector v){"),r.b("\n"+n),r.b("    float newEp = 0.001;"),r.b("\n"),r.b("\n"+n),r.b("    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));"),r.b("\n"+n),r.b("    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));"),r.b("\n"+n),r.b("    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));"),r.b("\n"+n),r.b("    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));"),r.b("\n"),r.b("\n"+n),r.b("    float vgx = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPX) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMX);"),r.b("\n"+n),r.b("    float vgy = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPY) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMY);"),r.b("\n"+n),r.b("    float vgz = "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftPZ) - "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(shiftMZ);"),r.b("\n"+n),r.b("    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));"),r.b("\n"),r.b("\n"+n),r.b("    n = geomNormalize(n);"),r.b("\n"+n),r.b("    return n;"),r.b("\n"+n),r.b("}"),r.fl()},partials:{},subs:{}},"RelVector {{name}}_gradient(RelVector v){\n    float newEp = 0.001;\n\n    RelVector shiftPX = smallShift(v, vec3(newEp, 0, 0));\n    RelVector shiftPY = smallShift(v, vec3(0, newEp, 0));\n    RelVector shiftPZ = smallShift(v, vec3(0, 0, newEp));\n    RelVector shiftMX = smallShift(v, vec3(-newEp, 0, 0));\n    RelVector shiftMY = smallShift(v, vec3(0, -newEp, 0));\n    RelVector shiftMZ = smallShift(v, vec3(0, 0, -newEp));\n\n    float vgx = {{name}}_sdf(shiftPX) - {{name}}_sdf(shiftMX);\n    float vgy = {{name}}_sdf(shiftPY) - {{name}}_sdf(shiftMY);\n    float vgz = {{name}}_sdf(shiftPZ) - {{name}}_sdf(shiftMZ);\n    RelVector n = createRelVector(v, vec3(vgx, vgy, vgz));\n\n    n = geomNormalize(n);\n    return n;\n}",r);return e.render.apply(e,arguments)}},3707:(e,t,n)=>{var r=n(5485);e.exports=function(){var e=new r.Template({code:function(e,t,n){var r=this;return r.b(n=n||""),r.b("float "),r.b(r.v(r.f("name",e,t,0))),r.b("_sdf(RelVector v) {"),r.b("\n"+n),r.b("    return sdf("),r.b(r.v(r.f("name",e,t,0))),r.b(",v);"),r.b("\n"+n),r.b("}"),r.b("\n"),r.fl()},partials:{},subs:{}},"float {{name}}_sdf(RelVector v) {\n    return sdf({{name}},v);\n}\n",r);return e.render.apply(e,arguments)}},6097:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                                    \n                                                                                                                        \n\nstruct GroupElement {\n    Isometry isom;                                 \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(IDENTITY);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(multiply(elt1.isom, elt2.isom));\n}\n\n                                              \n                                                 \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return elt.isom;\n}"},9188:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                     \n  \n                                                                                                                        \n                                                                                                                        \n\n                                                                                                                        \n          \n                               \n                                                                                                                        \n\nstruct GroupElement {\n    bool fake;                                                           \n};\n\nconst GroupElement GROUP_IDENTITY = GroupElement(true);\n\nGroupElement multiply(GroupElement elt1, GroupElement elt2){\n    return GroupElement(true);\n}\n\n                                              \n                                \n   \n\nIsometry toIsometry(GroupElement elt) {\n    return IDENTITY;\n}"},5363:e=>{e.exports="   \n                                                                \n   \nfloat fresnelReflectAmount(RelVector incident, RelVector normal, float r, float reflecAt0, float relfectAt90) {\n                           \n    float r0 = (r - 1.) / (r + 1.);\n    r0 = r0 * r0;\n    float cosX = -geomDot(normal, incident);\n    if (r > 1.)\n    {\n        float sinT2 = r * r * (1. - cosX * cosX);\n                                    \n        if (sinT2 > 1.){\n            return relfectAt90;\n        }\n        cosX = sqrt(1. - sinT2);\n    }\n    float x = 1.- cosX;\n    float ret = clamp(r0 + (1. - r0) * x * x * x * x * x, 0., 1.);\n\n                                                        \n                               \n    return reflecAt0 + (relfectAt90 - reflecAt0) * ret;\n}"},2093:e=>{e.exports="   \n                                  \n   \nfloat smoothMaxPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return max(a, b) + 0.25 * k * h * h;\n}\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMaxPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n    return add(multiplyScalar(1. - 0.5 * h, gradMax), multiplyScalar(0.5 * h, gradMin));\n}\n"},5442:e=>{e.exports="float smoothMinPoly(float a, float b, float k){\n    float h = max(1. - abs(a - b) / k, 0.);\n    return min(a, b) - 0.25 * k * h * h;\n}\n\n\n   \n                                                                                 \n                                                 \n                                                   \n                                                   \n                                                    \n   \nRelVector gradientMinPoly(float dist1, float dist2, RelVector grad1, RelVector grad2, float k){\n    RelVector gradMin, gradMax;\n    if (dist1 < dist2) {\n        gradMin = grad1;\n        gradMax = grad2;\n    }\n    else {\n        gradMin = grad2;\n        gradMax = grad1;\n    }\n    float h = max(1. - abs(dist1 - dist2) / k, 0.);\n\n    return add(multiplyScalar(1. - 0.5 * h, gradMin), multiplyScalar(0.5 * h, gradMax));\n}\n"},2143:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct BasicPTMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(BasicPTMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n                                                         \n                                  \n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\nvec3 render(BasicPTMaterial material, ExtVector v, RayType rayType) {\n    if (rayType.reflect){\n        return material.specular;\n    }\n                               \n                                              \n                                         \n       \n    return material.diffuse;\n}\n\n"},2197:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct CheckerboardMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec3 color1;\n    vec3 color2;\n};\n\nvec3 render(CheckerboardMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2), 2.);\n    if (x1 < 1. && x2 < 1.){\n        return material.color1;\n    } else if (x1 >= 1. && x2 >= 1.) {\n        return material.color1;\n    } else {\n        return material.color2;\n    }\n}\n\n"},7793:e=>{e.exports="\n                                                                                                                        \n                       \n                                                                                                                        \n"},3496:e=>{e.exports="                                                                                                                        \n                  \n                                            \n                                                     \n                                                                                                                        \n\nvec3 normalMaterialRender(ExtVector v, RelVector normal) {\n    Vector[3] f;\n    Point pos = applyGroupElement(v.vector.cellBoost, v.vector.local.pos);\n    frame(pos, f);\n\n    f[0] = applyGroupElement(v.vector.invCellBoost, f[0]);\n    f[1] = applyGroupElement(v.vector.invCellBoost, f[1]);\n    f[2] = applyGroupElement(v.vector.invCellBoost, f[2]);\n    \n                  \n                            \n    float r =  geomDot(normal.local, f[0]);\n    float g =  geomDot(normal.local, f[1]);\n    float b =  geomDot(normal.local, f[2]);\n    return abs(vec3(r, g, b));\n}"},7198:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct PathTracerWrapMaterial {\n    vec3 emission;\n    vec3 volumeEmission;\n    float opticalDepth;\n    vec3 specular;\n    vec3 absorb;\n    float ior;\n    float roughness;\n    float diffuseChance;\n    float reflectionChance;\n    float refractionChance;\n};\n\n\nRayType setRayType(PathTracerWrapMaterial material, ExtVector v, RelVector n, float r) {\n    RayType res = RayType(false, false, false, 0.);\n    float random = randomFloat();\n\n    float reflectionChance = fresnelReflectAmount(v.vector, n, r, material.reflectionChance, 1.0);\n    float chanceMultiplier = (1. - reflectionChance) / (1. - material.reflectionChance);\n    float refractionChance = chanceMultiplier * material.refractionChance;\n    float diffuseChance = 1. - refractionChance - reflectionChance;\n\n    if (random < diffuseChance){\n        res.diffuse = true;\n        res.chance = diffuseChance;\n    } else if (random < diffuseChance + reflectionChance){\n        res.reflect = true;\n        res.chance = reflectionChance;\n    }\n    else {\n        res.refract = true;\n        res.chance = refractionChance;\n    }\n    return res;\n}\n\n"},6045:e=>{e.exports="                                                                                                                        \n                 \n                                                                                                                        \n\nstruct PhongMaterial {\n    vec3 color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\n\n   \n                                                                \n                                \n                                                                        \n                                                             \n                                             \n                                               \n                                                                         \n                                                                   \n                                                            \n                                                      \n   \n                                                                                                                   \n                               \n                         \n                       \n                                                    \n                                                  \n                                                  \n  \n                                                          \n                                                                                                   \n                                 \n                                                       \n                  \n    \n\nvec3 lightComputation(Vector v, Vector n, Vector dir, PhongMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * material.color;\n    vec3 ambient = ambientCoeff * ambientLight * material.color;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},5836:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                                                        \n\nstruct PhongWrapMaterial {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    vec3 reflectivity;\n};\n\nvec3 lightComputation(Vector v, Vector n, Vector dir, vec3 baseColor, PhongWrapMaterial material, vec3 lightColor, float intensity){\n    Vector auxV = negate(v);\n    Vector auxL = dir;\n    Vector auxN = n;\n    Vector auxR = geomReflect(negate(auxL), auxN);\n    float NdotL = max(geomDot(auxN, auxL), 0.);\n    float RdotV = max(geomDot(auxR, auxV), 0.);\n\n                                                 \n    float specularCoeff = material.specular * pow(RdotV, material.shininess);\n    float diffuseCoeff = material.diffuse * NdotL;\n    float ambientCoeff = material.ambient;\n\n                                                \n                                                                                                                                                                                                                                      \n    vec3 specularLight = lightColor.rgb;\n    vec3 diffuseLight = 0.8 * lightColor.rgb + 0.2 * vec3(1.);\n    vec3 ambientLight = 0.5 * lightColor.rgb + 0.5 * vec3(1.);\n\n                                                 \n    vec3 specular = specularCoeff * specularLight;\n    vec3 diffuse = diffuseCoeff * diffuseLight * baseColor;\n    vec3 ambient = ambientCoeff * ambientLight * baseColor;\n\n                 \n    vec3 res = intensity * (ambient + diffuse + specular);\n\n    return res;\n}"},9095:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SimpleTextureMaterial {\n    sampler2D sampler;\n    vec2 start;\n    vec2 scale;\n    bool repeatU;\n    bool repeatV;\n};\n\nvec3 render(SimpleTextureMaterial material, ExtVector v, vec2 uv) {\n    vec2 texCoords = (uv - material.start) * material.scale;\n    vec4 color = texture(material.sampler, texCoords);\n                                                 \n    return color.xyz;\n}\n\n\n"},2664:e=>{e.exports="                                                                                                                        \n                        \n                                                                                                                        \n\nstruct SingleColorMaterial {\n    vec3 color;\n};\n\nvec3 render(SingleColorMaterial material, ExtVector v) {\n    return material.color;\n}"},3081:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct SquaresMaterial {\n    vec2 dir1;\n    vec2 dir2;\n    vec4 lengths;\n    vec3 color0;\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n\n};\n\nvec3 render(SquaresMaterial material, ExtVector v, vec2 uv) {\n    float x1 = mod(dot(uv, material.dir1) / dot(material.dir1, material.dir1), 2.);\n    float x2 = mod(dot(uv, material.dir2) / dot(material.dir2, material.dir2), 2.);\n    float c1 = abs(x1 - 1.);\n    float c2 = abs(x2 - 1.);\n    if (c1 < material.lengths.x && c2 < material.lengths.x){\n        return material.color0;\n    } else if (c1 < material.lengths.y && c2 < material.lengths.y){\n        return material.color1;\n    } else if (c1 < material.lengths.z && c2 < material.lengths.z){\n        return material.color2;\n    } else {\n        return material.color3;\n    }\n}\n\n"},5348:e=>{e.exports="vec3 applyFog(vec3 color, float dist){\n    float coeff = exp(- fog.scattering * dist);\n    return coeff * color + (1. - coeff) * fog.color;\n}"},7885:e=>{e.exports="                                                                                                                        \n  \n          \n                                 \n  \n                                                                                                                        \n\nstruct ExpFog {\n    vec3 color;                             \n    float scattering;                                                    \n};\n"},7333:e=>{e.exports="struct IntersectionShape {\n    float maxCoeff;\n};"},519:e=>{e.exports="struct UnionShape {\n    float minCoeff;\n};\n"},1685:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n    dir = camera.matrix * dir;\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},7591:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct Camera {\n    float fov;                              \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},4651:e=>{e.exports="   \n                                                                                                 \n                                                                                        \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = vec4(coords, 0);\n    dir = camera.matrix * dir;\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}\n\n   \n                                                                                             \n                                                               \n   \nRelVector mappingFromFlatScreen(vec2 coords) {\n                                                         \n    vec2 jitter = vec2(randomFloat(), randomFloat()) - 0.5;\n\n                                                                            \n    vec2 planeCoords = (coords - 0.5 * resolution + jitter) / (0.5 * resolution.y);\n\n                              \n    float z = - 1. / tan(radians(0.5 * camera.fov));\n\n                                                      \n    vec4 dir = vec4(planeCoords, z, 0);\n\n    dir = camera.matrix * dir;\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    RelVector res = applyPosition(camera.position, v);\n    return geomNormalize(res);\n}"},766:e=>{e.exports="                                                                                                                        \n          \n                      \n                                                                                               \n                                                                                                                        \nstruct PathTracerCamera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n    float focalLength;                    \n    float aperture;                \n};"},5074:e=>{e.exports="   \n                                                     \n                                                               \n   \nRelVector mapping(vec3 coords){\n    vec4 dir = normalize(vec4(coords, 0));\n    dir = camera.matrix * dir;\n    dir = normalize(dir);\n    Vector v = createVector(ORIGIN, dir.xyz);\n    return applyPosition(camera.position, v);\n}"},6539:e=>{e.exports="                                                                                                                        \n          \n          \n                                                                                               \n                                                                                                                        \nstruct VRCamera {\n    float fov;                     \n    float minDist;                                     \n    float maxDist;                                     \n    int maxSteps;                                                       \n    float threshold;                                          \n    RelPosition position;                                                                            \n    mat4 matrix;                                                 \n};"},190:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n\nVector geomMix(Vector v1, Vector v2, float a){\n    return add(multiplyScalar(1.-a, v1), multiplyScalar(a, v2));\n}\n\n   \n                                           \n                         \n             \n   \nVector negate(Vector v) {\n    return multiplyScalar(-1., v);\n}\n\n\n   \n                                         \n                       \n   \nfloat geomLength(Vector v){\n    return sqrt(geomDot(v, v));\n}\n\n   \n                                                          \n                            \n   \nVector geomNormalize(Vector v){\n    float a = geomLength(v);\n    return multiplyScalar(1./a, v);\n}\n\n   \n                                                     \n   \nfloat cosAngle(Vector v1, Vector v2){\n    float a1 = geomLength(v1);\n    float a2 = geomLength(v2);\n    return geomDot(v1, v2)/ (a1 * a2);\n}\n\n   \n                                                           \n                                   \n                                                                                                        \n                                     \n                                                                   \n                                                                       \n   \nVector geomReflect(Vector v, Vector n){\n    return sub(v, multiplyScalar(2. * geomDot(v, n), n));\n}\n\n\n   \n                                         \n                                                                        \n                                                                                   \n                                              \n   \nVector geomRefract(Vector v, Vector n, float r){\n    float cosTheta1 = -geomDot(n, v);\n    float sinTheta2Sq = r * r * (1. - cosTheta1 * cosTheta1);\n\n    if (sinTheta2Sq > 1.){\n               \n        return zeroVector(v.pos);\n    }\n                                                                 \n    float cosTheta2 = sqrt(1. - sinTheta2Sq);\n    float aux = r * cosTheta1 - cosTheta2;\n    return add(multiplyScalar(r, v), multiplyScalar(aux, n));\n}\n\n   \n                                                                          \n                                           \n   \nIsometry makeTranslation(Vector v) {\n    return makeTranslation(v.pos);\n}\n\n   \n                                                                          \n                                              \n   \nIsometry makeInvTranslation(Vector v) {\n    return makeInvTranslation(v.pos);\n}\n"},4168:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n                                                                         \n               \n   \nVector createVector(Point p, vec3 coords, Vector[3] frame){\n    Vector c0 = multiplyScalar(coords[0], frame[0]);\n    Vector c1 = multiplyScalar(coords[1], frame[1]);\n    Vector c2 = multiplyScalar(coords[2], frame[2]);\n    return add(c0, add(c1, c2));\n}\n\n\n\n   \n                                                                                          \n               \n   \nVector createVector(Point p, vec3 coords){\n    Vector[3] f;\n    frame(p, f);\n    return createVector(p, coords, f);\n}\n\n   \n                                                                                          \n               \n   \nVector createVectorOrtho(Point p, vec3 coords){\n    Vector[3] f;\n    orthoFrame(p, f);\n    return createVector(p, coords, f);\n}\n\n\n                                                                                                                        \n  \n                   \n                                                             \n                                                                       \n  \n                                                                                                                        \n\nstruct Position {\n    Isometry boost;\n    mat4 facing;\n};\n\n\n   \n                                        \n                          \n                                           \n   \nVector applyPosition(Position p, Vector v){\n    Vector res = applyFacing(p.facing, v);\n    return applyIsometry(p.boost, res);\n}"},2792:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                       \n                                                                                               \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n              \n                                \n   \nPoint applyIsometry(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\nPoint applyGroupElement(GroupElement elt, Point p){\n    return applyIsometry(toIsometry(elt), p);\n}\n\n   \n              \n                                \n   \nVector applyIsometry(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\nVector applyGroupElement(GroupElement elt, Vector v){\n    return applyIsometry(toIsometry(elt), v);\n}\n\n\n\n                                                                                                                        \n  \n                      \n                                                        \n                                                                     \n                        \n                                                                                 \n                                                                                 \n                                                                                   \n                                                                                    \n                                                                       \n                                                                                                                        \n\nstruct RelPosition {\n    Position local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n                                                                                                                        \n  \n                    \n                                  \n                                                                       \n                      \n                                                                                 \n                                                                                 \n                                                                            \n                                                                                    \n                                                                                                                        \n\nstruct RelVector {\n    Vector local;\n    GroupElement cellBoost;\n    GroupElement invCellBoost;\n};\n\n\n   \n                                                            \n   \nRelVector reduceError(RelVector v){\n    v.local = reduceError(v.local);\n    return v;\n}\n\n   \n                         \n                            \n                                                      \n   \nRelVector add(RelVector v1, RelVector v2){\n    v1.local = add(v1.local, v2.local);\n    return v1;\n}\n\n   \n                              \n                            \n                                                      \n   \nRelVector sub(RelVector v1, RelVector v2){\n    v1.local = sub(v1.local, v2.local);\n    return v1;\n}\n\n   \n                                   \n                         \n                      \n   \nRelVector multiplyScalar(float s, RelVector v){\n    v.local = multiplyScalar(s, v.local);\n    return v;\n}\n\n   \n                                                                                 \n                     \n                                                        \n   \nfloat geomDot(RelVector v1, RelVector v2) {\n    return geomDot(v1.local, v2.local);\n}\n\n   \n                              \n   \nRelVector geomNormalize(RelVector v){\n    v.local = geomNormalize(v.local);\n    return v;\n}\n\n   \n                                   \n                                                        \n   \nRelVector geomMix(RelVector v1, RelVector v2, float a) {\n    v1.local = geomMix(v1.local, v2.local, a);\n    return v1;\n}\n\n   \n                                            \n   \nRelVector negate(RelVector v){\n    v.local = negate(v.local);\n    return v;\n}\n\n   \n                                                                     \n                                                       \n   \nRelVector geomReflect(RelVector v, RelVector normal){\n    v.local = geomReflect(v.local, normal.local);\n    return v;\n}\n\n\n   \n                                                                     \n                                                       \n   \nRelVector geomRefract(RelVector v, RelVector normal, float n){\n    v.local = geomRefract(v.local, normal.local, n);\n    return v;\n}\n\n   \n                         \n                                            \n                                                                         \n   \nRelVector flow(RelVector v, float t) {\n    v.local = flow(v.local, t);\n    return v;\n}\n\n   \n                                                                                          \n                                                                           \n                                                                          \n                               \n                                                                                              \n   \nRelVector smallShift(RelVector v, vec3 dp){\n    v.local = smallShift(v.local, dp);\n    return v;\n                                                 \n                                                               \n}\n\n\n   \n                                                                                                            \n                           \n                                                   \n                                                                                             \n                                            \n   \n                                                   \n                                                   \n               \n                                                             \n                                                                 \n   \n\n   \n                                                                                                            \n                                                   \n                                                                                             \n   \nRelVector createRelVector(RelVector v, vec3 coords){\n    v.local =  createVector(v.local.pos, coords);\n    return v;\n                                                           \n                                                               \n}\n\n   \n                                                                  \n                          \n                                           \n   \nRelVector applyPosition(RelPosition position, Vector v) {\n    Vector local = applyPosition(position.local, v);\n    return RelVector(local, position.cellBoost, position.invCellBoost);\n}\n\n   \n                                                                                                                    \n   \nRelVector rewrite(RelVector v, GroupElement elt, GroupElement inv){\n    v.local = applyGroupElement(elt, v.local);\n                                     \n                                       \n    v.cellBoost = multiply(v.cellBoost, inv);\n    v.invCellBoost = multiply(elt, v.invCellBoost);\n    return v;\n}\n\n\n                                                                                                                        \n  \n                    \n                                    \n                                                                              \n                  \n                                                      \n                                                                                         \n  \n                                                                                                                        \n\nstruct ExtVector {\n    RelVector vector;\n    VectorData data;\n};\n\n\nExtVector flow(ExtVector v, float t) {\n    v.vector = flow(v.vector, t);\n    v.data.lastFlowDist = t;\n    v.data.lastBounceDist = v.data.lastBounceDist + t;\n    v.data.totalDist  = v.data.totalDist + t;\n    return v;\n}\n\n\n\n"},5315:e=>{e.exports="   \n                          \n   \nvarying vec3 spherePosition;\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    RelVector vector = mapping(spherePosition);\n    ExtVector v = ExtVector(vector, initVectorData());\n    vec3 color = getColor(v);\n    gl_FragColor = vec4(color, 1);\n}"},9461:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec3 pixel;                                                                   \n    vec3 leftToComputeColor;                                                                     \n};"},1767:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                             \n  \n                                                                                                                        \n                                                                                                                        \n\n   \n              \n   \nconst float PI = 3.1415926538;\n\n   \n                      \n   \nvec3 debugColor = vec3(0.5, 0, 0.8);\n\n   \n                                    \n         \n   \nconst int HIT_NOTHING = 0;\n   \n                                    \n         \n   \nconst int HIT_SOLID = 1;\n   \n                                  \n         \n   \nconst int HIT_DEBUG = -1;\n"},145:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + dist;\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\nvec3 getColor(ExtVector v){\n    int objId;\n    int hit;\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = raymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return v.data.pixel;\n}"},2639:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                \n  \n                                                                                                                        \n                                                                                                                        \n \nvarying vec3 spherePosition;\n\n   \n                                      \n                                                   \n                                                               \n                                                 \n   \nvoid main()\n{\n    spherePosition = position;\n    gl_Position = projectionMatrix * vec4(position, 1.0);\n}"},8187:e=>{e.exports="   \n                          \n   \nvarying vec3 spherePosition;\n\n\n   \n                                           \n                       \n                                                           \n                                 \n                                                         \n   \nvoid main() {\n    initSeed(gl_FragCoord.xy, frameSeed);\n    RelVector vector = mappingFromFlatScreen(gl_FragCoord.xy);\n    ExtVector v = ExtVector(vector, initVectorData());\n    vec3 color = getColor(v);\n    gl_FragColor = vec4(color, 1);\n}\n"},9638:e=>{e.exports="   \n                                                \n  \n   \nuint seed;\n\n   \n                                                \n                                                                  \n                                                \n                                                                                                         \n   \nvoid initSeed(vec2 coords, uint frameSeed){\n    uvec2 aux = uvec2(coords);\n    seed =  aux.x * uint(1973) + aux.y * uint(925277) + frameSeed * uint(26699) | uint(1);\n}\n\n   \n                           \n               \n                                                                                                     \n   \nuint wangHash() {\n    seed = (seed ^ uint(61)) ^ (seed >> uint(16));\n    seed = seed * uint(9);\n    seed = seed ^ (seed >> 4);\n    seed = seed * uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\n   \n                                                  \n   \nfloat randomFloat() {\n    return float(wangHash()) / 4294967296.;\n}\n\n   \n                                                                           \n                                                                                                    \n                                                                                                       \n                                          \n   \nvec3 randomUnitVec3() {\n    float z = randomFloat() * 2. - 1.;\n    float theta = randomFloat() * 2. * PI;\n    float r = sqrt(1. - z * z);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x, y, z);\n}\n\n   \n                                                   \n                                                      \n   \nVector randomVector(Point p) {\n    vec3 dir = randomUnitVec3();\n    return createVectorOrtho(p, dir);\n}\n\n   \n                                                                     \n                                                                                               \n   \nvec2 randomNormal2D(){\n    float u = randomFloat();\n    float v = randomFloat();\n\n    float r = sqrt(abs(2. * log(u)));\n    float x = r * cos(2. * PI * v);\n    float y = r * sin(2. * PI * v);\n\n    return vec2(x, y);\n\n}\n\n   \n                                                      \n   \nfloat randomNormal(float mean, float stdev){\n\n                           \n    float x = randomNormal2D().x;\n\n                                   \n    return stdev * x + mean;\n}\n"},7920:e=>{e.exports="   \n                                                                                      \n  \n   \n\n\n   \n                                                                                   \n                                                                          \n                                                       \n   \nRelVector randomVector(RelVector v) {\n    v.local = randomVector(v.local.pos);\n    return v;\n}"},3499:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n              \n  \n                                                                                                                        \n                                                                                                                        \n\n\n   \n                \n                                                      \n                                         \n                                                                                       \n                                                      \n                                                                    \n          \n                                \n                               \n                          \n                                                                                               \n                                                               \n                                                                                                                 \n                                                                                         \n   \nint raymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n            marchingStep = marchingStep + creepingDist(localV, dist, camera.threshold);\n            localV = flow(localV0, marchingStep);\n                                                                  \n                                                                                         \n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n        marchingStep = marchingStep + abs(dist);\n        globalV = flow(globalV0, marchingStep);\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool doesItScatter(inout float dist, float opticalDepth){\n                          \n    if (opticalDepth>100.){\n        return false;\n    }\n    else {\n        float probScatter=1.-exp(-dist/opticalDepth);\n        float flip=randomFloat();\n        if (flip<probScatter){\n                                           \n                                                \n            dist=dist*randomFloat();\n            return true;\n        }\n                                              \n        return false;\n    }\n}\n\n\nvoid scatterRay(inout ExtVector v){\n                                         \n    RelVector w=randomVector(v.vector);\n\n                                                 \n                                                  \n    v.vector=w;\n                                             \n                                                      \n}\n\n\n\nint scatterRaymarch(inout ExtVector v, out int objId){\n    initFlow(v.vector.local);                                                                 \n    ExtVector globalV0 = v;\n    ExtVector globalV = globalV0;\n    ExtVector localV0 = v;\n    ExtVector localV = localV0;\n    ExtVector res = v;\n    int auxId;\n    int auxHit;\n    float marchingStep = camera.minDist;\n    float dist;\n    int hit = HIT_NOTHING;\n    float d;\n    bool doScatter;\n\n\n                  \n    for (int i = 0; i < camera.maxSteps; i++){\n                          \n        localV.data.iMarch = v.data.iMarch + i;\n\n                                                     \n        localV = teleport(localV);\n        if (localV.data.isTeleported){\n                                                                                           \n            localV0 = localV;\n                                                                                      \n            marchingStep = camera.minDist;\n        }\n        else {\n                                                    \n            if (localV.data.totalDist > camera.maxDist) {\n                break;\n            }\n            dist = localSceneSDF(localV.vector, auxHit, auxId);\n            if (auxHit == HIT_DEBUG){\n                hit = HIT_DEBUG;\n                break;\n            }\n            if (auxHit == HIT_SOLID) {\n                                   \n                hit = HIT_SOLID;\n                objId = auxId;\n                v = localV;\n                break;\n            }\n\n                                          \n            d=abs(dist);\n            doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                                \n            marchingStep = marchingStep + creepingDist(localV, d, camera.threshold);\n            localV = flow(localV0, marchingStep);\n\n\n                                               \n                                                                              \n\n                                                       \n            if (doScatter){\n                scatterRay(localV);\n            }\n        }\n    }\n    if (hit == HIT_NOTHING) {\n        v = localV;\n    }\n                  \n    marchingStep = camera.minDist;\n    for (int i=0; i < camera.maxSteps; i++){\n                          \n        globalV.data.iMarch = v.data.iMarch + i;\n\n        if (globalV.data.totalDist > localV.data.totalDist || globalV.data.totalDist > camera.maxDist){\n                                              \n            break;\n        }\n        dist = globalSceneSDF(globalV.vector, auxHit, auxId);\n\n        if (auxHit == HIT_DEBUG){\n            hit = HIT_DEBUG;\n            break;\n        }\n        if (auxHit == HIT_SOLID) {\n                               \n            hit = auxHit;\n            objId = auxId;\n            v = globalV;\n            break;\n        }\n\n                                      \n        d=abs(dist);\n        doScatter=doesItScatter(d, v.data.currentOpticalDepth);\n\n                                            \n        marchingStep = marchingStep + d;\n        globalV = flow(globalV0, marchingStep);\n\n                                                   \n        if (doScatter){\n            scatterRay(globalV);\n        }\n    }\n\n    if (hit == HIT_NOTHING) {\n        v = globalV;\n    }\n    return hit;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 getColor(ExtVector v){\n    int objId;\n    int hit;\n    for (int i = 0; i <= maxBounces; i++){\n        if (v.data.stop){\n            break;\n        }\n        hit = scatterRaymarch(v, objId);\n        updateVectorData(v, hit, objId);\n    }\n    return v.data.pixel;\n}"},3888:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n           \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct RayType{\n    bool diffuse;\n    bool reflect;\n    bool refract;\n    float chance;\n};\n\n                                                                                                                        \n                                                                                                                        \n  \n                              \n  \n                                                                                                                        \n                                                                                                                        \n\nstruct VectorData {\n    float lastFlowDist;                                                                    \n    float lastBounceDist;                                                           \n    float totalDist;                                                  \n    bool isTeleported;                                             \n    int iMarch;                                                        \n    int iBounce;                                             \n    bool stop;                              \n    vec3 pixel;         \n    vec3 light;         \n    vec3 currentAbsorb;                                                    \n    vec3 currentEmission;                                                             \n    float currentOpticalDepth;                                                              \n    bool isInside;                                        \n};\n\n"},7499:e=>{e.exports="                                                                                                                        \n  \n           \n                               \n  \n                                                                                                                        \n \n struct Solid {\n    bool isRendered;\n };\n"},7928:e=>{e.exports="                                                                                                                        \n        \n                                                        \n                                                   \n                                                                               \n                                                                                                                        \n\n\n                                                  \n\nfloat hypDot(vec3 v1, vec3 v2){\n    return v1.x * v2.x + v1.y * v2.y - v1.z * v2.z;\n}\n\nfloat hypLengthSq(vec3 v) {\n    return abs(hypDot(v, v));\n}\n\nfloat hypLength(vec3 v) {\n    return sqrt(hypLengthSq(v));\n}\n\nvec3 hypNormalize(vec3 v) {\n    return v / hypLength(v);\n}\n\n                                                 \n\nfloat hypDot(vec4 v1, vec4 v2){\n    return hypDot(v1.xyz, v2.xyz);\n}\n\nfloat hypLengthSq(vec4 v) {\n    return abs(hypDot(v, v));\n}\n\nfloat hypLength(vec4 v) {\n    return sqrt(hypLengthSq(v));\n}\n\nvec4 hypNormalize(vec4 v) {\n    float len = hypLength(v);\n    return vec4(v.xyz / len, v.w);\n}\n\n                                                                                                                        \n  \n                   \n                                            \n  \n                                                                                                                        \nstruct Isometry{\n    mat4 matrix;\n    float shift;\n};\n\n   \n                    \n   \nconst Isometry IDENTITY = Isometry(mat4(1.), 0.);                          \n\n   \n                                                              \n                                            \n                                                                                    \n                                                                   \n   \nIsometry reduceError(Isometry isom){\n    vec4 col0 = isom.matrix[0];\n    vec4 col1 = isom.matrix[1];\n    vec4 col2 = isom.matrix[2];\n    vec4 col3 = isom.matrix[3];\n\n    col0 = hypNormalize(col0);\n\n    col1 = col1 - hypDot(col0, col1) * col0;\n    col1 = hypNormalize(col1);\n\n    col2 = col2 - hypDot(col0, col2) * col0;\n    col2 = col2 - hypDot(col1, col2) * col1;\n    col2 = hypNormalize(col2);\n\n    col3 = normalize(col3);\n    mat4 matrix = mat4(col0, col1, col2, col3);\n    return Isometry(matrix, isom.shift);\n\n\n                      \n}\n\n   \n                                     \n   \nIsometry multiply(Isometry isom1, Isometry isom2) {\n    mat4 matrix = isom1.matrix * isom2.matrix;\n    float shift = isom1.shift + isom1.matrix[3][3] * isom2.shift;\n    Isometry res = Isometry(matrix, shift);\n    return reduceError(res);\n}\n\n   \n                                            \n   \nIsometry geomInverse(Isometry isom) {\n    mat4 matrix = inverse(isom.matrix);\n    float shift = - isom.matrix[3][3] * isom.shift;\n    Isometry res = Isometry(matrix, shift);\n    return reduceError(res);\n\n}\n\n                                                                                                                        \n  \n                \n                                        \n  \n                                                                                                                        \nstruct Point{\n                                          \n    vec4 coords;\n};\n\n\nconst Point ORIGIN = Point(vec4(0, 0, 1, 0));                               \n\n   \n                                                           \n   \nPoint reduceError(Point p){\n    vec4 coords = hypNormalize(p.coords);\n    return Point(coords);\n}\n\n   \n                                       \n   \nPoint applyIsometry(Isometry isom, Point p) {\n    vec4 coords = isom.matrix * p.coords;\n    coords.w = coords.w + isom.shift;\n    Point res = Point(coords);\n    return reduceError(res);\n}\n\n   \n                                                                     \n                                  \n   \n\nIsometry makeTranslation(Point p) {\n\n    mat4 matrix = mat4(1.);\n    float shift = p.coords.w;\n    vec2 u = p.coords.xy;\n    float c1 = length(u);\n\n    if (c1 == 0.){\n        return Isometry(matrix, shift);\n    }\n\n    float c2 = p.coords.z - 1.;\n    u = normalize(u);\n\n    mat4 m = mat4(\n    0., 0., u.x, 0.,\n    0., 0., u.y, 0.,\n    u.x, u.y, 0., 0.,\n    0., 0., 0., 0.\n\n    );\n\n    matrix = matrix + c1 * m + c2 * m * m;\n    Isometry res = Isometry(matrix, shift);\n    return reduceError(res);\n}\n\n   \n                                                                     \n                                     \n   \nIsometry makeInvTranslation(Point p) {\n    Isometry isom = makeTranslation(p);\n    return geomInverse(isom);\n}\n\n                                                                                                                        \n  \n                 \n                                                              \n                                                                                                  \n  \n                                                                                                                        \nstruct Vector{\n    Point pos;                         \n    vec4 dir;\n};\n\n   \n                                \n   \nVector zeroVector(Point pos){\n    return Vector(pos, vec4(0));\n}\n\n\n   \n                                                            \n   \nVector reduceError(Vector v){\n    v.pos = reduceError(v.pos);\n    v.dir.xyz = v.dir.xyz + hypDot(v.pos.coords.xyz, v.dir.xyz) * v.pos.coords.xyz;\n    return v;\n}\n\n   \n                         \n                            \n   \nVector add(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir + v2.dir);\n}\n\n   \n                              \n                            \n   \nVector sub(Vector v1, Vector v2){\n    return Vector(v1.pos, v1.dir - v2.dir);\n}\n\n   \n                                   \n                         \n                      \n   \nVector multiplyScalar(float s, Vector v){\n    return Vector(v.pos, s * v.dir);\n}\n\n   \n                                                                                 \n                     \n   \nfloat geomDot(Vector v1, Vector v2) {\n    mat4 g = mat4(\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, -1, 0,\n    0, 0, 0, 1\n    );\n\n    return dot(v1.dir, g * v2.dir);\n}\n\n\n   \n                                        \n   \nVector applyIsometry(Isometry isom, Vector v) {\n    vec4 coords = isom.matrix * v.pos.coords;\n    coords.w = coords.w + isom.shift;\n    Point pos = Point(coords);\n    Vector res = Vector(pos, isom.matrix * v.dir);\n    return reduceError(res);\n}\n\n\n   \n                                                                       \n                                                                                                           \n                                           \n   \nVector applyFacing(mat4 m, Vector v) {\n    vec4 aux = m * vec4(v.dir.xy, v.dir.w, 0.);\n    Vector res = Vector(v.pos, vec4(aux.xy, 0., aux.z));\n    return res;\n                                  \n}\n\nvoid initFlow(Vector v){\n}"},9822:e=>{e.exports="   \n                               \n                                                                       \n                                     \n                                                      \n   \nvoid frame(Point p, out Vector[3] f){\n    float x = p.coords.x;\n    float y = p.coords.y;\n    float z = p.coords.z;\n\n    vec4 dir0 = vec4(z, 0, x, 0);\n    vec4 dir1 = vec4(0, z, y, 0);\n    vec4 dir2 = vec4(0, 0, 0, 1);\n\n    dir0 = hypNormalize(dir0);\n    dir1 = hypNormalize(dir1);\n\n    f[0] = Vector(p, dir0);\n    f[1] = Vector(p, dir1);\n    f[2] = Vector(p, dir2);\n}\n\nvoid orthoFrame(Point p, out Vector[3] f){\n    float x = p.coords.x;\n    float y = p.coords.y;\n    float z = p.coords.z;\n\n    float den = 1. + z;\n    vec4 dir0 = (1. / den) * vec4(x * x + z + 1., x * y, x * den, 0.);\n    vec4 dir1 = (1. / den) * vec4(x * y, y * y + z + 1., y * den, 0.);\n    vec4 dir2 = vec4(0, 0, 0, 1);\n\n    f[0] = Vector(p, dir0);\n    f[1] = Vector(p, dir1);\n    f[2] = Vector(p, dir2);\n}\n\n   \n                                                                                         \n                              \n                                                                                              \n   \nPoint smallShift(Point p, vec3 dp){\n    Vector[3] f;\n    frame(p, f);\n    vec4 coords = p.coords + dp[0] * f[0].dir + dp[1] * f[1].dir + dp[2] * f[2].dir;\n\n    Point res = Point(coords);\n    return reduceError(res);\n}\n\n\nVector smallShift(Vector v, vec3 dp){\n    Point pos = smallShift(v.pos, dp);\n    return Vector(pos, v.dir);\n}\n\n\n   \n                                  \n                                                 \n   \nVector flow(Vector v, float t){\n    vec3 u = v.dir.xyz;\n    float lambda = hypLength(u);\n    u = hypNormalize(u);\n    vec3 coords = cosh(lambda * t) * v.pos.coords.xyz + sinh(lambda * t) * u;\n    Point pos = Point(vec4(coords, v.pos.coords.w + t * v.dir.w));\n\n    vec3 dir = sinh(lambda * t) * v.pos.coords.xyz + cosh(lambda * t) * u;\n    Vector res = Vector(pos, vec4(lambda * dir, v.dir.w));\n    res = reduceError(res);\n    res = geomNormalize(res);\n    return res;\n}\n"},4761:e=>{e.exports="Vector direction(Point p, Point q){\n    vec3 pAux = p.coords.xyz;\n    vec3 qAux = q.coords.xyz;\n    float c = hypDot(pAux, qAux);\n    float lenAux = acosh(-c);\n    vec3 dirAux = qAux + c * pAux;\n    dirAux = (lenAux / sqrt(c * c  - 1.)) * dirAux;\n    Vector res = Vector(p, vec4(dirAux, q.coords.w - p.coords.w));\n    return geomNormalize(res);\n}\n"},5912:e=>{e.exports="   \n                              \n   \nfloat dist(Point p1, Point p2){\n    float aux1 = acosh(-hypDot(p1.coords, p2.coords));\n    float aux2 = p1.coords.w - p2.coords.w;\n    return sqrt(aux1 * aux1 + aux2 * aux2);\n}"},3820:e=>{e.exports="   \n                                                                                   \n                                                  \n                                        \n                                \n  \nfloat lightIntensity(float len){\n                            \n    return 1./ len;\n}"},6671:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct ESun {\n    int id;\n    vec3 color;\n    float intensity;\n    float direction;\n    int maxDirs;\n};\n\nbool directions(ESun light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i != 0){\n        return false;\n    }\n    intensity = light.intensity;\n    Vector local = Vector(v.local.pos, vec4(0, 0, 0, light.direction));\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}\n"},6489:e=>{e.exports="                                                                                                                        \n          \n                        \n                                                                                                                        \nstruct PointLight {\n    int id;\n    vec3 color;\n    float intensity;\n    Point position;\n    int maxDirs;\n};\n\nbool directions(PointLight light, RelVector v, int i, out RelVector dir, out float intensity) {\n    if (i!=0){\n        return false;\n    }\n    Point position = applyGroupElement(v.invCellBoost, light.position);\n    float dist = dist(v.local.pos, position);\n    intensity = lightIntensity(dist) * light.intensity;\n    Vector local = direction(v.local.pos, position);\n    dir = RelVector(local, v.cellBoost, v.invCellBoost);\n    return true;\n}\n"},6882:e=>{e.exports="                                                                                                                        \n                         \n                                                                                                                        \n\nstruct VaryingColorMaterial {\n    vec3 mainColor;\n    vec3 weight;\n};\n\nvec3 render(VaryingColorMaterial material, ExtVector v) {\n    return material.mainColor + material.weight * v.vector.local.pos.coords.xyw;\n}"},3021:e=>{e.exports="                                                                                                                        \n          \n                          \n                                                                                                                        \n\nstruct BallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                      \n   \nfloat sdf(BallShape ball, RelVector v) {\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    return dist(v.local.pos, center) - ball.radius;\n}\n\n   \n                                   \n   \nRelVector gradient(BallShape ball, RelVector v){\n    Point center = applyGroupElement(v.invCellBoost, ball.center);\n    Vector local = direction(v.local.pos, center);\n    return RelVector(negate(local), v.cellBoost, v.invCellBoost);\n}\n"},9511:e=>{e.exports="                                                                                                                        \n          \n                          \n                                                                                                                        \n\nstruct LocalBallShape {\n    int id;\n    Point center;\n    float radius;\n};\n\n   \n                                     \n   \nfloat sdf(LocalBallShape ball, RelVector v) {\n    return dist(v.local.pos, ball.center) - ball.radius;\n}\n\n   \n                                  \n   \nRelVector gradient(LocalBallShape ball, RelVector v){\n    Vector local = direction(v.local.pos, ball.center);\n    return RelVector(negate(local), v.cellBoost, v.invCellBoost);\n}\n"},5688:e=>{e.exports="                                                                                                                        \n                                                                                                                        \n  \n                                                            \n  \n                                                                                                                        \n                                                                                                                        \n\n\n"},466:(e,t,n)=>{e.exports=n.p+"img/426f7657671a2811d4aa.png"},8367:(e,t,n)=>{e.exports=n.p+"img/33960f5af615e67309e5.jpg"},2971:(e,t,n)=>{e.exports=n.p+"img/eba62d0cff4836a949b8.png"},5753:(e,t,n)=>{e.exports=n.p+"img/4b569137334e61081651.jpg"}},s={};function a(e){var t=s[e];if(void 0!==t)return t.exports;var n=s[e]={exports:{}};return o[e](n,n.exports,a),n.exports}a.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),a.p=e})();var i={};(()=>{a.d(i,{ec:()=>si,Yb:()=>Za,QU:()=>Le,ZH:()=>ot,K9:()=>ii,cK:()=>Fn,_x:()=>Bn,kj:()=>Nn,Vz:()=>nr,Iy:()=>oo,ik:()=>Oa,fY:()=>Ua,TB:()=>ir,Al:()=>xn,Gj:()=>Ga,KO:()=>ur,c$:()=>dt,mD:()=>Me,yb:()=>at,ZA:()=>Tn,Jz:()=>Ve,HZ:()=>Xo,TN:()=>To,JV:()=>s,Sc:()=>Qo,Nh:()=>Yo,RL:()=>ye,_k:()=>On,uR:()=>es,jo:()=>ai,Q:()=>ti,Qv:()=>gr,F5:()=>We,Uc:()=>is,Yu:()=>mr,Fh:()=>yn,oB:()=>qn,pJ:()=>Ye,GW:()=>He,DZ:()=>li,_K:()=>qr,JF:()=>Yn,Lv:()=>Pr,E9:()=>l,ce:()=>Ba,Ly:()=>h,iv:()=>as,mH:()=>ns,xd:()=>ss,pX:()=>xe,Dz:()=>_e,Uj:()=>ts,cV:()=>wo,lR:()=>Fo,xs:()=>st,oC:()=>Zo,h8:()=>Qe,Qf:()=>oi,k1:()=>wr,_D:()=>fr,$p:()=>Jo,xG:()=>Un,qC:()=>hi,N$:()=>di,TO:()=>ui,yI:()=>Uo,E6:()=>Fe,zO:()=>ci,cB:()=>za,OW:()=>c,$9:()=>Ko,iR:()=>gn,ak:()=>ve,Cy:()=>so,Y7:()=>Es,jV:()=>So,mm:()=>ta,wS:()=>Kr,IJ:()=>Lr,cR:()=>wa,p2:()=>ge,dV:()=>Gn,G0:()=>Oo,re:()=>$o,xS:()=>Va});const o=(e=>{var t={};return a.d(t,e),t})({AnimationClip:()=>e.AnimationClip,Bone:()=>e.Bone,Box3:()=>e.Box3,BufferAttribute:()=>e.BufferAttribute,BufferGeometry:()=>e.BufferGeometry,CanvasTexture:()=>e.CanvasTexture,ClampToEdgeWrapping:()=>e.ClampToEdgeWrapping,Clock:()=>e.Clock,Color:()=>e.Color,DirectionalLight:()=>e.DirectionalLight,DoubleSide:()=>e.DoubleSide,EventDispatcher:()=>e.EventDispatcher,FileLoader:()=>e.FileLoader,Float32BufferAttribute:()=>e.Float32BufferAttribute,FloatType:()=>e.FloatType,FrontSide:()=>e.FrontSide,Group:()=>e.Group,ImageBitmapLoader:()=>e.ImageBitmapLoader,InterleavedBuffer:()=>e.InterleavedBuffer,InterleavedBufferAttribute:()=>e.InterleavedBufferAttribute,Interpolant:()=>e.Interpolant,InterpolateDiscrete:()=>e.InterpolateDiscrete,InterpolateLinear:()=>e.InterpolateLinear,Line:()=>e.Line,LineBasicMaterial:()=>e.LineBasicMaterial,LineLoop:()=>e.LineLoop,LineSegments:()=>e.LineSegments,LinearFilter:()=>e.LinearFilter,LinearMipmapLinearFilter:()=>e.LinearMipmapLinearFilter,LinearMipmapNearestFilter:()=>e.LinearMipmapNearestFilter,Loader:()=>e.Loader,LoaderUtils:()=>e.LoaderUtils,Material:()=>e.Material,MathUtils:()=>e.MathUtils,Matrix3:()=>e.Matrix3,Matrix4:()=>e.Matrix4,Mesh:()=>e.Mesh,MeshBasicMaterial:()=>e.MeshBasicMaterial,MeshPhysicalMaterial:()=>e.MeshPhysicalMaterial,MeshStandardMaterial:()=>e.MeshStandardMaterial,MirroredRepeatWrapping:()=>e.MirroredRepeatWrapping,NearestFilter:()=>e.NearestFilter,NearestMipmapLinearFilter:()=>e.NearestMipmapLinearFilter,NearestMipmapNearestFilter:()=>e.NearestMipmapNearestFilter,NumberKeyframeTrack:()=>e.NumberKeyframeTrack,Object3D:()=>e.Object3D,OrthographicCamera:()=>e.OrthographicCamera,PerspectiveCamera:()=>e.PerspectiveCamera,PointLight:()=>e.PointLight,Points:()=>e.Points,PointsMaterial:()=>e.PointsMaterial,PropertyBinding:()=>e.PropertyBinding,Quaternion:()=>e.Quaternion,QuaternionKeyframeTrack:()=>e.QuaternionKeyframeTrack,RGBAFormat:()=>e.RGBAFormat,RGBFormat:()=>e.RGBFormat,RepeatWrapping:()=>e.RepeatWrapping,Scene:()=>e.Scene,ShaderMaterial:()=>e.ShaderMaterial,Skeleton:()=>e.Skeleton,SkinnedMesh:()=>e.SkinnedMesh,Sphere:()=>e.Sphere,SphereBufferGeometry:()=>e.SphereBufferGeometry,SphereGeometry:()=>e.SphereGeometry,SpotLight:()=>e.SpotLight,TangentSpaceNormalMap:()=>e.TangentSpaceNormalMap,TextureLoader:()=>e.TextureLoader,TriangleFanDrawMode:()=>e.TriangleFanDrawMode,TriangleStripDrawMode:()=>e.TriangleStripDrawMode,Uniform:()=>e.Uniform,UniformsUtils:()=>e.UniformsUtils,Vector2:()=>e.Vector2,Vector3:()=>e.Vector3,Vector4:()=>e.Vector4,VectorKeyframeTrack:()=>e.VectorKeyframeTrack,WebGLRenderTarget:()=>e.WebGLRenderTarget,WebGLRenderer:()=>e.WebGLRenderer,sRGBEncoding:()=>e.sRGBEncoding});class s{constructor(){this.build(...arguments)}get isIsometry(){return!0}build(){throw new Error("This method need be overloaded.")}identity(){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}multiply(e){throw new Error("This method need be overloaded.")}premultiply(e){throw new Error("This method need be overloaded.")}invert(){return this.matrix.invert(),this}makeTranslation(e){throw new Error("This method need be overloaded.")}makeInvTranslation(e){throw new Error("This method need be overloaded.")}makeTranslationFromDir(e){throw new Error("This method need be overloaded.")}diffExpMap(e){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}clone(){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}}s.prototype.build=function(){this.matrix=new o.Matrix4,this.shift=0},s.prototype.identity=function(){return this.matrix.identity(),this.shift=0,this},s.prototype.reduceError=function(){const e=new o.Vector4(1,0,0,0).applyMatrix4(this.matrix),t=new o.Vector4(0,1,0,0).applyMatrix4(this.matrix),n=new o.Vector4(0,0,1,0).applyMatrix4(this.matrix),r=new o.Vector4(0,0,0,1).applyMatrix4(this.matrix);e.hypNormalize();const s=e.clone().multiplyScalar(e.hypDot(t));t.sub(s).hypNormalize();const a=e.clone().multiplyScalar(e.hypDot(n)),i=t.clone().multiplyScalar(t.hypDot(n));return n.sub(a).sub(i).hypNormalize(),r.normalize(),this.matrix.set(e.x,t.x,n.x,r.x,e.y,t.y,n.y,r.y,e.z,t.z,n.z,r.z,e.w,t.w,n.w,r.w),this},s.prototype.multiply=function(e){const t=this.matrix.elements[this.matrix.elements.length-1];return this.matrix.multiply(e.matrix),this.shift=this.shift+t*e.shift,this},s.prototype.premultiply=function(e){const t=e.matrix.elements[e.matrix.elements.length-1];return this.matrix.premultiply(e.matrix),this.shift=e.shift+t*this.shift,this},s.prototype.invert=function(){this.matrix.invert();const e=this.matrix.elements[this.matrix.elements.length-1];return this.shift=-e*this.shift,this},s.prototype.makeTranslation=function(e){const[t,n,r,s]=e.coords.toArray();this.matrix.identity(),this.shift=s;const a=new o.Vector2(t,n),i=a.length();if(0===i)return this;const l=r-1;a.normalize();const c=(new o.Matrix4).set(0,0,a.x,0,0,0,a.y,0,a.x,a.y,0,0,0,0,0,0),h=c.clone().multiply(c);return c.multiplyScalar(i),h.multiplyScalar(l),this.matrix.add(c),this.matrix.add(h),this},s.prototype.makeInvTranslation=function(e){return this.makeTranslation(e),this.invert(),this},s.prototype.makeTranslationFromDir=function(e){const[t,n,r]=e.toArray();this.matrix.identity(),this.shift=r;const s=new o.Vector2(t,n),a=s.length();if(0===a)return this;const i=Math.sinh(a),l=Math.cosh(a)-1;s.normalize();const c=(new o.Matrix4).set(0,0,s.x,0,0,0,s.y,0,s.x,s.y,0,0,0,0,0,0),h=c.clone().multiply(c);return c.multiplyScalar(i),this.matrix.add(c),h.multiplyScalar(l),this.matrix.add(h),this},s.prototype.equals=function(e){return this.matrix.equals(e.matrix)&&this.shift===e.shift},s.prototype.clone=function(){const e=new s;return e.matrix.copy(this.matrix),e.shift=this.shift,e},s.prototype.copy=function(e){return this.matrix.copy(e.matrix),this.shift=e.shift,this};class l{constructor(...e){this.build(...e)}build(){throw new Error("This method need be overloaded.")}set(){throw new Error("This method need be overloaded.")}get isPoint(){return!0}applyIsometry(e){throw new Error("This method need be overloaded.")}reduceError(){throw new Error("This method need be overloaded.")}equals(e){throw new Error("This method need be overloaded.")}clone(){throw new Error("This method need be overloaded.")}copy(e){throw new Error("This method need be overloaded.")}}l.prototype.build=function(){this.coords=0===arguments.length?new o.Vector4(0,0,1,0):new o.Vector4(...arguments)},l.prototype.set=function(){return this.coords.set(...arguments),this},l.prototype.applyIsometry=function(e){return this.coords.applyMatrix4(e.matrix),this.coords.setW(this.coords.w+e.shift),this},l.prototype.reduceError=function(){return this},l.prototype.clone=function(){let e=new l;return e.coords.copy(this.coords),e},l.prototype.copy=function(e){return this.coords.copy(e.coords),this};class c extends o.Vector3{get isVector(){return!0}applyMatrix4(e){const t=new o.Vector4(this.x,this.y,this.z,0);return t.applyMatrix4(e),this.set(t.x,t.y,t.z),this}applyFacing(e){return this.applyQuaternion(e.quaternion),this}}class h{constructor(){this.boost=new s,this.quaternion=new o.Quaternion}get isPosition(){return!0}get facing(){return(new o.Matrix4).makeRotationFromQuaternion(this.quaternion)}setBoost(e){return this.boost=e,this}setQuaternion(e){return this.quaternion=e,this}reduceErrorBoost(){return this.boost.reduceError(),this}reduceErrorQuaternion(){return this.quaternion.normalize(),this}reduceError(){return this.reduceErrorBoost(),this.reduceErrorQuaternion(),this}get point(){return(new l).applyIsometry(this.boost)}reset(){return this.boost.identity(),this.quaternion.identity(),this}applyIsometry(e){return this.boost.premultiply(e),this}applyQuaternion(e){return this.quaternion.multiply(e),this}multiply(e){return this.boost.multiply(e.boost),this.quaternion.premultiply(e.quaternion),this}premultiply(e){return this.boost.premultiply(e.boost),this.quaternion.multiply(e.quaternion),this}invert(){return this.boost.invert(),this.quaternion.conjugate(),this}flowFromOrigin(e){throw new Error("This method need be overloaded.")}flow(e){const t=e.clone().applyFacing(this),n=(new h).flowFromOrigin(t);return this.multiply(n),this}fakeDiffExpMap(e){const t=(new c).setFromMatrixPosition(e),n=(new o.Quaternion).setFromRotationMatrix(e);return this.flow(t),this.quaternion.multiply(n),this}equals(e){return this.boost.equals(e.boost)&&this.quaternion.equals(e.quaternion)}clone(){let e=new h;return e.boost.copy(this.boost),e.quaternion.copy(this.quaternion),e}copy(e){this.boost.copy(e.boost),this.quaternion.copy(e.quaternion)}}h.prototype.flowFromOrigin=function(e){return this.boost.makeTranslationFromDir(e),this.quaternion.identity(),this};var d=a(7928),u=a.n(d),p=a(9822),m=a.n(p),b={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"};class f{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const v=new o.OrthographicCamera(-1,1,1,-1,0,1),g=new o.BufferGeometry;g.setAttribute("position",new o.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),g.setAttribute("uv",new o.Float32BufferAttribute([0,2,0,0,2,0],2));class y{constructor(e){this._mesh=new o.Mesh(g,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,v)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class x extends f{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof o.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=o.UniformsUtils.clone(e.uniforms),this.material=new o.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new y(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}class w extends f{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const r=e.getContext(),o=e.state;let s,a;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0),this.inverse?(s=0,a=1):(s=1,a=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),o.buffers.stencil.setFunc(r.ALWAYS,s,4294967295),o.buffers.stencil.setClear(a),o.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(r.EQUAL,1,4294967295),o.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),o.buffers.stencil.setLocked(!0)}}class T extends f{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class S{constructor(e,t){if(this.renderer=e,void 0===t){const n={minFilter:o.LinearFilter,magFilter:o.LinearFilter,format:o.RGBAFormat},r=e.getSize(new o.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=r.width,this._height=r.height,(t=new o.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,n)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===b&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===x&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new x(b),this.clock=new o.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,r=this.passes.length;t<r;t++){const r=this.passes[t];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==w&&(r instanceof w?n=!0:r instanceof T&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new o.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}const R=new o.OrthographicCamera(-1,1,1,-1,0,1),V=new o.BufferGeometry;V.setAttribute("position",new o.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),V.setAttribute("uv",new o.Float32BufferAttribute([0,2,0,0,2,0],2));class _ extends f{constructor(e,t,n,r,s){super(),this.scene=e,this.camera=t,this.overrideMaterial=n,this.clearColor=r,this.clearAlpha=void 0!==s?s:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new o.Color}render(e,t,n){const r=e.autoClear;let o,s;e.autoClear=!1,void 0!==this.overrideMaterial&&(s=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),o=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,o),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=s),e.autoClear=r}}Object.defineProperty(o.WebGLRenderer.prototype,"isWebGLRenderer",{get:function(){return!0}});class C{constructor(e,t,n,r,s,a={},i={}){this.shader1=e,this.shader2=t,this.set=n,this.camera=r,this.scene=s,this.threeRenderer=i.isWebGLRenderer?i:new o.WebGLRenderer(i),this.maxBounces=void 0!==a.maxBounces?a.maxBounces:0,this.postProcess=void 0!==a.postProcess&&a.postProcess,this.threeScene=new o.Scene}setPixelRatio(e){this.threeRenderer.setPixelRatio(e)}setSize(e,t,n=!0){this.threeRenderer.setSize(e,t,n)}setClearColor(e,t){this.threeRenderer.setClearColor(e,t)}setAnimationLoop(e){this.threeRenderer.setAnimationLoop(e)}get domElement(){return this.threeRenderer.domElement}build(){throw new Error("AbstractRenderer: this method is not implemented")}render(){throw new Error("AbstractRenderer: this method is not implemented")}}class M{constructor(e=1){this.useCase=e,this.code="",this.includedImports=[],this.includedClasses=[],this.includedConstants=[],this.includedUniforms=[],this.includedInstances=[],this.uniforms={}}addChunk(e){return this.code=this.code+"\r\n\r\n"+e,this}addImport(e){return this.includedImports.includes(e)||(this.includedImports.push(e),this.code=this.code+"\r\n\r\n"+e),this}addClass(e,t){return this.includedClasses.includes(e)||(this.includedClasses.push(e),this.code=this.code+"\r\n\r\n"+t),this}addConstant(e,t,n){return this.includedConstants.includes(e)||(this.includedConstants.push(e),this.code=this.code+"\r\n\r\n"+`const ${t} ${e} = ${n};`),this}addUniform(e,t,n){return this.includedUniforms.includes(e)||(this.includedUniforms.push(e),this.code=this.code+"\r\n\r\n"+`uniform ${t} ${e};`,this.uniforms[e]={type:t,value:n}),this}updateUniform(e,t){return this.uniforms[e].value=t,this}addInstance(e,t){return this.includedInstances.includes(e)||(this.includedInstances.push(e),this.code=this.code+"\r\n\r\n"+t),this}}var I=a(2639),E=a.n(I),D=a(1767),P=a.n(D),L=a(190),k=a.n(L),A=a(4168),B=a.n(A),N=a(145),F=a.n(N),U=a(2044),O=a.n(U),G=a(9461),j=a.n(G),H=a(7781),z=a.n(H);const W={uniforms:{tDiffuse:{value:null}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",fragmentShader:"\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n\n\n        vec3 LessThan(vec3 f, float value)\n        {\n            return vec3(\n            (f.x < value) ? 1.0f : 0.0f,\n            (f.y < value) ? 1.0f : 0.0f,\n            (f.z < value) ? 1.0f : 0.0f);\n        }\n\n        //GAMMA CORRECTION\n        vec3 LinearToSRGB(vec3 rgb)\n        {\n            rgb = clamp(rgb, 0.0f, 1.0f);\n\n            return mix(\n            pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n            rgb * 12.92f,\n            LessThan(rgb, 0.0031308f)\n            );\n        }\n        //TONE MAPPING\n        vec3 ACESFilm(vec3 x)\n        {\n            float a = 2.51f;\n            float b = 0.03f;\n            float c = 2.43f;\n            float d = 0.59f;\n            float e = 0.14f;\n            return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0f, 1.0f);\n        }\n\n        vec3 postProcess(vec3 pixelColor){\n\n            //set the exposure \n            float exposure = 0.8;\n            pixelColor *= exposure;\n\n            //correct tones\n            pixelColor = ACESFilm(pixelColor);\n            pixelColor = LinearToSRGB(pixelColor);\n\n            return pixelColor;\n        }\n        \n        void main() {\n            vec4 color = texture2D(tDiffuse, vUv);\n            vec3 aux = postProcess(color.rgb);\n            gl_FragColor = vec4(min(vec3(1.0), aux), color.a);\n        }"};var q=a(5315),K=a.n(q);class $ extends C{constructor(e,t,n,r,o,s={},a={}){super(e,t,n,r,o,s,a),this._fragmentBuilder=new M,this.composer=new S(this.threeRenderer)}get isBasicRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.composer.setPixelRatio(window.devicePixelRatio)}setSize(e,t,n=!0){super.setSize(e,t,n),this.composer.setSize(window.innerWidth,window.innerHeight)}buildFragmentShader(){this._fragmentBuilder.addChunk(P()),this._fragmentBuilder.addUniform("maxBounces","int",this.maxBounces),this._fragmentBuilder.addChunk(this.shader1),this._fragmentBuilder.addChunk(k()),this._fragmentBuilder.addChunk(this.shader2),this._fragmentBuilder.addChunk(B()),this._fragmentBuilder.addChunk(j()),this.set.shader(this._fragmentBuilder),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(O()(this)),this._fragmentBuilder.addChunk(z()(this)),this._fragmentBuilder.addChunk(F()),this._fragmentBuilder.addChunk(K())}build(){const e=new o.SphereBufferGeometry(1e3,60,40);e.scale(1,1,-1),this.buildFragmentShader();const t=new o.ShaderMaterial({uniforms:this._fragmentBuilder.uniforms,vertexShader:E(),fragmentShader:this._fragmentBuilder.code}),n=new o.Mesh(e,t);this.threeScene.add(n);const r=new _(this.threeScene,this.camera.threeCamera);if(r.clear=!1,this.composer.addPass(r),this.postProcess){const e=new x(W);e.clear=!1,this.composer.addPass(e)}return this}checkShader(){console.log(this._fragmentBuilder.code)}render(){this.composer.render()}}class X extends f{constructor(e,t){super(),void 0===b&&console.error("THREE.TexturePass relies on CopyShader");const n=b;this.map=e,this.opacity=void 0!==t?t:1,this.uniforms=o.UniformsUtils.clone(n.uniforms),this.material=new o.ShaderMaterial({uniforms:this.uniforms,vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,depthTest:!1,depthWrite:!1}),this.needsSwap=!1,this.fsQuad=new y(null)}render(e,t,n){const r=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.uniforms.opacity.value=this.opacity,this.uniforms.tDiffuse.value=this.map,this.material.transparent=this.opacity<1,e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(),this.fsQuad.render(e),e.autoClear=r}}var Q=a(6172),Y=a.n(Q),Z=a(3499),J=a.n(Z),ee=a(9638),te=a.n(ee),ne=a(7920),re=a.n(ne),oe=a(3888),se=a.n(oe),ae=a(6272),ie=a.n(ae),le=a(8187),ce=a.n(le),he=a(4122),de=a.n(he);const ue=new o.ShaderMaterial({uniforms:{accTex:new o.Uniform(null),newTex:new o.Uniform(null),iFrame:new o.Uniform(0)},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D accTex;\n        uniform sampler2D newTex;\n        uniform float iFrame;\n        void main() {\n            float den = 1./ (1. + iFrame);\n            gl_FragColor = den * (iFrame *  texture2D(accTex, vUv) + texture2D(newTex, vUv));\n        }"}),pe=new class{constructor(e){this._mesh=new o.Mesh(V,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,R)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}(ue),me={minFilter:o.NearestFilter,magFilter:o.NearestFilter,format:o.RGBAFormat,type:o.FloatType};class be extends C{constructor(e,t,n,r,s,a={},i={}){super(e,t,n,r,s,a,i),this.maxBounces=void 0!==a.maxBounces?a.maxBounces:50,this._fragmentBuilder=new M(3),this.sceneTarget=new o.WebGLRenderTarget(window.innerWidth,window.innerHeight,me),this.accReadTarget=new o.WebGLRenderTarget(window.innerWidth,window.innerHeight,me),this.accWriteTarget=new o.WebGLRenderTarget(window.innerWidth,window.innerHeight,me),this.iFrame=0,this.displayComposer=new S(this.threeRenderer)}get isPathTracerRenderer(){return!0}setPixelRatio(e){super.setPixelRatio(e),this.displayComposer.setPixelRatio(e)}setSize(e,t,n=!0){super.setSize(e,t,n),this.sceneTarget.setSize(e,t),this.accReadTarget.setSize(e,t),this.accWriteTarget.setSize(e,t),this.displayComposer.setSize(e,t)}updateFrameSeed(){const e=Math.floor(1e4*Math.random());this._fragmentBuilder.updateUniform("frameSeed",e)}buildFragmentShader(){this._fragmentBuilder.addChunk(P());const e=new o.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.addUniform("resolution","vec2",e),this._fragmentBuilder.addUniform("maxBounces","int",this.maxBounces),this._fragmentBuilder.addChunk(this.shader1),this._fragmentBuilder.addChunk(k()),this._fragmentBuilder.addChunk(this.shader2),this._fragmentBuilder.addChunk(B()),this._fragmentBuilder.addUniform("frameSeed","uint",Math.floor(1e4*Math.random())),this._fragmentBuilder.addChunk(te()),this._fragmentBuilder.addChunk(se()),this.set.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(re()),this.camera.shader(this._fragmentBuilder),this.scene.shader(this._fragmentBuilder),this._fragmentBuilder.addChunk(Y()(this)),this._fragmentBuilder.addChunk(de()(this)),this._fragmentBuilder.addChunk(ie()(this)),this._fragmentBuilder.addChunk(J()),this._fragmentBuilder.addChunk(ce())}build(){const e=new o.SphereBufferGeometry(1e3,60,40);e.scale(1,1,-1),this.buildFragmentShader();const t=new o.ShaderMaterial({uniforms:this._fragmentBuilder.uniforms,vertexShader:E(),fragmentShader:this._fragmentBuilder.code}),n=new o.Mesh(e,t);return this.threeScene.add(n),this.displayComposer.addPass(new X(this.accReadTarget.texture)),this.displayComposer.addPass(new x(W)),this}checkShader(){console.log(this._fragmentBuilder.code)}renderAccTarget(){this.threeRenderer.setRenderTarget(null),this.displayComposer.render()}render(){let e;this.updateFrameSeed();const t=new o.Vector2(this.accWriteTarget.width,this.accWriteTarget.height);this._fragmentBuilder.updateUniform("resolution",t),this.threeRenderer.setRenderTarget(this.sceneTarget),this.threeRenderer.render(this.threeScene,this.camera.threeCamera),this.threeRenderer.setRenderTarget(this.accWriteTarget),ue.uniforms.accTex.value=this.accReadTarget.texture,ue.uniforms.newTex.value=this.sceneTarget.texture,ue.uniforms.iFrame.value=this.iFrame,pe.render(this.threeRenderer),e=this.accReadTarget,this.accReadTarget=this.accWriteTarget,this.accWriteTarget=e,this.renderAccTarget(),this.iFrame=this.iFrame+1}}const fe=(e=>{var t={};return a.d(t,e),t})({default:()=>t.default});function ve(e,t){return function(){return t.apply(e,arguments)}}function ge(e){return e.replace(/\W/g,"_")}o.Vector3.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}]`},o.Vector4.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},o.Matrix3.prototype.toLog=function(){let e="\r\n";for(let t=0;t<3;t++){for(let n=0;n<3;n++)0!==n&&(e+=",\t"),e+=this.elements[t+3*n];e+="\r\n"}return e},o.Matrix3.prototype.power=function(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}},o.Matrix4.prototype.toLog=function(){let e="\r\n";for(let t=0;t<4;t++){for(let n=0;n<4;n++)0!==n&&(e+=",\t"),e+=this.elements[t+4*n];e+="\r\n"}return e},o.Matrix4.prototype.add=function(e){return this.set.apply(this,[].map.call(this.elements,(function(t,n){return t+e.elements[n]}))),this},o.Quaternion.prototype.toLog=function(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`},o.Quaternion.prototype.multiplyScalar=function(e){return this.set(e*this.x,e*this.y,e*this.z,e*this.w),this},o.Quaternion.prototype.add=function(e){return this.set(this.x+e.x,this.y+e.y,this.z+e.z,this.w+e.w),this};const ye=0,xe=1;class we extends C{constructor(e,t,n,r,o,s={},a={}){new fe.default,super(e,t,n,r,o,s,a),this.threeRenderer.xr.enabled=!0,this.threeRenderer.xr.setReferenceSpaceType("local"),this.camera.threeCamera.layers.enable(1);const i=class{static createButton(e,t){t&&console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');const n=document.createElement("button");function r(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null,n.textContent="VR NOT SUPPORTED"}function o(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return n.id="VRButton",n.style.display="none",o(n),navigator.xr.isSessionSupported("immersive-vr").then((function(t){t?function(){let t=null;async function r(r){r.addEventListener("end",o),await e.xr.setSession(r),n.textContent="EXIT VR",t=r}function o(){t.removeEventListener("end",o),n.textContent="ENTER VR",t=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="ENTER VR",n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){if(null===t){const e={optionalFeatures:["local-floor","bounded-floor","hand-tracking"]};navigator.xr.requestSession("immersive-vr",e).then(r)}else t.end()}}():r()})),n;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",o(e),e}}}.createButton(this.threeRenderer),l=ve(this.camera,this.camera.switchStereo);i.addEventListener("click",l,!1),document.body.appendChild(i),this._fragmentBuilder=[new M,new M]}get isVRRenderer(){return!0}get xr(){return this.threeRenderer.xr}buildFragmentShader(){for(const e of[ye,xe])this._fragmentBuilder[e].addChunk(P()),this._fragmentBuilder[e].addUniform("maxBounces","int",this.maxBounces),this._fragmentBuilder[e].addChunk(this.shader1),this._fragmentBuilder[e].addChunk(k()),this._fragmentBuilder[e].addChunk(this.shader2),this._fragmentBuilder[e].addChunk(B()),this._fragmentBuilder[e].addChunk(j()),this.set.shader(this._fragmentBuilder[e]),this.camera.sidedShader(this._fragmentBuilder[e],e),this.scene.shader(this._fragmentBuilder[e]),this._fragmentBuilder[e].addChunk(O()(this)),this._fragmentBuilder[e].addChunk(z()(this)),this._fragmentBuilder[e].addChunk(F()),this._fragmentBuilder[e].addChunk(K())}build(){const e=new o.SphereBufferGeometry(1e3,60,40);e.scale(1,1,-1),this.buildFragmentShader();const t=new o.ShaderMaterial({uniforms:this._fragmentBuilder[ye].uniforms,vertexShader:E(),fragmentShader:this._fragmentBuilder[ye].code}),n=new o.ShaderMaterial({uniforms:this._fragmentBuilder[xe].uniforms,vertexShader:E(),fragmentShader:this._fragmentBuilder[xe].code}),r=new o.Mesh(e,t),s=new o.Mesh(e,n);r.layers.set(1),s.layers.set(2),this.threeScene.add(r,s)}checkShader(e=ye){console.log(this._fragmentBuilder[e].code)}render(){this.camera.chaseThreeCamera(this.threeRenderer.xr),this.threeRenderer.render(this.threeScene,this.camera.threeCamera)}}function Te(e,t,n){return class extends e{constructor(){super(t,n,...arguments)}}}const Se=(e=>{var t={};return a.d(t,e),t})({GUI:()=>n.GUI});const Re=(e=>{var t={};return a.d(t,e),t})({default:()=>r.default});class Ve{constructor(e){this.group=e,this.uuid=o.MathUtils.generateUUID().replaceAll("-","_")}get name(){return void 0===this._name&&(this._name=`groupElement_${this.uuid}`),this._name}identity(){throw new Error("GroupElement: This method need be overloaded.")}multiply(e){throw new Error("GroupElement: This method need be overloaded.")}premultiply(e){throw new Error("GroupElement: This method need be overloaded.")}invert(){throw new Error("GroupElement: This method need be overloaded.")}toIsometry(){throw new Error("GroupElement: This method need be overloaded.")}equals(e){throw new Error("GroupElement: This method need be overloaded.")}clone(){throw new Error("GroupElement: This method need be overloaded.")}copy(e){throw new Error("GroupElement: This method need be overloaded.")}}class _e{constructor(e){this.local=new h,this.set=e,this.cellBoost=this.set.group.element(),this.invCellBoost=this.set.group.element()}reduceErrorBoost(){return this.local.reduceErrorBoost(),this}reduceErrorFacing(){return this.local.reduceErrorFacing(),this}reduceErrorLocal(){return this.local.reduceError(),this}reduceError(){return this.reduceErrorLocal(),this}get facing(){return this.local.facing}get localPoint(){return this.local.point}get point(){return this.local.point.applyIsometry(this.cellBoost.toIsometry())}get globalBoost(){return this.cellBoost.toIsometry().multiply(this.local.boost)}get globalPosition(){const e=new h;return e.boost.copy(this.globalBoost),e.quaternion.copy(this.local.quaternion),e}reset(){this.local.reset(),this.cellBoost.identity(),this.invCellBoost.identity()}applyQuaternion(e){return this.local.applyQuaternion(e),this}teleport(){let e,t;for(;;){t=this.localPoint,e=!0;for(const n of this.set.teleportations)if(e=e&&!n.jsTest(t),!e){this.local.applyIsometry(n.elt.toIsometry()),this.cellBoost.multiply(n.inv),this.invCellBoost.premultiply(n.elt);break}if(e)break}return this}flow(e){return this.local.flow(e),this.teleport(),this}fakeDiffExpMap(e){return this.local.fakeDiffExpMap(e),this}equals(e){let t=!0;return t=t&&this.local.equals(e.local),t=t&&this.cellBoost.equals(e.cellBoost),t}clone(){let e=new _e(this.set);return e.cellBoost.copy(this.cellBoost),e.invCellBoost.copy(this.invCellBoost),e.local.copy(this.local),e}copy(e){this.cellBoost.copy(e.cellBoost),this.invCellBoost.copy(e.invCellBoost),this.local.copy(e.local)}}const Ce={us:{a:"yawLeft",d:"yawRight",w:"pitchUp",s:"pitchDown",q:"rollLeft",e:"rollRight",ArrowUp:"forward",ArrowDown:"back",ArrowLeft:"left",ArrowRight:"right","'":"up","/":"down"},fr:{q:"yawLeft",d:"yawRight",z:"pitchUp",s:"pitchDown",a:"rollLeft",e:"rollRight",ArrowUp:"forward",ArrowDown:"back",ArrowLeft:"left",ArrowRight:"right",:"up","=":"down"}};class Me extends o.EventDispatcher{constructor(e,t="us"){super(),this.camera=e,this.keyboard=t,this.movementSpeed=.5,this.rollSpeed=.8,this._moveState={up:0,down:0,left:0,right:0,forward:0,back:0,pitchUp:0,pitchDown:0,yawLeft:0,yawRight:0,rollLeft:0,rollRight:0},this._moveVector=new c(0,0,0),this._rotationVector=new c(0,0,0),this._onKeyDown=ve(this,this.onKeyDown),this._onKeyUp=ve(this,this.onKeyUp),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}pause(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp)}restore(){window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}setKeyboard(e){this.keyboard=e}onKeyDown(e){if(e.key in Ce[this.keyboard]){const t=Ce[this.keyboard][e.key];this._moveState[t]=1,this.updateMovementVector(),this.updateRotationVector()}}onKeyUp(e){if(e.key in Ce[this.keyboard]){const t=Ce[this.keyboard][e.key];this._moveState[t]=0,this.updateMovementVector(),this.updateRotationVector()}}updateMovementVector(){this._moveVector.x=-this._moveState.left+this._moveState.right,this._moveVector.y=-this._moveState.down+this._moveState.up,this._moveVector.z=-this._moveState.forward+this._moveState.back}updateRotationVector(){this._rotationVector.x=-this._moveState.pitchDown+this._moveState.pitchUp,this._rotationVector.y=-this._moveState.yawRight+this._moveState.yawLeft,this._rotationVector.z=-this._moveState.rollRight+this._moveState.rollLeft}update(e){const t=this._moveVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix);this.camera.position.flow(t);const n=this._rotationVector.clone().multiplyScalar(this.movementSpeed*e).applyMatrix4(this.camera.matrix),r=new o.Quaternion(n.x,n.y,n.z,1).normalize();this.camera.position.applyQuaternion(r)}}var Ie=a(7591),Ee=a.n(Ie),De=a(1685),Pe=a.n(De);class Le{constructor(e){this.threeCamera=new o.PerspectiveCamera(void 0!==e.fov?e.fov:70,window.innerWidth/window.innerHeight,.01,2e3),this.threeCamera.position.set(0,0,0),this.threeCamera.lookAt(0,0,-1),this.minDist=void 0!==e.minDist?e.minDist:0,this.maxDist=void 0!==e.maxDist?e.maxDist:50,this.maxSteps=void 0!==e.maxSteps?e.maxSteps:100,this.threshold=void 0!==e.threshold?e.threshold:1e-4,this.position=new _e(e.set)}set aspect(e){this.threeCamera.aspect=e}get fov(){return this.threeCamera.fov}set fov(e){this.threeCamera.fov=e,this.threeCamera.updateProjectionMatrix()}get matrix(){return this.threeCamera.matrixWorld}updateProjectionMatrix(){this.threeCamera.updateProjectionMatrix()}shader(e){e.addClass("Camera",Ee()),e.addUniform("camera","Camera",this),e.addChunk(Pe())}}var ke=a(6539),Ae=a.n(ke),Be=a(5074),Ne=a.n(Be);class Fe extends Le{constructor(e){super(e),this.isStereoOn=!1,this.ipDist=void 0!==e.ipDist?e.ipDist:.03200000151991844,this.fakeCameras=[];for(const e in[ye,xe])this.fakeCameras[e]={fov:this.fov,minDist:this.minDist,maxDist:this.maxDist,maxSteps:this.maxSteps,threshold:this.threshold,position:this.position.clone(),matrix:this.matrix}}get isStereoOff(){return!this.isStereoOn}switchStereo(){this.isStereoOn=!this.isStereoOn}updateFakeCamerasPosition(){if(this.fakeCameras[ye].position.copy(this.position),this.fakeCameras[xe].position.copy(this.position),this.isStereoOn){const e=new c(1,0,0).multiplyScalar(this.ipDist).applyMatrix4(this.matrix),t=e.clone().negate();this.fakeCameras[xe].position.flow(e),this.fakeCameras[ye].position.flow(t)}}get chaseThreeCamera(){if(void 0===this._chaseThreeCamera){const e=new c;this._chaseThreeCamera=function(t){const n=new c;if(this.isStereoOn){const e=t.getCamera(this.threeCamera).cameras,r=(new o.Vector3).setFromMatrixPosition(e[ye].matrixWorld),s=(new o.Vector3).setFromMatrixPosition(e[xe].matrixWorld);n.lerpVectors(r,s,.5)}else n.setFromMatrixPosition(this.matrix);const r=(new c).subVectors(n,e);this.position.flow(r),this.updateFakeCamerasPosition(),e.copy(n)}}return this._chaseThreeCamera}shader(e){throw new Error("StereoCamera: for stereographic cameras, use sidedShader instead")}sidedShader(e,t){e.addClass("VRCamera",Ae()),e.addUniform("camera","VRCamera",this.fakeCameras[t]),e.addChunk(Ne())}}var Ue=a(766),Oe=a.n(Ue),Ge=a(4651),je=a.n(Ge);class He extends Le{constructor(e){super(e),this.focalLength=void 0!==e.focalLength?e.focalLength:1,this.aperture=void 0!==e.aperture?e.aperture:0}shader(e){e.addClass("Camera",Oe()),e.addUniform("camera","PathTracerCamera",this),e.addChunk(je())}}class ze{constructor(){this.uuid=o.MathUtils.generateUUID().replaceAll("-","_"),this.id=void 0,this.imports=[]}get className(){return this.constructor.name}get name(){return void 0===this._name&&(this._name=`${ge(this.className)}_${this.uuid}`),this._name}get uniformType(){return""}setId(e){this.id=e.nextId,e.nextId=e.nextId+1}onAdd(e){}addImport(e){for(const e of arguments)this.imports.push(e)}static glslClass(){throw new Error("Generic: this function should be implemented")}glslInstance(){throw new Error("Generic: this function should be implemented")}shader(e){for(const t of this.imports)e.addImport(t);e.addClass(this.constructor.name,this.constructor.glslClass()),""!==this.uniformType&&e.addUniform(this.name,this.uniformType,this),e.addInstance(this.name,this.glslInstance())}}class We extends ze{constructor(){super(),this.lights=void 0,this.reflectivity=void 0}get isMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}onAdd(e){this.usesLight&&(this.hasOwnProperty("lights")&&void 0!==this.lights||(this.lights=e.lights))}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}var qe=a(2664),Ke=a.n(qe),$e=a(8778),Xe=a.n($e);class Qe extends We{constructor(e){super(),this.color=e}get uniformType(){return"SingleColorMaterial"}get usesNormal(){return!1}static glslClass(){return Ke()}glslRender(){return Xe()(this)}}class Ye extends ze{constructor(){super()}get isPTMaterial(){return!0}get usesNormal(){return!0}get usesUVMap(){return!1}onAdd(e){}glslRender(){throw new Error("Material: this method should be implemented")}glslInstance(){return this.glslRender()}}var Ze=a(2143),Je=a.n(Ze),et=a(9606),tt=a.n(et),nt=a(5363),rt=a.n(nt);class ot extends Ye{constructor(e){super(),this.emission=void 0!==e.emission?e.emission:new o.Color(0,0,0),this.volumeEmission=void 0!==e.volumeEmission?e.volumeEmission:new o.Color(0,0,0),this.opticalDepth=void 0!==e.opticalDepth?e.opticalDepth:1e3,this.diffuse=void 0!==e.diffuse?e.diffuse:new o.Color(1,1,1),this.specular=void 0!==e.specular?e.specular:new o.Color(1,1,1),this.absorb=void 0!==e.absorb?e.absorb:new o.Color(.1,.1,.1),this.ior=void 0!==e.ior?e.ior:1,this.roughness=void 0!==e.roughness?e.roughness:.2,this.reflectionChance=void 0!==e.reflectionChance?e.reflectionChance:.1,this.refractionChance=void 0!==e.refractionChance?e.refractionChance:0,this.diffuseChance=void 0!==e.diffuseChance?e.diffuseChance:.9;const t=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/t,this.refractionChance=this.refractionChance/t,this.diffuseChance=this.diffuseChance/t,this.addImport(rt())}get uniformType(){return"BasicPTMaterial"}static glslClass(){return Je()}glslRender(){return tt()(this)}}class st{constructor(e={}){this.lights=[],this.solids=[],this.nextId=0,this.fog=e.fog,this.background=void 0!==e.background?e.background:new Qe(new o.Color(0,0,0)),this.ptBackground=void 0!==e.ptBackground?e.ptBackground:new ot({diffuse:new o.Color(0,0,0),specular:new o.Color(0,0,0),absorb:new o.Color(.25,.25,.25)})}_add(e){return e.setId(this),e.onAdd(this),e.isLight&&this.lights.push(e),e.isSolid&&this.solids.push(e),this}add(e){for(const e of arguments)this._add(e);return this}shader(e){3===e.useCase?this.ptBackground.shader(e):this.background.shader(e);for(const t of this.lights)3!==e.useCase&&t.shader(e);for(const t of this.solids)t.shader(e);void 0!==this.fog&&this.fog.shader(e)}}class at{constructor(){}shader(e){throw new Error("Fog: this method need be implemented")}}var it=a(7885),lt=a.n(it),ct=a(5348),ht=a.n(ct);class dt extends at{constructor(e,t){super(),this.color=e,this.scattering=t}shader(e){e.addClass("ExpFog",lt()),e.addUniform("fog","ExpFog",this),e.addChunk(ht())}}class ut{constructor(e){this.thurston=e,this.state=0,this.dialogBoxWrap=document.getElementById("thurstonDialogBoxWrap"),this.downloadButton=document.getElementById("thurstonDownloadButton");const t=ve(this,this.onPressP);window.addEventListener("keydown",t);const n=ve(this,this.onClickGo);document.querySelector("#thurstonDialogBox input[type=submit]").addEventListener("click",n);const r=ve(this,this.onClickDownload);document.getElementById("thurstonDownloadButton").addEventListener("click",r)}onPressP(e){if("p"===e.key)switch(this.state){case 0:document.getElementById("widthInput").value=window.innerWidth;document.getElementById("heightInput").value=window.innerHeight,this.dialogBoxWrap.classList.add("visible"),this.state=1;break;case 2:this.downloadButton.classList.remove("visible"),this.thurston.setSize(window.innerWidth,window.innerHeight),this.thurston.switchRenderer(),this.state=0;break;default:this.dialogBoxWrap.classList.remove("visible"),this.state=0}}onClickGo(e){if(1===this.state){const e=document.getElementById("widthInput"),t=document.getElementById("heightInput");this.thurston.setSize(e.value,t.value),this.thurston.ptCamera.aspect=e.value/t.value,this.thurston.ptCamera.updateProjectionMatrix(),this.dialogBoxWrap.classList.remove("visible"),this.downloadButton.classList.add("visible"),this.thurston.switchRenderer(),this.state=2}}onClickDownload(e){2===this.state&&(this.thurston.ptRenderer.renderAccTarget(),this.downloadButton.href=this.thurston.ptRenderer.domElement.toDataURL("image/png",1),this.downloadButton.download="export.png")}}const pt="\n    #thurstonDialogBoxWrap {\n        margin: 0;\n        background: rgba(0, 0, 0, 0.8);\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        visibility: hidden;\n    }\n\n    #thurstonDialogBox {\n        background: #9b9b9b;\n        opacity: 1;\n        width: 300px;\n        margin-top: 100px;\n        margin-left: auto;\n        margin-right: auto;\n        padding: 20px;\n    }\n\n    #thurstonDownloadButton {\n        display: block;\n        position: fixed;\n        bottom: 0;\n        right: 0;\n        padding: 10px;\n        background: black;\n        color: white;\n        visibility: hidden;\n    }\n\n    #thurstonDialogBoxWrap.visible,\n    #thurstonDownloadButton.visible {\n        visibility: visible;\n    }\n";class mt extends o.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new yt(e)})),this.register((function(e){return new wt(e)})),this.register((function(e){return new Tt(e)})),this.register((function(e){return new xt(e)})),this.register((function(e){return new vt(e)})),this.register((function(e){return new St(e)}))}load(e,t,n,r){const s=this;let a;a=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:o.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const i=function(t){r?r(t):console.error(t),s.manager.itemError(e),s.manager.itemEnd(e)},l=new o.FileLoader(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,(function(n){try{s.parse(n,a,(function(n){t(n),s.manager.itemEnd(e)}),i)}catch(e){i(e)}}),n,i)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,r){let s;const a={},i={};if("string"==typeof e)s=e;else{if(o.LoaderUtils.decodeText(new Uint8Array(e,0,4))===Rt){try{a[ft.KHR_BINARY_GLTF]=new Ct(e)}catch(e){return void(r&&r(e))}s=a[ft.KHR_BINARY_GLTF].content}else s=o.LoaderUtils.decodeText(new Uint8Array(e))}const l=JSON.parse(s);if(void 0===l.asset||l.asset.version[0]<2)return void(r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=new on(l,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){const t=this.pluginCallbacks[e](c);i[t.name]=t,a[t.name]=!0}if(l.extensionsUsed)for(let e=0;e<l.extensionsUsed.length;++e){const t=l.extensionsUsed[e],n=l.extensionsRequired||[];switch(t){case ft.KHR_MATERIALS_UNLIT:a[t]=new gt;break;case ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:a[t]=new Dt;break;case ft.KHR_DRACO_MESH_COMPRESSION:a[t]=new Mt(l,this.dracoLoader);break;case ft.KHR_TEXTURE_TRANSFORM:a[t]=new It;break;case ft.KHR_MESH_QUANTIZATION:a[t]=new Pt;break;default:n.indexOf(t)>=0&&void 0===i[t]&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}c.setExtensions(a),c.setPlugins(i),c.parse(n,r)}}function bt(){let e={};return{get:function(t){return e[t]},add:function(t,n){e[t]=n},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const ft={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class vt{constructor(e){this.parser=e,this.name=ft.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,r=t.length;n<r;n++){const r=t[n];r.extensions&&r.extensions[this.name]&&void 0!==r.extensions[this.name].light&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let r=t.cache.get(n);if(r)return r;const s=t.json,a=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let i;const l=new o.Color(16777215);void 0!==a.color&&l.fromArray(a.color);const c=void 0!==a.range?a.range:0;switch(a.type){case"directional":i=new o.DirectionalLight(l),i.target.position.set(0,0,-1),i.add(i.target);break;case"point":i=new o.PointLight(l),i.distance=c;break;case"spot":i=new o.SpotLight(l),i.distance=c,a.spot=a.spot||{},a.spot.innerConeAngle=void 0!==a.spot.innerConeAngle?a.spot.innerConeAngle:0,a.spot.outerConeAngle=void 0!==a.spot.outerConeAngle?a.spot.outerConeAngle:Math.PI/4,i.angle=a.spot.outerConeAngle,i.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,i.target.position.set(0,0,-1),i.add(i.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return i.position.set(0,0,0),i.decay=2,void 0!==a.intensity&&(i.intensity=a.intensity),i.name=t.createUniqueName(a.name||"light_"+e),r=Promise.resolve(i),t.cache.add(n,r),r}createNodeAttachment(e){const t=this,n=this.parser,r=n.json.nodes[e],o=(r.extensions&&r.extensions[this.name]||{}).light;return void 0===o?null:this._loadLight(o).then((function(e){return n._getNodeRef(t.cache,o,e)}))}}class gt{constructor(){this.name=ft.KHR_MATERIALS_UNLIT}getMaterialType(){return o.MeshBasicMaterial}extendParams(e,t,n){const r=[];e.color=new o.Color(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const t=s.baseColorFactor;e.color.fromArray(t),e.opacity=t[3]}void 0!==s.baseColorTexture&&r.push(n.assignTexture(e,"map",s.baseColorTexture))}return Promise.all(r)}}class yt{constructor(e){this.parser=e,this.name=ft.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?o.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],a=r.extensions[this.name];if(void 0!==a.clearcoatFactor&&(t.clearcoat=a.clearcoatFactor),void 0!==a.clearcoatTexture&&s.push(n.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),void 0!==a.clearcoatRoughnessFactor&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),void 0!==a.clearcoatRoughnessTexture&&s.push(n.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),void 0!==a.clearcoatNormalTexture&&(s.push(n.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),void 0!==a.clearcoatNormalTexture.scale)){const e=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new o.Vector2(e,-e)}return Promise.all(s)}}class xt{constructor(e){this.parser=e,this.name=ft.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?o.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const o=[],s=r.extensions[this.name];return void 0!==s.transmissionFactor&&(t.transmission=s.transmissionFactor),void 0!==s.transmissionTexture&&o.push(n.assignTexture(t,"transmissionMap",s.transmissionTexture)),Promise.all(o)}}class wt{constructor(e){this.parser=e,this.name=ft.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,r=n.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const o=r.extensions[this.name],s=n.images[o.source],a=t.options.ktx2Loader;if(!a){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s,a)}}class Tt{constructor(e){this.parser=e,this.name=ft.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,r=n.json,o=r.textures[e];if(!o.extensions||!o.extensions[t])return null;const s=o.extensions[t],a=r.images[s.source];let i=n.textureLoader;if(a.uri){const e=n.options.manager.getHandler(a.uri);null!==e&&(i=e)}return this.detectSupport().then((function(o){if(o)return n.loadTextureImage(e,a,i);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}}))),this.isSupported}}class St{constructor(e){this.name=ft.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const e=n.extensions[this.name],r=this.parser.getDependency("buffer",e.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([r,o.ready]).then((function(t){const n=e.byteOffset||0,r=e.byteLength||0,s=e.count,a=e.byteStride,i=new ArrayBuffer(s*a),l=new Uint8Array(t[0],n,r);return o.decodeGltfBuffer(new Uint8Array(i),s,a,l,e.mode,e.filter),i}))}return null}}const Rt="glTF",Vt=1313821514,_t=5130562;class Ct{constructor(e){this.name=ft.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12);if(this.header={magic:o.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Rt)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-12,r=new DataView(e,12);let s=0;for(;s<n;){const t=r.getUint32(s,!0);s+=4;const n=r.getUint32(s,!0);if(s+=4,n===Vt){const n=new Uint8Array(e,12+s,t);this.content=o.LoaderUtils.decodeText(n)}else if(n===_t){const n=12+s;this.body=e.slice(n,n+t)}s+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Mt{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ft.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,r=this.dracoLoader,o=e.extensions[this.name].bufferView,s=e.extensions[this.name].attributes,a={},i={},l={};for(const e in s){const t=Wt[e]||e.toLowerCase();a[t]=s[e]}for(const t in e.attributes){const r=Wt[t]||t.toLowerCase();if(void 0!==s[t]){const o=n.accessors[e.attributes[t]],s=Gt[o.componentType];l[r]=s,i[r]=!0===o.normalized}}return t.getDependency("bufferView",o).then((function(e){return new Promise((function(t){r.decodeDracoFile(e,(function(e){for(const t in e.attributes){const n=e.attributes[t],r=i[t];void 0!==r&&(n.normalized=r)}t(e)}),a,l)}))}))}}class It{constructor(){this.name=ft.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===t.offset&&void 0===t.rotation&&void 0===t.scale||(e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Et extends o.MeshStandardMaterial{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),n=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),r=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\ttexelSpecular = sRGBToLinear( texelSpecular );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),s=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),a=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),i={specular:{value:(new o.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=i,this.onBeforeCompile=function(e){for(const t in i)e.uniforms[t]=i[t];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",r).replace("#include <metalnessmap_fragment>",s).replace("#include <lights_physical_fragment>",a)},Object.defineProperties(this,{specular:{get:function(){return i.specular.value},set:function(e){i.specular.value=e}},specularMap:{get:function(){return i.specularMap.value},set:function(e){i.specularMap.value=e,e?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return i.glossiness.value},set:function(e){i.glossiness.value=e}},glossinessMap:{get:function(){return i.glossinessMap.value},set:function(e){i.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class Dt{constructor(){this.name=ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return Et}extendParams(e,t,n){const r=t.extensions[this.name];e.color=new o.Color(1,1,1),e.opacity=1;const s=[];if(Array.isArray(r.diffuseFactor)){const t=r.diffuseFactor;e.color.fromArray(t),e.opacity=t[3]}if(void 0!==r.diffuseTexture&&s.push(n.assignTexture(e,"map",r.diffuseTexture)),e.emissive=new o.Color(0,0,0),e.glossiness=void 0!==r.glossinessFactor?r.glossinessFactor:1,e.specular=new o.Color(1,1,1),Array.isArray(r.specularFactor)&&e.specular.fromArray(r.specularFactor),void 0!==r.specularGlossinessTexture){const t=r.specularGlossinessTexture;s.push(n.assignTexture(e,"glossinessMap",t)),s.push(n.assignTexture(e,"specularMap",t))}return Promise.all(s)}createMaterial(e){const t=new Et(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=o.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}class Pt{constructor(){this.name=ft.KHR_MESH_QUANTIZATION}}class Lt extends o.Interpolant{constructor(e,t,n,r){super(e,t,n,r)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,o=e*r*3+r;for(let e=0;e!==r;e++)t[e]=n[o+e];return t}}Lt.prototype.beforeStart_=Lt.prototype.copySampleValue_,Lt.prototype.afterEnd_=Lt.prototype.copySampleValue_,Lt.prototype.interpolate_=function(e,t,n,r){const o=this.resultBuffer,s=this.sampleValues,a=this.valueSize,i=2*a,l=3*a,c=r-t,h=(n-t)/c,d=h*h,u=d*h,p=e*l,m=p-l,b=-2*u+3*d,f=u-d,v=1-b,g=f-d+h;for(let e=0;e!==a;e++){const t=s[m+e+a],n=s[m+e+i]*c,r=s[p+e+a],l=s[p+e]*c;o[e]=v*t+g*n+b*r+f*l}return o};const kt=0,At=1,Bt=2,Nt=3,Ft=4,Ut=5,Ot=6,Gt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},jt={9728:o.NearestFilter,9729:o.LinearFilter,9984:o.NearestMipmapNearestFilter,9985:o.LinearMipmapNearestFilter,9986:o.NearestMipmapLinearFilter,9987:o.LinearMipmapLinearFilter},Ht={33071:o.ClampToEdgeWrapping,33648:o.MirroredRepeatWrapping,10497:o.RepeatWrapping},zt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Wt={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},qt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Kt={CUBICSPLINE:void 0,LINEAR:o.InterpolateLinear,STEP:o.InterpolateDiscrete},$t="OPAQUE",Xt="MASK",Qt="BLEND";function Yt(e,t){return"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}function Zt(e,t,n){for(const r in n.extensions)void 0===e[r]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[r]=n.extensions[r])}function Jt(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function en(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let n=0,r=t.weights.length;n<r;n++)e.morphTargetInfluences[n]=t.weights[n];if(t.extras&&Array.isArray(t.extras.targetNames)){const n=t.extras.targetNames;if(e.morphTargetInfluences.length===n.length){e.morphTargetDictionary={};for(let t=0,r=n.length;t<r;t++)e.morphTargetDictionary[n[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function tn(e){const t=e.extensions&&e.extensions[ft.KHR_DRACO_MESH_COMPRESSION];let n;return n=t?"draco:"+t.bufferView+":"+t.indices+":"+nn(t.attributes):e.indices+":"+nn(e.attributes)+":"+e.mode,n}function nn(e){let t="";const n=Object.keys(e).sort();for(let r=0,o=n.length;r<o;r++)t+=n[r]+":"+e[n[r]]+";";return t}function rn(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class on{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new bt,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.textureCache={},this.nodeNamesUsed={},"undefined"!=typeof createImageBitmap&&!1===/Firefox/.test(navigator.userAgent)?this.textureLoader=new o.ImageBitmapLoader(this.options.manager):this.textureLoader=new o.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new o.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,r=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])})).then((function(t){const s={scene:t[0][r.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:r.asset,parser:n,userData:{}};Zt(o,s,r),Jt(s,r),Promise.all(n._invokeAll((function(e){return e.afterRoot&&e.afterRoot(s)}))).then((function(){e(s)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const r=t[n].joints;for(let t=0,n=r.length;t<n;t++)e[r[t]].isBone=!0}for(let t=0,r=e.length;t<r;t++){const r=e[t];void 0!==r.mesh&&(this._addNodeRef(this.meshCache,r.mesh),void 0!==r.skin&&(n[r.mesh].isSkinnedMesh=!0)),void 0!==r.camera&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const r=n.clone();return r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const r=e(t[n]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let r=0;r<t.length;r++){const o=e(t[r]);o&&n.push(o)}return n}getDependency(e,t){const n=e+":"+t;let r=this.cache.get(n);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this.loadNode(t);break;case"mesh":r=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":r=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":r=this.loadSkin(t);break;case"animation":r=this.loadAnimation(t);break;case"camera":r=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(n,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,r=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(r.map((function(t,r){return n.getDependency(e,r)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[ft.KHR_BINARY_GLTF].body);const r=this.options;return new Promise((function(e,o){n.load(Yt(t.uri,r.path),e,void 0,(function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const n=t.byteLength||0,r=t.byteOffset||0;return e.slice(r,r+n)}))}loadAccessor(e){const t=this,n=this.json,r=this.json.accessors[e];if(void 0===r.bufferView&&void 0===r.sparse)return Promise.resolve(null);const s=[];return void 0!==r.bufferView?s.push(this.getDependency("bufferView",r.bufferView)):s.push(null),void 0!==r.sparse&&(s.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(s).then((function(e){const s=e[0],a=zt[r.type],i=Gt[r.componentType],l=i.BYTES_PER_ELEMENT,c=l*a,h=r.byteOffset||0,d=void 0!==r.bufferView?n.bufferViews[r.bufferView].byteStride:void 0,u=!0===r.normalized;let p,m;if(d&&d!==c){const e=Math.floor(h/d),n="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+e+":"+r.count;let c=t.cache.get(n);c||(p=new i(s,e*d,r.count*d/l),c=new o.InterleavedBuffer(p,d/l),t.cache.add(n,c)),m=new o.InterleavedBufferAttribute(c,a,h%d/l,u)}else p=null===s?new i(r.count*a):new i(s,h,r.count*a),m=new o.BufferAttribute(p,a,u);if(void 0!==r.sparse){const t=zt.SCALAR,n=Gt[r.sparse.indices.componentType],l=r.sparse.indices.byteOffset||0,c=r.sparse.values.byteOffset||0,h=new n(e[1],l,r.sparse.count*t),d=new i(e[2],c,r.sparse.count*a);null!==s&&(m=new o.BufferAttribute(m.array.slice(),m.itemSize,m.normalized));for(let e=0,t=h.length;e<t;e++){const t=h[e];if(m.setX(t,d[e*a]),a>=2&&m.setY(t,d[e*a+1]),a>=3&&m.setZ(t,d[e*a+2]),a>=4&&m.setW(t,d[e*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m}))}loadTexture(e){const t=this.json,n=this.options,r=t.textures[e],o=t.images[r.source];let s=this.textureLoader;if(o.uri){const e=n.manager.getHandler(o.uri);null!==e&&(s=e)}return this.loadTextureImage(e,o,s)}loadTextureImage(e,t,n){const r=this,s=this.json,a=this.options,i=s.textures[e],l=(t.uri||t.bufferView)+":"+i.sampler;if(this.textureCache[l])return this.textureCache[l];const c=self.URL||self.webkitURL;let h=t.uri||"",d=!1,u=!0;const p=h.search(/\.jpe?g($|\?)/i)>0||0===h.search(/^data\:image\/jpeg/);if(("image/jpeg"===t.mimeType||p)&&(u=!1),void 0!==t.bufferView)h=r.getDependency("bufferView",t.bufferView).then((function(e){if("image/png"===t.mimeType){const t=new DataView(e,25,1).getUint8(0,!1);u=6===t||4===t||3===t}d=!0;const n=new Blob([e],{type:t.mimeType});return h=c.createObjectURL(n),h}));else if(void 0===t.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const m=Promise.resolve(h).then((function(e){return new Promise((function(t,r){let s=t;!0===n.isImageBitmapLoader&&(s=function(e){t(new o.CanvasTexture(e))}),n.load(Yt(e,a.path),s,void 0,r)}))})).then((function(t){!0===d&&c.revokeObjectURL(h),t.flipY=!1,i.name&&(t.name=i.name),u||(t.format=o.RGBFormat);const n=(s.samplers||{})[i.sampler]||{};return t.magFilter=jt[n.magFilter]||o.LinearFilter,t.minFilter=jt[n.minFilter]||o.LinearMipmapLinearFilter,t.wrapS=Ht[n.wrapS]||o.RepeatWrapping,t.wrapT=Ht[n.wrapT]||o.RepeatWrapping,r.associations.set(t,{type:"textures",index:e}),t}));return this.textureCache[l]=m,m}assignTexture(e,t,n){const r=this;return this.getDependency("texture",n.index).then((function(o){if(void 0===n.texCoord||0==n.texCoord||"aoMap"===t&&1==n.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+t+" not yet supported."),r.extensions[ft.KHR_TEXTURE_TRANSFORM]){const e=void 0!==n.extensions?n.extensions[ft.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=r.associations.get(o);o=r.extensions[ft.KHR_TEXTURE_TRANSFORM].extendTexture(o,e),r.associations.set(o,t)}}e[t]=o}))}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const r=void 0!==t.attributes.tangent,s=void 0!==t.attributes.color,a=void 0===t.attributes.normal,i=Object.keys(t.morphAttributes).length>0,l=i&&void 0!==t.morphAttributes.normal;if(e.isPoints){const e="PointsMaterial:"+n.uuid;let t=this.cache.get(e);t||(t=new o.PointsMaterial,o.Material.prototype.copy.call(t,n),t.color.copy(n.color),t.map=n.map,t.sizeAttenuation=!1,this.cache.add(e,t)),n=t}else if(e.isLine){const e="LineBasicMaterial:"+n.uuid;let t=this.cache.get(e);t||(t=new o.LineBasicMaterial,o.Material.prototype.copy.call(t,n),t.color.copy(n.color),this.cache.add(e,t)),n=t}if(r||s||a||i){let e="ClonedMaterial:"+n.uuid+":";n.isGLTFSpecularGlossinessMaterial&&(e+="specular-glossiness:"),r&&(e+="vertex-tangents:"),s&&(e+="vertex-colors:"),a&&(e+="flat-shading:"),i&&(e+="morph-targets:"),l&&(e+="morph-normals:");let t=this.cache.get(e);t||(t=n.clone(),s&&(t.vertexColors=!0),a&&(t.flatShading=!0),i&&(t.morphTargets=!0),l&&(t.morphNormals=!0),r&&(t.vertexTangents=!0,t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(n))),n=t}n.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=n}getMaterialType(){return o.MeshStandardMaterial}loadMaterial(e){const t=this,n=this.json,r=this.extensions,s=n.materials[e];let a;const i={},l=s.extensions||{},c=[];if(l[ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const e=r[ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];a=e.getMaterialType(),c.push(e.extendParams(i,s,t))}else if(l[ft.KHR_MATERIALS_UNLIT]){const e=r[ft.KHR_MATERIALS_UNLIT];a=e.getMaterialType(),c.push(e.extendParams(i,s,t))}else{const n=s.pbrMetallicRoughness||{};if(i.color=new o.Color(1,1,1),i.opacity=1,Array.isArray(n.baseColorFactor)){const e=n.baseColorFactor;i.color.fromArray(e),i.opacity=e[3]}void 0!==n.baseColorTexture&&c.push(t.assignTexture(i,"map",n.baseColorTexture)),i.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,i.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(c.push(t.assignTexture(i,"metalnessMap",n.metallicRoughnessTexture)),c.push(t.assignTexture(i,"roughnessMap",n.metallicRoughnessTexture))),a=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),c.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,i)}))))}!0===s.doubleSided&&(i.side=o.DoubleSide);const h=s.alphaMode||$t;return h===Qt?(i.transparent=!0,i.depthWrite=!1):(i.transparent=!1,h===Xt&&(i.alphaTest=void 0!==s.alphaCutoff?s.alphaCutoff:.5)),void 0!==s.normalTexture&&a!==o.MeshBasicMaterial&&(c.push(t.assignTexture(i,"normalMap",s.normalTexture)),i.normalScale=new o.Vector2(1,-1),void 0!==s.normalTexture.scale&&i.normalScale.set(s.normalTexture.scale,-s.normalTexture.scale)),void 0!==s.occlusionTexture&&a!==o.MeshBasicMaterial&&(c.push(t.assignTexture(i,"aoMap",s.occlusionTexture)),void 0!==s.occlusionTexture.strength&&(i.aoMapIntensity=s.occlusionTexture.strength)),void 0!==s.emissiveFactor&&a!==o.MeshBasicMaterial&&(i.emissive=(new o.Color).fromArray(s.emissiveFactor)),void 0!==s.emissiveTexture&&a!==o.MeshBasicMaterial&&c.push(t.assignTexture(i,"emissiveMap",s.emissiveTexture)),Promise.all(c).then((function(){let n;return n=a===Et?r[ft.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(i):new a(i),s.name&&(n.name=s.name),n.map&&(n.map.encoding=o.sRGBEncoding),n.emissiveMap&&(n.emissiveMap.encoding=o.sRGBEncoding),Jt(n,s),t.associations.set(n,{type:"materials",index:e}),s.extensions&&Zt(r,n,s),n}))}createUniqueName(e){const t=o.PropertyBinding.sanitizeNodeName(e||"");let n=t;for(let e=1;this.nodeNamesUsed[n];++e)n=t+"_"+e;return this.nodeNamesUsed[n]=!0,n}loadGeometries(e){const t=this,n=this.extensions,r=this.primitiveCache;function s(e){return n[ft.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(n){return an(n,e,t)}))}const a=[];for(let n=0,i=e.length;n<i;n++){const i=e[n],l=tn(i),c=r[l];if(c)a.push(c.promise);else{let e;e=i.extensions&&i.extensions[ft.KHR_DRACO_MESH_COMPRESSION]?s(i):an(new o.BufferGeometry,i,t),r[l]={primitive:i,promise:e},a.push(e)}}return Promise.all(a)}loadMesh(e){const t=this,n=this.json,r=this.extensions,s=n.meshes[e],a=s.primitives,i=[];for(let e=0,t=a.length;e<t;e++){const t=void 0===a[e].material?(void 0===(l=this.cache).DefaultMaterial&&(l.DefaultMaterial=new o.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:o.FrontSide})),l.DefaultMaterial):this.getDependency("material",a[e].material);i.push(t)}var l;return i.push(t.loadGeometries(a)),Promise.all(i).then((function(n){const i=n.slice(0,n.length-1),l=n[n.length-1],c=[];for(let n=0,h=l.length;n<h;n++){const h=l[n],d=a[n];let u;const p=i[n];if(d.mode===Ft||d.mode===Ut||d.mode===Ot||void 0===d.mode)u=!0===s.isSkinnedMesh?new o.SkinnedMesh(h,p):new o.Mesh(h,p),!0!==u.isSkinnedMesh||u.geometry.attributes.skinWeight.normalized||u.normalizeSkinWeights(),d.mode===Ut?u.geometry=ln(u.geometry,o.TriangleStripDrawMode):d.mode===Ot&&(u.geometry=ln(u.geometry,o.TriangleFanDrawMode));else if(d.mode===At)u=new o.LineSegments(h,p);else if(d.mode===Nt)u=new o.Line(h,p);else if(d.mode===Bt)u=new o.LineLoop(h,p);else{if(d.mode!==kt)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+d.mode);u=new o.Points(h,p)}Object.keys(u.geometry.morphAttributes).length>0&&en(u,s),u.name=t.createUniqueName(s.name||"mesh_"+e),Jt(u,s),d.extensions&&Zt(r,u,d),t.assignFinalMaterial(u),c.push(u)}if(1===c.length)return c[0];const h=new o.Group;for(let e=0,t=c.length;e<t;e++)h.add(c[e]);return h}))}loadCamera(e){let t;const n=this.json.cameras[e],r=n[n.type];if(r)return"perspective"===n.type?t=new o.PerspectiveCamera(o.MathUtils.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):"orthographic"===n.type&&(t=new o.OrthographicCamera(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),Jt(t,n),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],n={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(n):this.getDependency("accessor",t.inverseBindMatrices).then((function(e){return n.inverseBindMatrices=e,n}))}loadAnimation(e){const t=this.json.animations[e],n=[],r=[],s=[],a=[],i=[];for(let e=0,o=t.channels.length;e<o;e++){const o=t.channels[e],l=t.samplers[o.sampler],c=o.target,h=void 0!==c.node?c.node:c.id,d=void 0!==t.parameters?t.parameters[l.input]:l.input,u=void 0!==t.parameters?t.parameters[l.output]:l.output;n.push(this.getDependency("node",h)),r.push(this.getDependency("accessor",d)),s.push(this.getDependency("accessor",u)),a.push(l),i.push(c)}return Promise.all([Promise.all(n),Promise.all(r),Promise.all(s),Promise.all(a),Promise.all(i)]).then((function(n){const r=n[0],s=n[1],a=n[2],i=n[3],l=n[4],c=[];for(let e=0,t=r.length;e<t;e++){const t=r[e],n=s[e],h=a[e],d=i[e],u=l[e];if(void 0===t)continue;let p;switch(t.updateMatrix(),t.matrixAutoUpdate=!0,qt[u.path]){case qt.weights:p=o.NumberKeyframeTrack;break;case qt.rotation:p=o.QuaternionKeyframeTrack;break;default:p=o.VectorKeyframeTrack}const m=t.name?t.name:t.uuid,b=void 0!==d.interpolation?Kt[d.interpolation]:o.InterpolateLinear,f=[];qt[u.path]===qt.weights?t.traverse((function(e){!0===e.isMesh&&e.morphTargetInfluences&&f.push(e.name?e.name:e.uuid)})):f.push(m);let v=h.array;if(h.normalized){const e=rn(v.constructor),t=new Float32Array(v.length);for(let n=0,r=v.length;n<r;n++)t[n]=v[n]*e;v=t}for(let e=0,t=f.length;e<t;e++){const t=new p(f[e]+"."+qt[u.path],n.array,v,b);"CUBICSPLINE"===d.interpolation&&(t.createInterpolant=function(e){return new Lt(this.times,this.values,this.getValueSize()/3,e)},t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),c.push(t)}}const h=t.name?t.name:"animation_"+e;return new o.AnimationClip(h,void 0,c)}))}createNodeMesh(e){const t=this.json,n=this,r=t.nodes[e];return void 0===r.mesh?null:n.getDependency("mesh",r.mesh).then((function(e){const t=n._getNodeRef(n.meshCache,r.mesh,e);return void 0!==r.weights&&t.traverse((function(e){if(e.isMesh)for(let t=0,n=r.weights.length;t<n;t++)e.morphTargetInfluences[t]=r.weights[t]})),t}))}loadNode(e){const t=this.json,n=this.extensions,r=this,s=t.nodes[e],a=s.name?r.createUniqueName(s.name):"";return function(){const t=[],n=r._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return n&&t.push(n),void 0!==s.camera&&t.push(r.getDependency("camera",s.camera).then((function(e){return r._getNodeRef(r.cameraCache,s.camera,e)}))),r._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){t.push(e)})),Promise.all(t)}().then((function(t){let i;if(i=!0===s.isBone?new o.Bone:t.length>1?new o.Group:1===t.length?t[0]:new o.Object3D,i!==t[0])for(let e=0,n=t.length;e<n;e++)i.add(t[e]);if(s.name&&(i.userData.name=s.name,i.name=a),Jt(i,s),s.extensions&&Zt(n,i,s),void 0!==s.matrix){const e=new o.Matrix4;e.fromArray(s.matrix),i.applyMatrix4(e)}else void 0!==s.translation&&i.position.fromArray(s.translation),void 0!==s.rotation&&i.quaternion.fromArray(s.rotation),void 0!==s.scale&&i.scale.fromArray(s.scale);return r.associations.set(i,{type:"nodes",index:e}),i}))}loadScene(e){const t=this.json,n=this.extensions,r=this.json.scenes[e],s=this,a=new o.Group;r.name&&(a.name=s.createUniqueName(r.name)),Jt(a,r),r.extensions&&Zt(n,a,r);const i=r.nodes||[],l=[];for(let e=0,n=i.length;e<n;e++)l.push(sn(i[e],a,t,s));return Promise.all(l).then((function(){return a}))}}function sn(e,t,n,r){const s=n.nodes[e];return r.getDependency("node",e).then((function(e){if(void 0===s.skin)return e;let t;return r.getDependency("skin",s.skin).then((function(e){t=e;const n=[];for(let e=0,o=t.joints.length;e<o;e++)n.push(r.getDependency("node",t.joints[e]));return Promise.all(n)})).then((function(n){return e.traverse((function(e){if(!e.isMesh)return;const r=[],s=[];for(let e=0,a=n.length;e<a;e++){const a=n[e];if(a){r.push(a);const n=new o.Matrix4;void 0!==t.inverseBindMatrices&&n.fromArray(t.inverseBindMatrices.array,16*e),s.push(n)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}e.bind(new o.Skeleton(r,s),e.matrixWorld)})),e}))})).then((function(e){t.add(e);const o=[];if(s.children){const t=s.children;for(let s=0,a=t.length;s<a;s++){const a=t[s];o.push(sn(a,e,n,r))}}return Promise.all(o)}))}function an(e,t,n){const r=t.attributes,s=[];function a(t,r){return n.getDependency("accessor",t).then((function(t){e.setAttribute(r,t)}))}for(const t in r){const n=Wt[t]||t.toLowerCase();n in e.attributes||s.push(a(r[t],n))}if(void 0!==t.indices&&!e.index){const r=n.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));s.push(r)}return Jt(e,t),function(e,t,n){const r=t.attributes,s=new o.Box3;if(void 0===r.POSITION)return;{const e=n.json.accessors[r.POSITION],t=e.min,a=e.max;if(void 0===t||void 0===a)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(s.set(new o.Vector3(t[0],t[1],t[2]),new o.Vector3(a[0],a[1],a[2])),e.normalized){const t=rn(Gt[e.componentType]);s.min.multiplyScalar(t),s.max.multiplyScalar(t)}}const a=t.targets;if(void 0!==a){const e=new o.Vector3,t=new o.Vector3;for(let r=0,o=a.length;r<o;r++){const o=a[r];if(void 0!==o.POSITION){const r=n.json.accessors[o.POSITION],s=r.min,a=r.max;if(void 0!==s&&void 0!==a){if(t.setX(Math.max(Math.abs(s[0]),Math.abs(a[0]))),t.setY(Math.max(Math.abs(s[1]),Math.abs(a[1]))),t.setZ(Math.max(Math.abs(s[2]),Math.abs(a[2]))),r.normalized){const e=rn(Gt[r.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(e)}e.boundingBox=s;const i=new o.Sphere;s.getCenter(i.center),i.radius=s.min.distanceTo(s.max)/2,e.boundingSphere=i}(e,t,n),Promise.all(s).then((function(){return void 0!==t.targets?function(e,t,n){let r=!1,o=!1;for(let e=0,n=t.length;e<n;e++){const n=t[e];if(void 0!==n.POSITION&&(r=!0),void 0!==n.NORMAL&&(o=!0),r&&o)break}if(!r&&!o)return Promise.resolve(e);const s=[],a=[];for(let i=0,l=t.length;i<l;i++){const l=t[i];if(r){const t=void 0!==l.POSITION?n.getDependency("accessor",l.POSITION):e.attributes.position;s.push(t)}if(o){const t=void 0!==l.NORMAL?n.getDependency("accessor",l.NORMAL):e.attributes.normal;a.push(t)}}return Promise.all([Promise.all(s),Promise.all(a)]).then((function(t){const n=t[0],s=t[1];return r&&(e.morphAttributes.position=n),o&&(e.morphAttributes.normal=s),e.morphTargetsRelative=!0,e}))}(e,t.targets,n):e}))}function ln(e,t){let n=e.getIndex();if(null===n){const t=[],r=e.getAttribute("position");if(void 0===r)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<r.count;e++)t.push(e);e.setIndex(t),n=e.getIndex()}const r=n.count-2,s=[];if(t===o.TriangleFanDrawMode)for(let e=1;e<=r;e++)s.push(n.getX(0)),s.push(n.getX(e)),s.push(n.getX(e+1));else for(let e=0;e<r;e++)e%2==0?(s.push(n.getX(e)),s.push(n.getX(e+1)),s.push(n.getX(e+2))):(s.push(n.getX(e+2)),s.push(n.getX(e+1)),s.push(n.getX(e)));s.length/3!==r&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=e.clone();return a.setIndex(s),a}const cn={Handedness:Object.freeze({NONE:"none",LEFT:"left",RIGHT:"right"}),ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})};async function hn(e){const t=await fetch(e);if(t.ok)return t.json();throw new Error(t.statusText)}async function dn(e,t,n=null,r=!0){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No basePath supplied");const o=await async function(e){if(!e)throw new Error("No basePath supplied");return await hn(`${e}/profilesList.json`)}(t);let s;if(e.profiles.some((e=>{const n=o[e];return n&&(s={profileId:e,profilePath:`${t}/${n.path}`,deprecated:!!n.deprecated}),!!s})),!s){if(!n)throw new Error("No matching profile name found");const e=o[n];if(!e)throw new Error(`No matching profile name found and default profile "${n}" missing.`);s={profileId:n,profilePath:`${t}/${e.path}`,deprecated:!!e.deprecated}}const a=await hn(s.profilePath);let i;if(r){let t;if(t="any"===e.handedness?a.layouts[Object.keys(a.layouts)[0]]:a.layouts[e.handedness],!t)throw new Error(`No matching handedness, ${e.handedness}, in profile ${s.profileId}`);t.assetPath&&(i=s.profilePath.replace("profile.json",t.assetPath))}return{profile:a,assetPath:i}}const un={xAxis:0,yAxis:0,button:0,state:cn.ComponentState.DEFAULT};class pn{constructor(e){this.componentProperty=e.componentProperty,this.states=e.states,this.valueNodeName=e.valueNodeName,this.valueNodeProperty=e.valueNodeProperty,this.valueNodeProperty===cn.VisualResponseProperty.TRANSFORM&&(this.minNodeName=e.minNodeName,this.maxNodeName=e.maxNodeName),this.value=0,this.updateFromComponent(un)}updateFromComponent({xAxis:e,yAxis:t,button:n,state:r}){const{normalizedXAxis:o,normalizedYAxis:s}=function(e=0,t=0){let n=e,r=t;if(Math.sqrt(e*e+t*t)>1){const o=Math.atan2(t,e);n=Math.cos(o),r=Math.sin(o)}return{normalizedXAxis:.5*n+.5,normalizedYAxis:.5*r+.5}}(e,t);switch(this.componentProperty){case cn.ComponentProperty.X_AXIS:this.value=this.states.includes(r)?o:.5;break;case cn.ComponentProperty.Y_AXIS:this.value=this.states.includes(r)?s:.5;break;case cn.ComponentProperty.BUTTON:this.value=this.states.includes(r)?n:0;break;case cn.ComponentProperty.STATE:this.valueNodeProperty===cn.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(r):this.value=this.states.includes(r)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class mn{constructor(e,t){if(!(e&&t&&t.visualResponses&&t.gamepadIndices&&0!==Object.keys(t.gamepadIndices).length))throw new Error("Invalid arguments supplied");this.id=e,this.type=t.type,this.rootNodeName=t.rootNodeName,this.touchPointNodeName=t.touchPointNodeName,this.visualResponses={},Object.keys(t.visualResponses).forEach((e=>{const n=new pn(t.visualResponses[e]);this.visualResponses[e]=n})),this.gamepadIndices=Object.assign({},t.gamepadIndices),this.values={state:cn.ComponentState.DEFAULT,button:void 0!==this.gamepadIndices.button?0:void 0,xAxis:void 0!==this.gamepadIndices.xAxis?0:void 0,yAxis:void 0!==this.gamepadIndices.yAxis?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(e){if(this.values.state=cn.ComponentState.DEFAULT,void 0!==this.gamepadIndices.button&&e.buttons.length>this.gamepadIndices.button){const t=e.buttons[this.gamepadIndices.button];this.values.button=t.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,t.pressed||1===this.values.button?this.values.state=cn.ComponentState.PRESSED:(t.touched||this.values.button>cn.ButtonTouchThreshold)&&(this.values.state=cn.ComponentState.TOUCHED)}void 0!==this.gamepadIndices.xAxis&&e.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=e.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===cn.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>cn.AxisTouchThreshold&&(this.values.state=cn.ComponentState.TOUCHED)),void 0!==this.gamepadIndices.yAxis&&e.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=e.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===cn.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>cn.AxisTouchThreshold&&(this.values.state=cn.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach((e=>{e.updateFromComponent(this.values)}))}}class bn{constructor(e,t,n){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=e,this.assetUrl=n,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach((e=>{const t=this.layoutDescription.components[e];this.components[e]=new mn(e,t)})),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach((t=>{e.push(t.data)})),e}updateFromGamepad(){Object.values(this.components).forEach((e=>{e.updateFromGamepad(this.xrInputSource.gamepad)}))}}class fn extends o.Object3D{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap==e||(this.envMap=e,this.traverse((e=>{e.isMesh&&(e.material.envMap=this.envMap,e.material.needsUpdate=!0)}))),this}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach((e=>{Object.values(e.visualResponses).forEach((e=>{const{valueNode:t,minNode:n,maxNode:r,value:o,valueNodeProperty:s}=e;t&&(s===cn.VisualResponseProperty.VISIBILITY?t.visible=o:s===cn.VisualResponseProperty.TRANSFORM&&(t.quaternion.slerpQuaternions(n.quaternion,r.quaternion,o),t.position.lerpVectors(n.position,r.position,o)))}))})))}}function vn(e,t){!function(e,t){Object.values(e.components).forEach((e=>{const{type:n,touchPointNodeName:r,visualResponses:s}=e;if(n===cn.ComponentType.TOUCHPAD)if(e.touchPointNode=t.getObjectByName(r),e.touchPointNode){const t=new o.SphereGeometry(.001),n=new o.MeshBasicMaterial({color:255}),r=new o.Mesh(t,n);e.touchPointNode.add(r)}else console.warn(`Could not find touch dot, ${e.touchPointNodeName}, in touchpad component ${e.id}`);Object.values(s).forEach((e=>{const{valueNodeName:n,minNodeName:r,maxNodeName:o,valueNodeProperty:s}=e;if(s===cn.VisualResponseProperty.TRANSFORM){if(e.minNode=t.getObjectByName(r),e.maxNode=t.getObjectByName(o),!e.minNode)return void console.warn(`Could not find ${r} in the model`);if(!e.maxNode)return void console.warn(`Could not find ${o} in the model`)}e.valueNode=t.getObjectByName(n),e.valueNode||console.warn(`Could not find ${n} in the model`)}))}))}(e.motionController,t),e.envMap&&t.traverse((t=>{t.isMesh&&(t.material.envMap=e.envMap,t.material.needsUpdate=!0)})),e.add(t)}class gn{constructor(e=null){this.gltfLoader=e,this.path="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",this._assetCache={},this.gltfLoader||(this.gltfLoader=new mt)}createControllerModel(e){const t=new fn;let n=null;return e.addEventListener("connected",(e=>{const r=e.data;"tracked-pointer"===r.targetRayMode&&r.gamepad&&dn(r,this.path,"generic-trigger").then((({profile:e,assetPath:o})=>{t.motionController=new bn(r,e,o);const s=this._assetCache[t.motionController.assetUrl];if(s)n=s.scene.clone(),vn(t,n);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(t.motionController.assetUrl,(e=>{this._assetCache[t.motionController.assetUrl]=e,n=e.scene.clone(),vn(t,n)}),null,(()=>{throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`)}))}})).catch((e=>{console.warn(e)}))})),e.addEventListener("disconnected",(()=>{t.motionController=null,t.remove(n),n=null})),t}}class yn extends o.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this.movementSpeed=.5,this._isSelecting=!1,this._isSqueezing=!1;const n=ve(this,this.onSelectStart),r=ve(this,this.onSelectEnd),o=ve(this,this.onSqueezeStart),s=ve(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",o),this.controller.addEventListener("squeezeend",s)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}update(e){if(this._isSelecting){const t=new c;this.controller.getWorldDirection(t),t.normalize().multiplyScalar(-this.movementSpeed*e),this.position.flow(t)}}}class xn extends o.EventDispatcher{constructor(e,t){super(),this.position=e,this.controller=t,this._isSelecting=!1,this._isSqueezing=!1;const n=ve(this,this.onSelectStart),r=ve(this,this.onSelectEnd),o=ve(this,this.onSqueezeStart),s=ve(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",n),this.controller.addEventListener("selectend",r),this.controller.addEventListener("squeezestart",o),this.controller.addEventListener("squeezeend",s)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}get update(){if(void 0===this._update){const e=10,t=new c,n=new c;let r=[],s=0,a=!1;this._update=function(i){const l=new c;if(this.controller.getWorldDirection(l),l.normalize().multiplyScalar(1/e),n.add(l),a&&n.sub(r[s]),r[s]=l,a&&this._isSelecting){const e=n.clone().normalize(),r=t.clone().normalize(),s=(new o.Quaternion).setFromUnitVectors(e,r).normalize();this.position.applyQuaternion(s)}t.copy(n),s=(s+1)%e,0===s&&(a=!0)}}return this._update}}function wn(e,t,n){return class extends e{constructor(){super(t,n,...arguments)}}}class Tn{constructor(){}element(){throw new Error("Group: this method should be implemented")}shader(e){throw new Error("Group: this method should be implemented")}}class Sn extends Ve{constructor(e){super(e),this.fake=!0}identity(){return this}multiply(e){return this}premultiply(e){return this}invert(){return this}toIsometry(){return new s}equals(e){return!0}clone(){return new Sn}copy(e){return this}}var Rn=a(9188),Vn=a.n(Rn);class _n extends Tn{constructor(){super()}element(){return new Sn(this)}shader(e){e.addChunk(Vn())}}var Cn=a(8008),Mn=a.n(Cn);const In=/bool\s*(\w+)\(Point.*\)/m,En=/float\s*(\w+)\(ExtVector.*\)/m;class Dn{constructor(e,t,n,r,s,a){let i;if(this.set=e,this.uuid=o.MathUtils.generateUUID().replaceAll("-","_"),this.jsTest=t,this.glslTest=n,this.glslTestName=void 0,i=n.match(In),!i)throw new Error("Teleportation: unable to find the name of the GLSL test");if(this.glslTestName=i[1],this.elt=r,this.inv=void 0!==s?s:r.clone().invert(),this.glslCreepCustom=void 0,this.glslCreep=void 0,this.glslCreepName=void 0,void 0!==a){if(this.glslCreepCustom=!0,this.glslCreep=a,i=a.match(En),!i)throw new Error("Teleportation: unable to find the name of the GLSL creep");this.glslCreepName=i[1]}else this.glslCreepCustom=!1,this.glslCreepName=`creep${this.uuid}`,this.glslCreep=Mn()(this)}get name(){return void 0===this._name&&(this._name=`teleportation_${this.uuid}`),this._name}get usesCreepingCustom(){return this.set.usesCreeping&&this.glslCreepCustom}get usesCreepingBinary(){return this.set.creepingType===Fn&&!this.glslCreepCustom}shader(e){e.addChunk(this.glslTest),this.set.usesCreeping&&e.addChunk(this.glslCreep),e.addUniform(this.elt.name,"GroupElement",this.elt),e.addUniform(this.elt.name,"GroupElement",this.inv)}}var Pn=a(2792),Ln=a.n(Pn),kn=a(968),An=a.n(kn);const Bn=0,Nn=1,Fn=2;class Un{constructor(e=[],t=!1,n=Bn){this.teleportations=[],this.neighbors=e,this.usesNearestNeighbors=t,this.creepingType=n}get usesCreeping(){return this.creepingType===Nn||this.creepingType===Fn}add(e,t,n,r,o){return this.teleportations.push(new Dn(this,e,t,n,r,o)),this}get group(){return 0!==this.teleportations.length?this.teleportations[0].elt.group:new _n}shader(e){this.group.shader(e),e.addChunk(Ln());for(const t of this.teleportations)t.shader(e);for(const t of this.neighbors)e.addUniform(t.elt.name,"GroupElement",t.elt),e.addUniform(t.inv.name,"GroupElement",t.inv);e.addChunk(An()(this))}}class On extends ze{constructor(e){super(),this.maxDirs=e}get isLight(){return!0}get isGlobal(){throw new Error("Generic: this method should be implemented")}get isLocal(){return!this.isGlobal}glslDirections(){throw new Error("Light: this method should be implemented")}glslInstance(){return this.glslDirections()}}const Gn=new Un;var jn=a(3496),Hn=a.n(jn),zn=a(6077),Wn=a.n(zn);class qn extends We{constructor(){super()}get uniformType(){return""}static glslClass(){return Hn()}glslRender(){return Wn()(this)}}var Kn=a(6045),$n=a.n(Kn),Xn=a(8149),Qn=a.n(Xn);class Yn extends We{constructor(e={}){super(),this.color=void 0!==e.color?e.color:new o.Color(1,1,1),this.ambient=void 0!==e.ambient?e.ambient:.5,this.diffuse=void 0!==e.diffuse?e.diffuse:.4,this.specular=void 0!==e.specular?e.specular:.1;const t=this.ambient+this.diffuse+this.specular;this.ambient=this.ambient/t,this.diffuse=this.diffuse/t,this.specular=this.specular/t,this.shininess=void 0!==e.shininess?e.shininess:10,this.reflectivity=void 0!==e.reflectivity?e.reflectivity:new o.Color(0,0,0),this.lights=e.lights}get uniformType(){return"PhongMaterial"}get usesLight(){return!0}get isReflecting(){return!0}static glslClass(){return $n()}glslRender(){return Qn()(this)}shader(e){for(const t of this.lights)t.shader(e);super.shader(e)}}var Zn=a(2197),Jn=a.n(Zn),er=a(1215),tr=a.n(er);class nr extends We{constructor(e,t,n,r){super(),this.dir1=e,this.dir2=t,this.color1=n,this.color2=r}get uniformType(){return"CheckerboardMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return Jn()}glslRender(){return tr()(this)}}var rr=a(7793),or=a.n(rr),sr=a(9909),ar=a.n(sr);class ir extends We{constructor(){super()}get uniformType(){return""}get usesNormal(){return!1}get usesUVMap(){return!1}get usesLight(){return!1}get isReflecting(){return!1}static glslClass(){return or()}glslRender(){return ar()(this)}shader(e){super.shader(e)}}var lr=a(9095),cr=a.n(lr);class hr extends We{constructor(e,t={}){super(),this.sampler=(new o.TextureLoader).load(e),this.sampler.wrapS=void 0!==t.wrapS?t.wrapS:o.RepeatWrapping,this.sampler.wrapT=void 0!==t.wrapT?t.wrapT:o.RepeatWrapping,this.sampler.magFilter=o.LinearFilter,this.sampler.minFilter=o.LinearFilter,this.start=void 0!==t.start?t.start.clone():new o.Vector2(0,0),this.scale=void 0!==t.scale?t.scale.clone():new o.Vector2(1,1)}get uniformType(){return"SimpleTextureMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return cr()}glslRender(){return tr()(this)}}var dr=a(466);class ur extends hr{constructor(){super(dr,{start:new o.Vector2(-Math.PI,0),scale:new o.Vector2(1/(2*Math.PI),1/Math.PI)})}}var pr=a(2971);class mr extends hr{constructor(){super(pr,{start:new o.Vector2(-Math.PI,0),scale:new o.Vector2(1/(2*Math.PI),1/Math.PI)})}}var br=a(5753);class fr extends hr{constructor(){super(br,{start:new o.Vector2(-Math.PI,0),scale:new o.Vector2(1/(2*Math.PI),1/Math.PI)})}}var vr=a(8367);class gr extends hr{constructor(){super(vr,{start:new o.Vector2(-Math.PI,0),scale:new o.Vector2(1/(2*Math.PI),1/Math.PI)})}}var yr=a(3081),xr=a.n(yr);class wr extends We{constructor(e,t,n,r){super(),this.dir1=e,this.dir2=t;const s=void 0!==r?r:[.5,1,1,.5];let a=0;const i=[];for(let e=0;e<4;e++)void 0!==s[e]&&(a+=s[e]),i[e]=a;for(let e=0;e<4;e++)i[e]=i[e]/a;this.lengths=new o.Vector4(...i);let l=new o.Color(1,1,1);this.color0=void 0!==n[0]?n[0]:l.clone(),l=this.color0,this.color1=void 0!==n[1]?n[1]:l.clone(),l=this.color1,this.color2=void 0!==n[2]?n[2]:l.clone(),l=this.color2,this.color3=void 0!==n[3]?n[3]:l.clone()}get uniformType(){return"SquaresMaterial"}get usesNormal(){return!1}get usesUVMap(){return!0}static glslClass(){return xr()}glslRender(){return tr()(this)}}var Tr=a(5836),Sr=a.n(Tr),Rr=a(3838),Vr=a.n(Rr),_r=a(472),Cr=a.n(_r),Mr=a(8204),Ir=a.n(Mr),Er=a(7660),Dr=a.n(Er);class Pr extends We{constructor(e,t={}){super(),this.material=e,this.ambient=void 0!==t.ambient?t.ambient:.5,this.diffuse=void 0!==t.diffuse?t.diffuse:.5,this.specular=void 0!==t.specular?t.specular:.5,this.shininess=void 0!==t.shininess?t.shininess:10,this.reflectivity=void 0!==t.reflectivity?t.reflectivity:new o.Vector3(0,0,0),this.lights=t.lights}get uniformType(){return"PhongWrapMaterial"}static glslClass(){return Sr()}get usesNormal(){return!0}get usesUVMap(){return this.material.usesUVMap}get usesLight(){return!0}get isReflecting(){return!0}glslRender(){return this.material.usesNormal?this.material.usesUVMap?Dr()(this):Cr()(this):this.material.usesUVMap?Ir()(this):Vr()(this)}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e);for(const t of this.lights)t.shader(e);super.shader(e)}}function Lr(e,t={}){return new Pr(e,t)}var kr=a(7198),Ar=a.n(kr),Br=a(1202),Nr=a.n(Br),Fr=a(2330),Ur=a.n(Fr),Or=a(588),Gr=a.n(Or),jr=a(9040),Hr=a.n(jr),zr=a(1365),Wr=a.n(zr);class qr extends Ye{constructor(e,t){super(),this.material=e,this.emission=void 0!==t.emission?t.emission:new o.Color(0,0,0),this.volumeEmission=void 0!==t.volumeEmission?t.volumeEmission:new o.Color(0,0,0),this.opticalDepth=void 0!==t.opticalDepth?t.opticalDepth:0,this.specular=void 0!==t.specular?t.specular:new o.Color(1,1,1),this.absorb=void 0!==t.absorb?t.absorb:new o.Color(.1,.1,.1),this.ior=void 0!==t.ior?t.ior:1,this.roughness=void 0!==t.roughness?t.roughness:.2,this.reflectionChance=void 0!==t.reflectionChance?t.reflectionChance:.1,this.refractionChance=void 0!==t.refractionChance?t.refractionChance:0,this.diffuseChance=void 0!==t.diffuseChance?t.diffuseChance:.9;const n=this.reflectionChance+this.refractionChance+this.diffuseChance;this.reflectionChance=this.reflectionChance/n,this.refractionChance=this.refractionChance/n,this.diffuseChance=this.diffuseChance/n,this.addImport(rt())}get uniformType(){return"PathTracerWrapMaterial"}static glslClass(){return Ar()}get usesUVMap(){return this.material.usesUVMap}glslRender(){let e="";return e+=Nr()(this),this.material.usesNormal?this.material.usesUVMap?e+=Gr()(this):e+=Hr()(this):this.material.usesUVMap?e+=Wr()(this):e+=Ur()(this),e}setId(e){this.material.setId(e),super.setId(e)}onAdd(e){this.material.onAdd(e),super.onAdd(e)}shader(e){this.material.shader(e),super.shader(e)}}function Kr(e,t={}){return new qr(e,t)}var $r=a(8266),Xr=a.n($r);class Qr extends ze{constructor(e){super(),this.isom=void 0!==e?e:new s,this.isomInv=this.isom.clone().invert(),this.parent=void 0,this._absoluteIsom=void 0,this._absoluteIsomInv=void 0}updateAbsoluteIsom(){void 0===this._absoluteIsom&&(this._absoluteIsom=new s,this._absoluteIsomInv=new s),this.isomInv=this.isom.clone().invert(),this._absoluteIsom.copy(this.isom),this._absoluteIsomInv.copy(this.isomInv),void 0!==this.parent&&(this._absoluteIsom.premultiply(this.parent.absoluteIsom),this._absoluteIsomInv.multiply(this.parent.absoluteIsomInv))}updateData(){this.updateAbsoluteIsom()}get absoluteIsom(){return void 0===this._absoluteIsom&&this.updateAbsoluteIsom(),this._absoluteIsom}get absoluteIsomInv(){return void 0===this._absoluteIsomInv&&this.updateAbsoluteIsom(),this._absoluteIsomInv}get isShape(){return!0}get isBasicShape(){throw new Error("Shape: this method should be implemented")}get isAdvancedShape(){return!this.isBasicShape}get isGlobal(){throw new Error("Shape: this method should be implemented")}get isLocal(){return!this.isGlobal}get hasUVMap(){return!1}glslSDF(){throw new Error("Shape: this method should be implemented")}glslGradient(){return Xr()(this)}glslUVMap(){throw new Error("Shape: this method should be implemented")}glslInstance(){let e=this.glslSDF()+"\r\n"+this.glslGradient();return this.hasUVMap&&(e=e+"\r\n"+this.glslUVMap()),e}}class Yr extends Qr{constructor(e){super(e)}get isBasicShape(){return!1}}var Zr=a(7939),Jr=a.n(Zr),eo=a(6142),to=a.n(eo),no=a(7260),ro=a.n(no);class oo extends Yr{constructor(e){super(),this.shape=e,this.shape.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData()}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return Jr()(this)}glslGradient(){return to()(this)}glslUVMap(){return ro()(this)}setId(e){this.shape.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),super.onAdd(e)}shader(e){this.shape.shader(e),super.shader(e)}}function so(e){return new oo(e)}var ao=a(2093),io=a.n(ao),lo=a(2076),co=a.n(lo),ho=a(3335),uo=a.n(ho),po=a(6428),mo=a.n(po),bo=a(6861),fo=a.n(bo),vo=a(2905),go=a.n(vo),yo=a(7333),xo=a.n(yo);const wo=1;class To extends Yr{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("IntersectionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.maxType=void 0!==n.maxType?n.maxType:0,this.maxCoeff=0,this.maxType===wo)this.addImport(io()),this.maxCoeff=void 0!==n.maxCoeff?n.maxCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"IntersectionShape"}static glslClass(){return xo()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.maxType===wo?mo()(this):co()(this)}glslGradient(){return this.maxType===wo?fo()(this):uo()(this)}glslUVMap(){return go()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function So(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new To(e,arguments[r],t));return e}var Ro=a(5442),Vo=a.n(Ro),_o=a(3908),Co=a.n(_o),Mo=a(7762),Io=a.n(Mo),Eo=a(7500),Do=a.n(Eo),Po=a(3238),Lo=a.n(Po),ko=a(519),Ao=a.n(ko),Bo=a(8655),No=a.n(Bo);const Fo=1;class Uo extends Yr{constructor(e,t,n={}){if(e.isGlobal!==t.isGlobal)throw new Error("UnionShape: the two shapes should be both local or both global");if(super(),this.shape1=e,this.shape2=t,this.shape1.parent=this,this.shape2.parent=this,this.minType=void 0!==n.minType?n.minType:0,this.minCoeff=0,this.minType===Fo)this.addImport(Vo()),this.minCoeff=void 0!==n.minCoeff?n.minCoeff:.1}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape1.updateAbsoluteIsom(),this.shape2.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape1.updateData(),this.shape2.updateData()}get uniformType(){return"UnionShape"}static glslClass(){return Ao()}get isGlobal(){return this.shape1.isGlobal}get hasUVMap(){return this.shape1.hasUVMap&&this.shape2.hasUVMap}glslSDF(){return this.minType===Fo?Lo()(this):Co()(this)}glslGradient(){return this.minType===Fo?No()(this):Io()(this)}glslUVMap(){return Do()(this)}setId(e){this.shape1.setId(e),this.shape2.setId(e),super.setId(e)}onAdd(e){this.shape1.onAdd(e),this.shape2.onAdd(e),super.onAdd(e)}shader(e){this.shape1.shader(e),this.shape2.shader(e),super.shader(e)}}function Oo(){let e,t={};const n=arguments.length;if(0===n)throw new Error("union: the function expect at least one argument");arguments[n-1].isShape||(t=arguments[n-1]),e=arguments[0];for(let r=1;r<n;r++)arguments[r].isShape&&(e=new Uo(e,arguments[r],t));return e}var Go=a(3105),jo=a.n(Go),Ho=a(6242),zo=a.n(Ho),Wo=a(9338),qo=a.n(Wo);class Ko extends Yr{constructor(e,t){if(e.isGlobal!==t.isGlobal)throw new Error("WrapShape: the two shapes should be both local or both global");super(),this.wrap=e,this.shape=t,this.shape.parent=this,this.wrap.parent=this}updateAbsoluteIsom(){super.updateAbsoluteIsom(),this.shape.updateAbsoluteIsom(),this.wrap.updateAbsoluteIsom()}updateData(){super.updateData(),this.shape.updateData(),this.wrap.updateData()}get isWrapShape(){return!0}get isGlobal(){return this.shape.isGlobal}get hasUVMap(){return this.shape.hasUVMap}static glslClass(){return""}glslSDF(){return jo()(this)}glslGradient(){return zo()(this)}glslUVMap(){return qo()(this)}setId(e){this.wrap.setId(e),this.shape.setId(e),super.setId(e)}onAdd(e){this.wrap.onAdd(e),this.shape.onAdd(e),super.onAdd(e)}shader(e){this.wrap.shader(e),this.shape.shader(e),super.shader(e)}}function $o(e,t){return new Ko(e,t)}class Xo{constructor(e="i"){this.action=void 0,this.key=e;const t=ve(this,this.onKeyDown);window.addEventListener("keydown",t,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.action&&this.action()}}class Qo{constructor(e,t,n){this.controller=e,this.camera=t,this.solid=n,this._isSelecting=!1,this._isSqueezing=!1;const r=ve(this,this.onSelectStart),o=ve(this,this.onSelectEnd),s=ve(this,this.onSqueezeStart),a=ve(this,this.onSqueezeEnd);this.controller.addEventListener("selectstart",r),this.controller.addEventListener("selectend",o),this.controller.addEventListener("squeezestart",s),this.controller.addEventListener("squeezeend",a)}onSelectStart(){this._isSelecting=!0}onSelectEnd(){this._isSelecting=!1}onSqueezeStart(){this._isSqueezing=!0}onSqueezeEnd(){this._isSqueezing=!1}chase(e){this.solid.isRendered=this._isSelecting;const t=(new c).setFromMatrixPosition(this.controller.matrixWorld);let n=new c;if(this.camera.isStereoOn){const t=e.getCamera(this.camera.threeCamera).cameras,r=(new o.Vector3).setFromMatrixPosition(t[ye].matrixWorld),s=(new o.Vector3).setFromMatrixPosition(t[xe].matrixWorld);n.lerpVectors(r,s,.5)}else n.setFromMatrixPosition(this.camera.matrix);const r=t.clone().sub(n),s=this.controller.matrixWorld.clone().setPosition(r),a=this.camera.position.clone().fakeDiffExpMap(s);this.solid.isom.copy(a.globalBoost),this.solid.isom.matrix.multiply(a.facing),this.solid.updateData()}}class Yo{constructor(e="p"){this.actionKeyDown=void 0,this.actionKeyUp=void 0,this.key=e;const t=ve(this,this.onKeyDown),n=ve(this,this.onKeyUp);window.addEventListener("keydown",t,!1),window.addEventListener("keyup",n,!1)}onKeyDown(e){e.key===this.key&&void 0!==this.actionKeyDown&&this.actionKeyDown()}onKeyUp(e){e.key===this.key&&void 0!==this.actionKeyUp&&this.actionKeyUp()}}class Zo{constructor(e,t,n,r){this.controller=e,this.camera=t,this.solids=n,this.speed=r,this._status=0,this._nextBullet=0,this._clock=new o.Clock;const s=ve(this,this.onSelectStart),a=ve(this,this.onSelectEnd);this.controller.addEventListener("selectstart",s),this.controller.addEventListener("selectend",a)}onSelectStart(){0===this._status&&(this._status=1)}onSelectEnd(){}shoot(e){const t=this.solids[this._nextBullet];t.bulletData={time:this._clock.getElapsedTime(),position:e},t.isRendered=!0,this._nextBullet=(this._nextBullet+1)%this.solids.length}updateBullet(e){const t=this.solids[e];if(t.hasOwnProperty("bulletData")){const e=this._clock.getElapsedTime()-t.bulletData.time,n=t.bulletData.position.clone().flow(new c(0,0,-this.speed*e));t.isom.copy(n.boost),t.updateData()}}updateAllBullets(){for(let e=0;e<this.solids.length;e++)this.updateBullet(e)}update(e){if(1===this._status){const t=(new c).setFromMatrixPosition(this.controller.matrixWorld);let n=new c;if(this.camera.isStereoOn){const t=e.getCamera(this.camera.threeCamera).cameras,r=(new o.Vector3).setFromMatrixPosition(t[ye].matrixWorld),s=(new o.Vector3).setFromMatrixPosition(t[xe].matrixWorld);n.lerpVectors(r,s,.5)}else n.setFromMatrixPosition(this.camera.matrix);const r=t.clone().sub(n),s=this.controller.matrixWorld.clone().setPosition(r),a=this.camera.position.clone().fakeDiffExpMap(s);this.shoot(a.globalPosition),this._status=0}this.updateAllBullets()}}class Jo{constructor(e="p",t=2,n=0){this.key=e,this.stateNumber=t,this.state=n,this.justChanged=!1;const r=ve(this,this.onKeyDown);window.addEventListener("keydown",r,!1)}onKeyDown(e){e.key===this.key&&(this.state=(this.state+1)%this.stateNumber,this.justChanged=!0)}}class es{constructor(e,t,n){this.controller=e,this.camera=t,this.light=n}chase(e){const t=(new c).setFromMatrixPosition(this.controller.matrixWorld);let n=new c;if(this.camera.isStereoOn){const t=e.getCamera(this.camera.threeCamera).cameras,r=(new o.Vector3).setFromMatrixPosition(t[ye].matrixWorld),s=(new o.Vector3).setFromMatrixPosition(t[xe].matrixWorld);n.lerpVectors(r,s,.5)}else n.setFromMatrixPosition(this.camera.matrix);const r=t.clone().sub(n),s=this.controller.matrixWorld.clone().setPosition(r),a=this.camera.position.clone().fakeDiffExpMap(s);this.light.position=(new l).applyIsometry(a.globalBoost)}}class ts{constructor(e,t,n=!1,r){if(this.position=e,this.controller=t,this._reset=0,this._alignFacing=n,this._camera=r,this._alignFacing&&void 0===r)throw new Error("VRControlsReset.constructor, the camera is needed when the alignFacing option is on");const o=ve(this,this.onSelectStart),s=ve(this,this.onSelectEnd);this.controller.addEventListener("selectstart",o),this.controller.addEventListener("selectend",s)}onSelectStart(){this._reset=1}onSelectEnd(){}update(){if(1===this._reset){if(this.position.reset(),this._alignFacing){const e=this._camera.threeCamera.matrixWorld;this.position.local.quaternion.setFromRotationMatrix(e),this.position.local.quaternion.invert()}this._reset=0}}}class ns{constructor(e,t=0,n=0){this.ring=e,this.a=t,this.b=n,this.reduce()}reduce(){return this.a=Math.round(this.a),this.b=Math.round(this.b),this}negate(){return this.a=-this.a,this.b=-this.b,this}multiply(e){const t=this.a,n=this.b;return this.a=t*e.a+this.ring.d*n*e.b,this.b=t*e.b+n*e.a,this.reduce()}add(e){return this.a=this.a+e.a,this.b=this.b+e.b,this.reduce()}sub(e){return this.a=this.a-e.a,this.b=this.b-e.b,this.reduce()}sum(){this.copy(this.ring.zero);for(const e of arguments)this.add(e);return this}product(){this.copy(this.ring.one);for(const e of arguments)this.multiply(e);return this}addProduct(){const e=new ns(this.ring).product(...arguments);return this.add(e),this}subProduct(){const e=new ns(this.ring).product(...arguments);return this.sub(e),this}toNumber(){return this.a+this.b*Math.sqrt(this.ring.d)}equals(e){return this.a===e.a&&this.b===e.b}isZero(){return 0===this.a&&0===this.b}clone(){const e=new ns(this.ring);return e.a=this.a,e.b=this.b,e}copy(e){return this.a=e.a,this.b=e.b,this}toLog(){return`${this.a} + ${this.b} _rD`}}var rs=a(5688),os=a.n(rs);class ss{constructor(e){this.ring=e,this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()]}get isQuadRingMatrix4(){return!0}get a(){const e=this.toArray().map((e=>e.a));return(new o.Matrix4).fromArray(e)}get b(){const e=this.toArray().map((e=>e.b));return(new o.Matrix4).fromArray(e)}getEntry(e,t){return this.elements[4*t+e]}setEntry(e,t,n){return this.elements[4*t+e].copy(n),this}set(e,t,n,r,o,s,a,i,l,c,h,d,u,p,m,b){for(let e=0;e<4;e++)for(let t=0;t<4;t++)this.setEntry(e,t,arguments[4*e+t]);return this}identity(){return this.elements=[this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.zero.clone(),this.ring.one.clone()],this}multiplyMatrices(e,t){for(let n=0;n<4;n++)for(let r=0;r<4;r++){this.setEntry(n,r,this.ring.zero);for(let o=0;o<4;o++)this.getEntry(n,r).addProduct(e.getEntry(n,o),t.getEntry(o,r))}return this}multiply(e){return this.multiplyMatrices(this.clone(),e)}premultiply(e){return this.multiplyMatrices(e,this.clone())}multiplyScalar(e){for(let t=0;t<16;t++)this.elements[t].multiply(e);return this}transpose(){const e=this.elements;let t=this.ring.element();return t.copy(e[1]),e[1].copy(e[4]),e[4].copy(t),t.copy(e[2]),e[2].copy(e[8]),e[8].copy(t),t.copy(e[6]),e[6].copy(e[9]),e[9].copy(t),t.copy(e[3]),e[3].copy(e[12]),e[12].copy(t),t.copy(e[7]),e[7].copy(e[13]),e[13].copy(t),t.copy(e[11]),e[11].copy(e[14]),e[14].copy(t),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],o=e[3],s=e[4],a=e[5],i=e[6],l=e[7],c=e[8],h=e[9],d=e[10],u=e[11],p=e[12],m=e[13],b=e[14],f=e[15];return e[0]=this.ring.element().addProduct(h,b,l).subProduct(m,d,l).addProduct(m,i,u).subProduct(a,b,u).subProduct(h,i,f).addProduct(a,d,f),e[1]=this.ring.element().addProduct(m,d,o).subProduct(h,b,o).subProduct(m,r,u).addProduct(n,b,u).addProduct(h,r,f).subProduct(n,d,f),e[2]=this.ring.element().addProduct(a,b,o).subProduct(m,i,o).addProduct(m,r,l).subProduct(n,b,l).subProduct(a,r,f).addProduct(n,i,f),e[3]=this.ring.element().addProduct(h,i,o).subProduct(a,d,o).subProduct(h,r,l).addProduct(n,d,l).addProduct(a,r,u).subProduct(n,i,u),e[4]=this.ring.element().addProduct(p,d,l).subProduct(c,b,l).subProduct(p,i,u).addProduct(s,b,u).addProduct(c,i,f).subProduct(s,d,f),e[5]=this.ring.element().addProduct(c,b,o).subProduct(p,d,o).addProduct(p,r,u).subProduct(t,b,u).subProduct(c,r,f).addProduct(t,d,f),e[6]=this.ring.element().addProduct(p,i,o).subProduct(s,b,o).subProduct(p,r,l).addProduct(t,b,l).addProduct(s,r,f).subProduct(t,i,f),e[7]=this.ring.element().addProduct(s,d,o).subProduct(c,i,o).addProduct(c,r,l).subProduct(t,d,l).subProduct(s,r,u).addProduct(t,i,u),e[8]=this.ring.element().addProduct(c,m,l).subProduct(p,h,l).addProduct(p,a,u).subProduct(s,m,u).subProduct(c,a,f).addProduct(s,h,f),e[9]=this.ring.element().addProduct(p,h,o).subProduct(c,m,o).subProduct(p,n,u).addProduct(t,m,u).addProduct(c,n,f).subProduct(t,h,f),e[10]=this.ring.element().addProduct(s,m,o).subProduct(p,a,o).addProduct(p,n,l).subProduct(t,m,l).subProduct(s,n,f).addProduct(t,a,f),e[11]=this.ring.element().addProduct(c,a,o).subProduct(s,h,o).subProduct(c,n,l).addProduct(t,h,l).addProduct(s,n,u).subProduct(t,a,u),e[12]=this.ring.element().addProduct(p,h,i).subProduct(c,m,i).subProduct(p,a,d).addProduct(s,m,d).addProduct(c,a,b).subProduct(s,h,b),e[13]=this.ring.element().addProduct(c,m,r).subProduct(p,h,r).addProduct(p,n,d).subProduct(t,m,d).subProduct(c,n,b).addProduct(t,h,b),e[14]=this.ring.element().addProduct(p,a,r).subProduct(s,m,r).subProduct(p,n,i).addProduct(t,m,i).addProduct(s,n,b).subProduct(t,a,b),e[15]=this.ring.element().addProduct(s,h,r).subProduct(c,a,r).addProduct(c,n,i).subProduct(t,h,i).subProduct(s,n,d).addProduct(t,a,d),this}equals(e){for(let t=0;t<16;t++)if(!this.elements[t].equals(e.elements[t]))return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n].copy(e[n+t]);return this}toArray(e=[],t=0){const n=this.elements;for(let r=0;r<16;r++)e[t+r]=n[r].clone();return e}toMatrix4(){const e=this.toArray().map((e=>e.toNumber()));return(new o.Matrix4).fromArray(e)}clone(){return new ss(this.ring).fromArray(this.elements)}copy(e){return this.fromArray(e.elements)}toLog(){return this.toMatrix4().toLog()}}class as{constructor(e){this.d=e}element(e=0,t=0){return new ns(this,e,t)}matrix4(){return new ss(this)}get one(){return new ns(this,1)}get zero(){return new ns(this,0)}shader(e){e.addChunk(os()),e.addConstant("QUAD_RING_D","int",this.d)}}class is{constructor(){this.elements=[1,0,0,1]}set(e,t,n,r){return this.elements=[e,n,t,r],this}identity(){return this.set(1,0,0,1),this}multplyMatrices(e,t){const[n,r,o,s]=e.elements,[a,i,l,c]=t.elements;return this.elements=[n*a+o*i,r*a+s*i,n*l+o*c,r*l+s*c],this}multiply(e){return this.multplyMatrices(this,e)}premultiply(e){return this.multplyMatrices(e,this)}power(e){if(e<0)return this.invert().power(-e);if(0===e)return this.identity();if(1===e)return this;if(e%2==0)return this.power(e/2),this.multiply(this);{const t=this.clone();return this.power(e-1),this.multiply(t)}}determinant(){const[e,t,n,r]=this.elements;return e*r-n*t}invert(){const[e,t,n,r]=this.elements,o=this.determinant();return this.elements=[r/o,-t/o,-n/o,e/o],this}clone(){const e=new is;for(let t=0;t<4;t++)e.elements[t]=this.elements[t];return e}copy(e){for(let t=0;t<4;t++)this.elements[t]=e.elements[t];return this}equals(e){for(let t=0;t<4;t++)if(this.elements[t]!==e.elements[t])return!1;return!0}}class ls extends Ve{constructor(e){super(e),this.isom=new s}identity(){return this.isom.identity(),this}multiply(e){return this.isom.multiply(e.isom),this}premultiply(e){return this.isom.premultiply(e.isom),this}invert(){return this.isom.invert(),this}toIsometry(){return this.isom.clone()}equals(e){return this.isom.equals(e.isom)}clone(){const e=new ls;return e.isom.copy(this.isom),e}copy(e){return this.isom.copy(e.isom),this}}var cs=a(6097),hs=a.n(cs);class ds extends Tn{constructor(){super()}element(){return new ls(this)}shader(e){e.addChunk(hs())}}const us=new ds,ps=Math.sqrt(2),ms=1/ps,bs=new o.Vector4(1,0,-ms,0);const fs=`//\nbool testXp(Point p){\n    vec4 normal = vec4(1, 0, -${ms}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,vs=new o.Vector4(-1,0,-ms,0);const gs=`//\nbool testXn(Point p){\n    vec4 normal = vec4(-1, 0, -${ms}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,ys=new o.Vector4(0,1,-ms,0);const xs=`//\nbool testYp(Point p){\n    vec4 normal = vec4(0, 1, -${ms}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,ws=new o.Vector4(0,-1,-ms,0);const Ts=`//\nbool testYn(Point p){\n    vec4 normal = vec4(0, -1, -${ms}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`;const Ss=us.element(),Rs=us.element(),Vs=us.element(),_s=us.element(),Cs=us.element(),Ms=us.element(),Is=2*ps;Ss.isom.matrix.set(3,0,-Is,0,0,1,0,0,-Is,0,3,0,0,0,0,1),Rs.isom.matrix.set(3,0,Is,0,0,1,0,0,Is,0,3,0,0,0,0,1),Vs.isom.matrix.set(1,0,0,0,0,3,-Is,0,0,-Is,3,0,0,0,0,1),_s.isom.matrix.set(1,0,0,0,0,3,Is,0,0,Is,3,0,0,0,0,1),Cs.isom.makeTranslationFromDir(new c(0,0,-2)),Ms.isom.makeTranslationFromDir(new c(0,0,2));const Es=(new Un).add((function(e){return e.coords.dot(bs)>0}),fs,Ss,Rs).add((function(e){return e.coords.dot(vs)>0}),gs,Rs,Ss).add((function(e){return e.coords.dot(ys)>0}),xs,Vs,_s).add((function(e){return e.coords.dot(ws)>0}),Ts,_s,Vs).add((function(e){return e.coords.w>1}),"//\nbool testWp(Point p){\n    return p.coords.w > 1.;\n}\n",Cs,Ms).add((function(e){return e.coords.w<-1}),"//\nbool testWn(Point p){\n    return p.coords.w < -1.;\n}\n",Ms,Cs),Ds=new ds,Ps=Math.sqrt(2),Ls=Math.pow(2,.25),ks=1/Ls,As=Math.sqrt(1+Ps)/Ls,Bs=Math.asinh(ks),Ns=new o.Vector4(As,0,-ks,0);const Fs=`//\nbool testXp(Point p){\n    vec4 normal = vec4(${As}, 0, -${ks}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,Us=new o.Vector4(-As,0,-ks,0);const Os=`//\nbool testXn(Point p){\n    vec4 normal = vec4(-${As}, 0, -${ks}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,Gs=new o.Vector4(0,As,-ks,0);const js=`//\nbool testYp(Point p){\n    vec4 normal = vec4(0, ${As}, -${ks}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,Hs=new o.Vector4(0,-As,-ks,0);const zs=`//\nbool testYn(Point p){\n    vec4 normal = vec4(0, -${As}, -${ks}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`;const Ws=`//\nbool testWp(Point p){\n    return p.coords.w > ${Bs};\n}\n`;const qs=`//\nbool testWn(Point p){\n    return p.coords.w < -${Bs};\n}\n`,Ks=Ds.element(),$s=Ds.element(),Xs=Ds.element(),Qs=Ds.element(),Ys=Ds.element(),Zs=Ds.element(),Js=2*ks*As,ea=2*As*As-1;Ks.isom.matrix.set(ea,0,-Js,0,0,1,0,0,-Js,0,ea,0,0,0,0,1),$s.isom.matrix.set(ea,0,Js,0,0,1,0,0,Js,0,ea,0,0,0,0,1),Xs.isom.matrix.set(1,0,0,0,0,ea,-Js,0,0,-Js,ea,0,0,0,0,1),Qs.isom.matrix.set(1,0,0,0,0,ea,Js,0,0,Js,ea,0,0,0,0,1),Ys.isom.makeTranslationFromDir(new c(0,0,-2*Bs)),Zs.isom.makeTranslationFromDir(new c(0,0,2*Bs));const ta=(new Un).add((function(e){return e.coords.dot(Ns)>0}),Fs,Ks,$s).add((function(e){return e.coords.dot(Us)>0}),Os,$s,Ks).add((function(e){return e.coords.dot(Gs)>0}),js,Xs,Qs).add((function(e){return e.coords.dot(Hs)>0}),zs,Qs,Xs).add((function(e){return e.coords.w>Bs}),Ws,Ys,Zs).add((function(e){return e.coords.w<-Bs}),qs,Zs,Ys),na=new ds,ra=Math.sqrt(2),oa=Math.pow(2,.25),sa=1/oa,aa=Math.sqrt(1+ra)/oa,ia=(Math.asinh(sa),new o.Vector4(aa,0,-sa,0));const la=`//\nbool testXp(Point p){\n    vec4 normal = vec4(${aa}, 0, -${sa}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,ca=new o.Vector4(-aa,0,-sa,0);const ha=`//\nbool testXn(Point p){\n    vec4 normal = vec4(-${aa}, 0, -${sa}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,da=new o.Vector4(0,aa,-sa,0);const ua=`//\nbool testYp(Point p){\n    vec4 normal = vec4(0, ${aa}, -${sa}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`,pa=new o.Vector4(0,-aa,-sa,0);const ma=`//\nbool testYn(Point p){\n    vec4 normal = vec4(0, -${aa}, -${sa}, 0);\n    return dot(p.coords, normal) > 0.;\n}\n`;const ba=na.element(),fa=na.element(),va=na.element(),ga=na.element(),ya=2*sa*aa,xa=2*aa*aa-1;ba.isom.matrix.set(xa,0,-ya,0,0,1,0,0,-ya,0,xa,0,0,0,0,1),fa.isom.matrix.set(xa,0,ya,0,0,1,0,0,ya,0,xa,0,0,0,0,1),va.isom.matrix.set(1,0,0,0,0,xa,-ya,0,0,-ya,xa,0,0,0,0,1),ga.isom.matrix.set(1,0,0,0,0,xa,ya,0,0,ya,xa,0,0,0,0,1);const wa=(new Un).add((function(e){return e.coords.dot(ia)>0}),la,ba,fa).add((function(e){return e.coords.dot(ca)>0}),ha,fa,ba).add((function(e){return e.coords.dot(da)>0}),ua,va,ga).add((function(e){return e.coords.dot(pa)>0}),ma,ga,va),Ta=new ds;const Sa=Ta.element(),Ra=Ta.element();Sa.isom.makeTranslationFromDir(new c(0,0,-2)),Ra.isom.makeTranslationFromDir(new c(0,0,2));const Va=(new Un).add((function(e){return e.coords.w>1}),"//\nbool testWp(Point p){\n    return p.coords.w > 1.;\n}\n",Sa,Ra).add((function(e){return e.coords.w<-1}),"//\nbool testWn(Point p){\n    return p.coords.w < -1.;\n}\n",Ra,Sa);var _a=a(4761),Ca=a.n(_a),Ma=a(5912),Ia=a.n(Ma),Ea=a(3820),Da=a.n(Ea),Pa=a(6489),La=a.n(Pa),ka=a(7577),Aa=a.n(ka);class Ba extends On{constructor(e,t,n=1){super(1),this.color=e,this.intensity=n,this.position=t,this.addImport(Ia(),Ca(),Da())}get isGlobal(){return!0}get uniformType(){return"PointLight"}static glslClass(){return La()}glslDirections(){return Aa()(this)}}var Na=a(6671),Fa=a.n(Na);const Ua=1,Oa=-1;class Ga extends On{constructor(e,t=1,n=Ua){super(1),this.color=e,this.intensity=t,this.direction=n}get isGlobal(){return!0}get uniformType(){return"ESun"}static glslClass(){return Fa()}glslDirections(){return Aa()(this)}}var ja=a(6882),Ha=a.n(ja);class za extends We{constructor(e,t){super(),this.mainColor=e,this.weight=t}get uniformType(){return"VaryingColorMaterial"}get usesNormal(){return!1}static glslClass(){return Ha()}glslRender(){return Xe()(this)}}class Wa extends Qr{constructor(e){super(e)}get isBasicShape(){return!0}}var qa=a(3021),Ka=a.n(qa),$a=a(3707),Xa=a.n($a),Qa=a(5030),Ya=a.n(Qa);class Za extends Wa{constructor(e,t){const n=new s;if(e.isIsometry)n.copy(e);else if(e.isPoint)n.makeTranslation(e);else{if(!e.isVector)throw new Error("BallShape: this type of location is not implemented");n.makeTranslationFromDir(e)}super(n),this.radius=t,this._center=void 0,this.addImport(Ia(),Ca())}updateData(){super.updateData(),this._center=(new l).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isBallShape(){return!0}get isGlobal(){return!0}get uniformType(){return"BallShape"}get hasUVMap(){return!1}static glslClass(){return Ka()}glslSDF(){return Xa()(this)}glslGradient(){return Ya()(this)}}var Ja=a(9511),ei=a.n(Ja);class ti extends Wa{constructor(e,t){const n=new s;if(e.isIsometry)n.copy(e);else if(e.isPoint)n.makeTranslation(e);else{if(!e.isVector)throw new Error("BallShape: this type of location is not implemented");n.makeTranslationFromDir(e)}super(n),this.radius=t,this._center=void 0,this.addImport(Ia(),Ca())}updateData(){super.updateData(),this._center=(new l).applyIsometry(this.absoluteIsom)}get center(){return void 0===this._center&&this.updateData(),this._center}get isLocalBallShape(){return!0}get isGlobal(){return!1}get uniformType(){return"LocalBallShape"}get hasUVMap(){return!1}static glslClass(){return ei()}glslSDF(){return Xa()(this)}glslGradient(){return Ya()(this)}}var ni=a(7499),ri=a.n(ni);class oi extends ze{constructor(e,t,n){if(!e.hasUVMap){if(t.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map");if(void 0!==n&&n.usesUVMap)throw new Error("Solid: a material using UV coordinates cannot be applied to a shape without a UV map")}super(),this.shape=e,this.material=t,this.ptMaterial=n,this.isRendered=!0,this.addImport(ri())}get isSolid(){return!0}get isom(){return this.shape.isom}get absoluteIsom(){return this.shape.absoluteIsom}get isGlobal(){return this.shape.isGlobal}get isLocal(){return this.shape.isLocal}get uniformType(){return"Solid"}updateData(){this.shape.updateData()}setId(e){this.shape.setId(e),this.material.setId(e),super.setId(e)}onAdd(e){this.shape.onAdd(e),this.material.onAdd(e),super.onAdd(e)}static glslClass(){return""}glslInstance(){return""}shader(e){this.shape.shader(e),3===e.useCase&&void 0!==this.ptMaterial?this.ptMaterial.shader(e):this.material.shader(e),super.shader(e)}}class si extends oi{constructor(e,t,n,r){super(new Za(e,t),n,r)}}class ai extends oi{constructor(e,t,n,r){super(new ti(e,t),n,r)}}const ii=Te($,u(),m()),li=Te(be,u(),m()),ci=Te(we,u(),m()),hi=wn(class{constructor(e,t,n,r={}){this.set=n,this.callback=void 0;const s=new dt(new o.Color(0,0,0),.07);this.scene=new st({fog:s}),this.camera=new Le({set:this.set}),this.ptCamera=new He({set:this.set}),this.threeRenderer=new o.WebGLRenderer,this.threeRenderer.setClearColor(new o.Color(0,0,.2),1),document.body.appendChild(this.threeRenderer.domElement),this.renderer=new $(e,t,this.set,this.camera,this.scene,{},this.threeRenderer),this.ptRenderer=new be(e,t,this.set,this.ptCamera,this.scene,{},this.threeRenderer),this.currentRenderer=this.renderer,this.setSize(window.innerWidth,window.innerHeight),this._onWindowResize=ve(this,this.onWindowResize),window.addEventListener("resize",this._onWindowResize,!1),this.flyControls=new Me(this.camera,void 0!==r.keyboard?r.keyboard:"us"),this.clock=new o.Clock,this.stats=void 0,this.gui=void 0,this.pathTracerUI=void 0,this.onLoad()}onLoad(){const e=document.createElement("style");e.setAttribute("type","text/css"),e.textContent=pt.trim(),document.head.appendChild(e),document.body.insertAdjacentHTML("beforeend",'\n<div id="thurstonDialogBoxWrap">\n    <div id="thurstonDialogBox">\n    <p>\n        Choose the resolution of the picture, and click on "Go".\n        You can download the image any time, with the "Download" button in the bottom right corner.\n        To leave the path tracer mode, hit \'p\'.\n    </p>\n        <form action="javascript:void(0);">\n            <label for="widthInput">Width :</label> <input id="widthInput" type="number"><br>\n            <label for="heightInput">Height:</label> <input id="heightInput" type="number"><br>\n            <input type="submit" value="Go!">\n        </form>\n    </div>\n</div>\n'),document.body.insertAdjacentHTML("beforeend",'\n<a id="thurstonDownloadButton" href="#">Download</a>\n')}setPixelRatio(e){this.renderer.setPixelRatio(e),this.ptRenderer.setPixelRatio(e)}setSize(e,t){this.renderer.setSize(e,t),this.ptRenderer.setSize(e,t)}initGUI(){this.gui=new Se.GUI,this.gui.close(),this.gui.add({help:function(){window.open("https://github.com/henryseg/non-euclidean_VR")}},"help").name("Help/About"),this.gui.add(this.flyControls,"keyboard",{QWERTY:"us",AZERTY:"fr"}).name("Keyboard");const e=this.gui.addFolder("Camera");return e.add(this.camera,"fov",45,120).name("Field of view"),e.add(this.camera,"maxDist",0,100,1).name("Max distance"),e.add(this.camera,"maxSteps",20,500,1).name("Max steps"),e.add(this.camera,"threshold").name("Threshold"),this}initStats(){return this.stats=new Re.default,this.stats.showPanel(0),document.body.appendChild(this.stats.dom),this}initPathTracerUI(){this.pathTracerUI=new ut(this)}add(e){this.scene.add(...arguments)}onWindowResize(e){this.renderer.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}switchRenderer(){this.currentRenderer.isBasicRenderer?(this.flyControls.pause(),window.removeEventListener("resize",this._onWindowResize),this.ptCamera.position.copy(this.camera.position),this.ptRenderer.iFrame=0,this.threeRenderer.setRenderTarget(this.ptRenderer.accReadTarget),this.threeRenderer.clear(),this.currentRenderer=this.ptRenderer):(this.flyControls.restore(),window.addEventListener("resize",this._onWindowResize),this.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.currentRenderer=this.renderer)}animate(){const e=this.clock.getDelta();void 0!==this.callback&&this.callback(),this.flyControls.update(e),this.currentRenderer.render(),this.stats.update()}run(){this.initStats(),this.initGUI(),this.initPathTracerUI(),this.renderer.build(),this.ptRenderer.build();const e=ve(this,this.animate);this.threeRenderer.setAnimationLoop(e)}},u(),m()),di=wn(class{constructor(e,t,n,r={}){this.set=n,this.callback=void 0;const s=new dt(new o.Color(0,0,0),.07);this.scene=new st({fog:s}),this.camera=new Le({set:this.set}),this.renderer=new $(e,t,this.set,this.camera,this.scene,{}),this.setPixelRatio(window.devicePixelRatio),this.setSize(window.innerWidth,window.innerHeight),this.renderer.setClearColor(new o.Color(0,0,.2),1),document.body.appendChild(this.renderer.domElement);const a=ve(this,this.onWindowResize);window.addEventListener("resize",a,!1),this.flyControls=new Me(this.camera,void 0!==r.keyboard?r.keyboard:"us"),this.clock=new o.Clock,this.stats=void 0,this.gui=void 0}setPixelRatio(e){this.renderer.setPixelRatio(e)}setSize(e,t){this.renderer.setSize(e,t)}initGUI(){this.gui=new Se.GUI,this.gui.close(),this.gui.add({help:function(){window.open("https://github.com/henryseg/non-euclidean_VR")}},"help").name("Help/About"),this.gui.add(this.flyControls,"keyboard",{QWERTY:"us",AZERTY:"fr"}).name("Keyboard");const e=this.gui.addFolder("Camera");return e.add(this.camera,"fov",45,120).name("Field of view"),e.add(this.camera,"maxDist",0,100,1).name("Max distance"),e.add(this.camera,"maxSteps",20,500,1).name("Max steps"),e.add(this.camera,"threshold").name("Threshold"),this}initStats(){return this.stats=new Re.default,this.stats.showPanel(0),document.body.appendChild(this.stats.dom),this}add(e){this.scene.add(...arguments)}onWindowResize(e){this.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}animate(){const e=this.clock.getDelta();this.flyControls.update(e),this.renderer.render(),void 0!==this.callback&&this.callback(),this.stats.update()}run(){this.initStats(),this.initGUI(),this.renderer.build();const e=ve(this,this.animate);this.renderer.threeRenderer.setAnimationLoop(e)}},u(),m()),ui=wn(class{constructor(e,t,n,r={}){this.set=n,this.callback=void 0,this.camera=void 0!==r.camera?r.camera:new Fe({set:this.set});const s=new dt(new o.Color(0,0,0),.07);this.scene=new st({fog:s}),this.renderer=new we(e,t,this.set,this.camera,this.scene),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(window.innerWidth,window.innerHeight),this.renderer.setClearColor(new o.Color(0,0,.2),1),document.body.appendChild(this.renderer.domElement);const a=ve(this,this.onWindowResize);window.addEventListener("resize",a,!1),this.flyControls=new Me(this.camera,void 0!==r.keyboard?r.keyboard:"us"),this.clock=new o.Clock,this.stats=void 0,this.gui=void 0;const i=new gn,l=this.renderer.xr.getControllerGrip(0),c=i.createControllerModel(l);l.add(c),this.renderer.threeScene.add(l);const h=this.renderer.xr.getControllerGrip(1),d=i.createControllerModel(h);h.add(d),this.renderer.threeScene.add(h);const u=this.renderer.xr.getController(0);this.renderer.threeScene.add(u);const p=this.renderer.xr.getController(1);this.renderer.threeScene.add(p),this.VRControlsMove=new yn(this.camera.position,u),this.VRControlsDrag=new xn(this.camera.position,p)}initGUI(){this.gui=new Se.GUI,this.gui.close(),this.gui.add({help:function(){window.open("https://github.com/henryseg/non-euclidean_VR")}},"help").name("Help/About"),this.gui.add(this.flyControls,"keyboard",{QWERTY:"us",AZERTY:"fr"}).name("Keyboard");const e=this.gui.addFolder("Camera");return e.add(this.camera,"fov",45,120).name("Field of view"),e.add(this.camera,"maxDist",0,100,1).name("Max distance"),e.add(this.camera,"maxSteps",20,500,1).name("Max steps"),e.add(this.camera,"threshold").name("Threshold"),this}initStats(){return this.stats=new Re.default,this.stats.showPanel(0),document.body.appendChild(this.stats.dom),this}add(e){this.scene.add(...arguments)}onWindowResize(e){this.renderer.setSize(window.innerWidth,window.innerHeight),this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix()}animate(){const e=this.clock.getDelta();void 0!==this.callback&&this.callback(),this.flyControls.update(e),this.VRControlsMove.update(e),this.VRControlsDrag.update(e),this.renderer.render(),this.stats.update()}run(){this.initStats(),this.initGUI(),this.renderer.build();const e=ve(this,this.animate);this.renderer.setAnimationLoop(e)}},u(),m())})();var l=i.ec,c=i.Yb,h=i.QU,d=i.ZH,u=i.K9,p=i.cK,m=i._x,b=i.kj,f=i.Vz,v=i.Iy,g=i.ik,y=i.fY,x=i.TB,w=i.Al,T=i.Gj,S=i.KO,R=i.c$,V=i.mD,_=i.yb,C=i.ZA,M=i.Jz,I=i.HZ,E=i.TN,D=i.JV,P=i.Sc,L=i.Nh,k=i.RL,A=i._k,B=i.uR,N=i.jo,F=i.Q,U=i.Qv,O=i.F5,G=i.Uc,j=i.Yu,H=i.Fh,z=i.oB,W=i.pJ,q=i.GW,K=i.DZ,$=i._K,X=i.JF,Q=i.Lv,Y=i.E9,Z=i.ce,J=i.Ly,ee=i.iv,te=i.mH,ne=i.xd,re=i.pX,oe=i.Dz,se=i.Uj,ae=i.cV,ie=i.lR,le=i.xs,ce=i.oC,he=i.h8,de=i.Qf,ue=i.k1,pe=i._D,me=i.$p,be=i.xG,fe=i.qC,ve=i.N$,ge=i.TO,ye=i.yI,xe=i.E6,we=i.zO,Te=i.cB,Se=i.OW,Re=i.$9,Ve=i.iR,_e=i.ak,Ce=i.Cy,Me=i.Y7,Ie=i.jV,Ee=i.mm,De=i.wS,Pe=i.IJ,Le=i.cR,ke=i.p2,Ae=i.dV,Be=i.G0,Ne=i.re,Fe=i.xS;export{l as Ball,c as BallShape,h as BasicCamera,d as BasicPTMaterial,u as BasicRenderer,p as CREEPING_FULL,m as CREEPING_OFF,b as CREEPING_STRICT,f as CheckerboardMaterial,v as ComplementShape,g as DIR_DOWN,y as DIR_UP,x as DebugMaterial,w as DragVRControls,T as ESun,S as EarthTexture,R as ExpFog,V as FlyControls,_ as Fog,C as Group,M as GroupElement,I as InfoControls,E as IntersectionShape,D as Isometry,P as IsotropicChaseVRControls,L as KeyGenericControls,k as LEFT,A as Light,B as LightVRControls,N as LocalBall,F as LocalBallShape,U as MarsTexture,O as Material,G as Matrix2,j as MoonTexture,H as MoveVRControls,z as NormalMaterial,W as PTMaterial,q as PathTracerCamera,K as PathTracerRenderer,$ as PathTracerWrapMaterial,X as PhongMaterial,Q as PhongWrapMaterial,Y as Point,Z as PointLight,J as Position,ee as QuadRing,te as QuadRingElement,ne as QuadRingMatrix4,re as RIGHT,oe as RelPosition,se as ResetVRControls,ae as SMOOTH_MAX_POLY,ie as SMOOTH_MIN_POLY,le as Scene,ce as ShootVRControls,he as SingleColorMaterial,de as Solid,ue as SquaresMaterial,pe as SunTexture,me as SwitchControls,be as TeleportationSet,fe as Thurston,ve as ThurstonLite,ge as ThurstonVR,ye as UnionShape,xe as VRCamera,we as VRRenderer,Te as VaryingColorMaterial,Se as Vector,Re as WrapShape,Ve as XRControllerModelFactory,_e as bind,Ce as complement,Me as cuspedTorusSet,Ie as intersection,Ee as orbiTorusSet,De as pathTracerWrap,Pe as phongWrap,Le as planeSet,ke as safeString,Ae as trivialSet,Be as union,Ne as wrap,Fe as zLoopSet};